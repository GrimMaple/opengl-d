/**
 * This is a set of OpenGL bindings.
 *
 * Generated by ./ogl_gen ....
 * Do not modify. Regenerate if changes are required.
 *
 * Macros:
 *    D_CODE = <pre><code class="D">$0</code></pre>
 */
module opengl.gl2;
import std.traits : Unqual;

alias int64_t = long;
alias uint64_t = ulong;
alias int32_t = int;

///
alias GLboolean = bool;
///
alias GLbyte = byte;
///
alias GLubyte = ubyte;
///
alias GLshort = short;
///
alias GLushort = ushort;
///
alias GLhalf = ushort;
///
alias GLint = int;
///
alias GLuint = uint;
///
alias GLfixed = int;
///
alias GLint64 = long;
///
alias GLuint64 = ulong;
///
alias GLsizei = uint;
///
alias GLenum = uint;
///
alias GLintptr = ptrdiff_t;
///
alias GLsizeiptr = ptrdiff_t;
///
alias GLsync = void*;
///
alias GLbitfield = uint;
///
alias GLfloat = float;
///
alias GLclampf = float;
///
alias GLdouble = double;
///
alias GLclampd = double;
///
alias GLclampx = int;
///
alias GLchar = char;
///
alias GLuintptr = size_t;
///
alias GLvoid = void;
///
alias GLeglImageOES = void*;
///
alias GLcharARB = char;
///
alias GLhandleARB = uint;
///
alias GLhalfARB = ushort;
///
alias Glfixed = GLint;

///
struct _cl_context;
///
struct _cl_event;

///
alias GLDEBUGPROC = void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);
///
alias GLDEBUGPROCARB = void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);
///
alias GLDEBUGPROCKHR = void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

///
alias GLintptrARB = ptrdiff_t;
///
alias GLsizeiptrARB = ptrdiff_t;
///
alias GLint64EXT = int64_t;
///
alias GLuint64EXT = uint64_t;

///
alias GLDEBUGPROCAMD = void function(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);
///
alias GLhalfNV = ushort;
///
alias GLvdpauSurfaceNV = GLintptr;

///
struct GLUnurbs;
///
struct GLUquadric;
///
struct GLUtesselator;
///
alias _GLUfuncptr = void function();

struct OpenGL_Version {
	OGLIntroducedIn from;
}

struct OpenGL_Extension {
	string name;
}

enum OGLIntroducedIn : ushort {
	Unknown,
	V1P0 = 10,
	V1P1 = 11,
	V1P2 = 12,
	V1P3 = 13,
	V1P4 = 14,
	V1P5 = 15,
	V2P0 = 25,
	V2P1 = 21,
	V2P2 = 22,
	V3P0 = 30,
	V3P1 = 31,
	V3P2 = 32,
	V3P3 = 33,
	V4P0 = 40,
	V4P1 = 41,
	V4P2 = 42,
	V4P3 = 43,
	V4P4 = 44,
	V4P5 = 45,
}

struct Bitmaskable {}
enum GL_1PASS_EXT = 0x80A1; ///
enum GL_1PASS_SGIS = 0x80A1; ///
enum GL_2D = 0x0600; ///
enum GL_2PASS_0_EXT = 0x80A2; ///
enum GL_2PASS_0_SGIS = 0x80A2; ///
enum GL_2PASS_1_EXT = 0x80A3; ///
enum GL_2PASS_1_SGIS = 0x80A3; ///
enum GL_2X_BIT_ATI = 0x00000001; ///
enum GL_2_BYTES = 0x1407; ///
enum GL_2_BYTES_NV = 0x1407; ///
enum GL_3D = 0x0601; ///
enum GL_3DC_XY_AMD = 0x87FA; ///
enum GL_3DC_X_AMD = 0x87F9; ///
enum GL_3D_COLOR = 0x0602; ///
enum GL_3D_COLOR_TEXTURE = 0x0603; ///
enum GL_3_BYTES = 0x1408; ///
enum GL_3_BYTES_NV = 0x1408; ///
enum GL_422_AVERAGE_EXT = 0x80CE; ///
enum GL_422_EXT = 0x80CC; ///
enum GL_422_REV_AVERAGE_EXT = 0x80CF; ///
enum GL_422_REV_EXT = 0x80CD; ///
enum GL_4D_COLOR_TEXTURE = 0x0604; ///
enum GL_4PASS_0_EXT = 0x80A4; ///
enum GL_4PASS_0_SGIS = 0x80A4; ///
enum GL_4PASS_1_EXT = 0x80A5; ///
enum GL_4PASS_1_SGIS = 0x80A5; ///
enum GL_4PASS_2_EXT = 0x80A6; ///
enum GL_4PASS_2_SGIS = 0x80A6; ///
enum GL_4PASS_3_EXT = 0x80A7; ///
enum GL_4PASS_3_SGIS = 0x80A7; ///
enum GL_4X_BIT_ATI = 0x00000002; ///
enum GL_4_BYTES = 0x1409; ///
enum GL_4_BYTES_NV = 0x1409; ///
enum GL_8X_BIT_ATI = 0x00000004; ///
enum GL_ABGR_EXT = 0x8000; ///
enum GL_ACCUM = 0x0100; ///
enum GL_ACCUM_ADJACENT_PAIRS_NV = 0x90AD; ///
enum GL_ACCUM_ALPHA_BITS = 0x0D5B; ///
enum GL_ACCUM_BLUE_BITS = 0x0D5A; ///
enum GL_ACCUM_BUFFER_BIT = 0x00000200; ///
enum GL_ACCUM_CLEAR_VALUE = 0x0B80; ///
enum GL_ACCUM_GREEN_BITS = 0x0D59; ///
enum GL_ACCUM_RED_BITS = 0x0D58; ///
enum GL_ACTIVE_ATOMIC_COUNTER_BUFFERS = 0x92D9; ///
enum GL_ACTIVE_ATTRIBUTES = 0x8B89; ///
enum GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A; ///
enum GL_ACTIVE_PROGRAM = 0x8259; ///
enum GL_ACTIVE_PROGRAM_EXT = 0x8B8D; ///
enum GL_ACTIVE_RESOURCES = 0x92F5; ///
enum GL_ACTIVE_STENCIL_FACE_EXT = 0x8911; ///
enum GL_ACTIVE_SUBROUTINES = 0x8DE5; ///
enum GL_ACTIVE_SUBROUTINE_MAX_LENGTH = 0x8E48; ///
enum GL_ACTIVE_SUBROUTINE_UNIFORMS = 0x8DE6; ///
enum GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47; ///
enum GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49; ///
enum GL_ACTIVE_TEXTURE = 0x84E0; ///
enum GL_ACTIVE_TEXTURE_ARB = 0x84E0; ///
enum GL_ACTIVE_UNIFORMS = 0x8B86; ///
enum GL_ACTIVE_UNIFORM_BLOCKS = 0x8A36; ///
enum GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35; ///
enum GL_ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87; ///
enum GL_ACTIVE_VARIABLES = 0x9305; ///
enum GL_ACTIVE_VARYINGS_NV = 0x8C81; ///
enum GL_ACTIVE_VARYING_MAX_LENGTH_NV = 0x8C82; ///
enum GL_ACTIVE_VERTEX_UNITS_ARB = 0x86A5; ///
enum GL_ADD = 0x0104; ///
enum GL_ADD_ATI = 0x8963; ///
enum GL_ADD_BLEND_IMG = 0x8C09; ///
enum GL_ADD_SIGNED = 0x8574; ///
enum GL_ADD_SIGNED_ARB = 0x8574; ///
enum GL_ADD_SIGNED_EXT = 0x8574; ///
enum GL_ADJACENT_PAIRS_NV = 0x90AE; ///
enum GL_AFFINE_2D_NV = 0x9092; ///
enum GL_AFFINE_3D_NV = 0x9094; ///
enum GL_ALIASED_LINE_WIDTH_RANGE = 0x846E; ///
enum GL_ALIASED_POINT_SIZE_RANGE = 0x846D; ///
enum GL_ALLOW_DRAW_FRG_HINT_PGI = 0x1A210; ///
enum GL_ALLOW_DRAW_MEM_HINT_PGI = 0x1A211; ///
enum GL_ALLOW_DRAW_OBJ_HINT_PGI = 0x1A20E; ///
enum GL_ALLOW_DRAW_WIN_HINT_PGI = 0x1A20F; ///
enum GL_ALL_ATTRIB_BITS = 0xFFFFFFFF; ///
enum GL_ALL_BARRIER_BITS = 0xFFFFFFFF; ///
enum GL_ALL_BARRIER_BITS_EXT = 0xFFFFFFFF; ///
enum GL_ALL_COMPLETED_NV = 0x84F2; ///
enum GL_ALL_SHADER_BITS = 0xFFFFFFFF; ///
enum GL_ALL_SHADER_BITS_EXT = 0xFFFFFFFF; ///
enum GL_ALL_STATIC_DATA_IBM = 0x103060; ///
enum GL_ALPHA = 0x1906; ///
enum GL_ALPHA12 = 0x803D; ///
enum GL_ALPHA12_EXT = 0x803D; ///
enum GL_ALPHA16 = 0x803E; ///
enum GL_ALPHA16F_ARB = 0x881C; ///
enum GL_ALPHA16F_EXT = 0x881C; ///
enum GL_ALPHA16I_EXT = 0x8D8A; ///
enum GL_ALPHA16UI_EXT = 0x8D78; ///
enum GL_ALPHA16_EXT = 0x803E; ///
enum GL_ALPHA16_SNORM = 0x9018; ///
enum GL_ALPHA32F_ARB = 0x8816; ///
enum GL_ALPHA32F_EXT = 0x8816; ///
enum GL_ALPHA32I_EXT = 0x8D84; ///
enum GL_ALPHA32UI_EXT = 0x8D72; ///
enum GL_ALPHA4 = 0x803B; ///
enum GL_ALPHA4_EXT = 0x803B; ///
enum GL_ALPHA8 = 0x803C; ///
enum GL_ALPHA8I_EXT = 0x8D90; ///
enum GL_ALPHA8UI_EXT = 0x8D7E; ///
enum GL_ALPHA8_EXT = 0x803C; ///
enum GL_ALPHA8_OES = 0x803C; ///
enum GL_ALPHA8_SNORM = 0x9014; ///
enum GL_ALPHA_BIAS = 0x0D1D; ///
enum GL_ALPHA_BITS = 0x0D55; ///
enum GL_ALPHA_FLOAT16_APPLE = 0x881C; ///
enum GL_ALPHA_FLOAT16_ATI = 0x881C; ///
enum GL_ALPHA_FLOAT32_APPLE = 0x8816; ///
enum GL_ALPHA_FLOAT32_ATI = 0x8816; ///
enum GL_ALPHA_INTEGER = 0x8D97; ///
enum GL_ALPHA_INTEGER_EXT = 0x8D97; ///
enum GL_ALPHA_MAX_CLAMP_INGR = 0x8567; ///
enum GL_ALPHA_MAX_SGIX = 0x8321; ///
enum GL_ALPHA_MIN_CLAMP_INGR = 0x8563; ///
enum GL_ALPHA_MIN_SGIX = 0x8320; ///
enum GL_ALPHA_REF_COMMAND_NV = 0x000F; ///
enum GL_ALPHA_SCALE = 0x0D1C; ///
enum GL_ALPHA_SNORM = 0x9010; ///
enum GL_ALPHA_TEST = 0x0BC0; ///
enum GL_ALPHA_TEST_FUNC = 0x0BC1; ///
enum GL_ALPHA_TEST_FUNC_QCOM = 0x0BC1; ///
enum GL_ALPHA_TEST_QCOM = 0x0BC0; ///
enum GL_ALPHA_TEST_REF = 0x0BC2; ///
enum GL_ALPHA_TEST_REF_QCOM = 0x0BC2; ///
enum GL_ALREADY_SIGNALED = 0x911A; ///
enum GL_ALREADY_SIGNALED_APPLE = 0x911A; ///
enum GL_ALWAYS = 0x0207; ///
enum GL_ALWAYS_FAST_HINT_PGI = 0x1A20C; ///
enum GL_ALWAYS_SOFT_HINT_PGI = 0x1A20D; ///
enum GL_AMBIENT = 0x1200; ///
enum GL_AMBIENT_AND_DIFFUSE = 0x1602; ///
enum GL_AND = 0x1501; ///
enum GL_AND_INVERTED = 0x1504; ///
enum GL_AND_REVERSE = 0x1502; ///
enum GL_ANY_SAMPLES_PASSED = 0x8C2F; ///
enum GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A; ///
enum GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT = 0x8D6A; ///
enum GL_ANY_SAMPLES_PASSED_EXT = 0x8C2F; ///
enum GL_ARC_TO_NV = 0xFE; ///
enum GL_ARRAY_BUFFER = 0x8892; ///
enum GL_ARRAY_BUFFER_ARB = 0x8892; ///
enum GL_ARRAY_BUFFER_BINDING = 0x8894; ///
enum GL_ARRAY_BUFFER_BINDING_ARB = 0x8894; ///
enum GL_ARRAY_ELEMENT_LOCK_COUNT_EXT = 0x81A9; ///
enum GL_ARRAY_ELEMENT_LOCK_FIRST_EXT = 0x81A8; ///
enum GL_ARRAY_OBJECT_BUFFER_ATI = 0x8766; ///
enum GL_ARRAY_OBJECT_OFFSET_ATI = 0x8767; ///
enum GL_ARRAY_SIZE = 0x92FB; ///
enum GL_ARRAY_STRIDE = 0x92FE; ///
enum GL_ASYNC_DRAW_PIXELS_SGIX = 0x835D; ///
enum GL_ASYNC_HISTOGRAM_SGIX = 0x832C; ///
enum GL_ASYNC_MARKER_SGIX = 0x8329; ///
enum GL_ASYNC_READ_PIXELS_SGIX = 0x835E; ///
enum GL_ASYNC_TEX_IMAGE_SGIX = 0x835C; ///
enum GL_ATC_RGBA_EXPLICIT_ALPHA_AMD = 0x8C93; ///
enum GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD = 0x87EE; ///
enum GL_ATC_RGB_AMD = 0x8C92; ///
enum GL_ATOMIC_COUNTER_BARRIER_BIT = 0x00001000; ///
enum GL_ATOMIC_COUNTER_BARRIER_BIT_EXT = 0x00001000; ///
enum GL_ATOMIC_COUNTER_BUFFER = 0x92C0; ///
enum GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5; ///
enum GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6; ///
enum GL_ATOMIC_COUNTER_BUFFER_BINDING = 0x92C1; ///
enum GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4; ///
enum GL_ATOMIC_COUNTER_BUFFER_INDEX = 0x9301; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = 0x90ED; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7; ///
enum GL_ATOMIC_COUNTER_BUFFER_SIZE = 0x92C3; ///
enum GL_ATOMIC_COUNTER_BUFFER_START = 0x92C2; ///
enum GL_ATTACHED_SHADERS = 0x8B85; ///
enum GL_ATTENUATION_EXT = 0x834D; ///
enum GL_ATTRIBUTE_ADDRESS_COMMAND_NV = 0x0009; ///
enum GL_ATTRIB_ARRAY_POINTER_NV = 0x8645; ///
enum GL_ATTRIB_ARRAY_SIZE_NV = 0x8623; ///
enum GL_ATTRIB_ARRAY_STRIDE_NV = 0x8624; ///
enum GL_ATTRIB_ARRAY_TYPE_NV = 0x8625; ///
enum GL_ATTRIB_STACK_DEPTH = 0x0BB0; ///
enum GL_AUTO_GENERATE_MIPMAP = 0x8295; ///
enum GL_AUTO_NORMAL = 0x0D80; ///
enum GL_AUX0 = 0x0409; ///
enum GL_AUX1 = 0x040A; ///
enum GL_AUX2 = 0x040B; ///
enum GL_AUX3 = 0x040C; ///
enum GL_AUX_BUFFERS = 0x0C00; ///
enum GL_AUX_DEPTH_STENCIL_APPLE = 0x8A14; ///
enum GL_AVERAGE_EXT = 0x8335; ///
enum GL_AVERAGE_HP = 0x8160; ///
enum GL_BACK = 0x0405; ///
enum GL_BACK_LEFT = 0x0402; ///
enum GL_BACK_NORMALS_HINT_PGI = 0x1A223; ///
enum GL_BACK_PRIMARY_COLOR_NV = 0x8C77; ///
enum GL_BACK_RIGHT = 0x0403; ///
enum GL_BACK_SECONDARY_COLOR_NV = 0x8C78; ///
enum GL_BEVEL_NV = 0x90A6; ///
enum GL_BGR = 0x80E0; ///
enum GL_BGRA = 0x80E1; ///
enum GL_BGRA8_EXT = 0x93A1; ///
enum GL_BGRA_EXT = 0x80E1; ///
enum GL_BGRA_IMG = 0x80E1; ///
enum GL_BGRA_INTEGER = 0x8D9B; ///
enum GL_BGRA_INTEGER_EXT = 0x8D9B; ///
enum GL_BGR_EXT = 0x80E0; ///
enum GL_BGR_INTEGER = 0x8D9A; ///
enum GL_BGR_INTEGER_EXT = 0x8D9A; ///
enum GL_BIAS_BIT_ATI = 0x00000008; ///
enum GL_BIAS_BY_NEGATIVE_ONE_HALF_NV = 0x8541; ///
enum GL_BINNING_CONTROL_HINT_QCOM = 0x8FB0; ///
enum GL_BINORMAL_ARRAY_EXT = 0x843A; ///
enum GL_BINORMAL_ARRAY_POINTER_EXT = 0x8443; ///
enum GL_BINORMAL_ARRAY_STRIDE_EXT = 0x8441; ///
enum GL_BINORMAL_ARRAY_TYPE_EXT = 0x8440; ///
enum GL_BITMAP = 0x1A00; ///
enum GL_BITMAP_TOKEN = 0x0704; ///
enum GL_BLEND = 0x0BE2; ///
enum GL_BLEND_ADVANCED_COHERENT_KHR = 0x9285; ///
enum GL_BLEND_ADVANCED_COHERENT_NV = 0x9285; ///
enum GL_BLEND_COLOR = 0x8005; ///
enum GL_BLEND_COLOR_COMMAND_NV = 0x000B; ///
enum GL_BLEND_COLOR_EXT = 0x8005; ///
enum GL_BLEND_DST = 0x0BE0; ///
enum GL_BLEND_DST_ALPHA = 0x80CA; ///
enum GL_BLEND_DST_ALPHA_EXT = 0x80CA; ///
enum GL_BLEND_DST_ALPHA_OES = 0x80CA; ///
enum GL_BLEND_DST_RGB = 0x80C8; ///
enum GL_BLEND_DST_RGB_EXT = 0x80C8; ///
enum GL_BLEND_DST_RGB_OES = 0x80C8; ///
enum GL_BLEND_EQUATION = 0x8009; ///
enum GL_BLEND_EQUATION_ALPHA = 0x883D; ///
enum GL_BLEND_EQUATION_ALPHA_EXT = 0x883D; ///
enum GL_BLEND_EQUATION_ALPHA_OES = 0x883D; ///
enum GL_BLEND_EQUATION_EXT = 0x8009; ///
enum GL_BLEND_EQUATION_OES = 0x8009; ///
enum GL_BLEND_EQUATION_RGB = 0x8009; ///
enum GL_BLEND_EQUATION_RGB_EXT = 0x8009; ///
enum GL_BLEND_EQUATION_RGB_OES = 0x8009; ///
enum GL_BLEND_OVERLAP_NV = 0x9281; ///
enum GL_BLEND_PREMULTIPLIED_SRC_NV = 0x9280; ///
enum GL_BLEND_SRC = 0x0BE1; ///
enum GL_BLEND_SRC_ALPHA = 0x80CB; ///
enum GL_BLEND_SRC_ALPHA_EXT = 0x80CB; ///
enum GL_BLEND_SRC_ALPHA_OES = 0x80CB; ///
enum GL_BLEND_SRC_RGB = 0x80C9; ///
enum GL_BLEND_SRC_RGB_EXT = 0x80C9; ///
enum GL_BLEND_SRC_RGB_OES = 0x80C9; ///
enum GL_BLOCK_INDEX = 0x92FD; ///
enum GL_BLUE = 0x1905; ///
enum GL_BLUE_BIAS = 0x0D1B; ///
enum GL_BLUE_BITS = 0x0D54; ///
enum GL_BLUE_BIT_ATI = 0x00000004; ///
enum GL_BLUE_INTEGER = 0x8D96; ///
enum GL_BLUE_INTEGER_EXT = 0x8D96; ///
enum GL_BLUE_MAX_CLAMP_INGR = 0x8566; ///
enum GL_BLUE_MIN_CLAMP_INGR = 0x8562; ///
enum GL_BLUE_NV = 0x1905; ///
enum GL_BLUE_SCALE = 0x0D1A; ///
enum GL_BOLD_BIT_NV = 0x01; ///
enum GL_BOOL = 0x8B56; ///
enum GL_BOOL_ARB = 0x8B56; ///
enum GL_BOOL_VEC2 = 0x8B57; ///
enum GL_BOOL_VEC2_ARB = 0x8B57; ///
enum GL_BOOL_VEC3 = 0x8B58; ///
enum GL_BOOL_VEC3_ARB = 0x8B58; ///
enum GL_BOOL_VEC4 = 0x8B59; ///
enum GL_BOOL_VEC4_ARB = 0x8B59; ///
enum GL_BOUNDING_BOX_NV = 0x908D; ///
enum GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV = 0x909C; ///
enum GL_BROWSER_DEFAULT_WEBGL = 0x9244; ///
enum GL_BUFFER = 0x82E0; ///
enum GL_BUFFER_ACCESS = 0x88BB; ///
enum GL_BUFFER_ACCESS_ARB = 0x88BB; ///
enum GL_BUFFER_ACCESS_FLAGS = 0x911F; ///
enum GL_BUFFER_ACCESS_OES = 0x88BB; ///
enum GL_BUFFER_BINDING = 0x9302; ///
enum GL_BUFFER_DATA_SIZE = 0x9303; ///
enum GL_BUFFER_FLUSHING_UNMAP_APPLE = 0x8A13; ///
enum GL_BUFFER_GPU_ADDRESS_NV = 0x8F1D; ///
enum GL_BUFFER_IMMUTABLE_STORAGE = 0x821F; ///
enum GL_BUFFER_IMMUTABLE_STORAGE_EXT = 0x821F; ///
enum GL_BUFFER_KHR = 0x82E0; ///
enum GL_BUFFER_MAPPED = 0x88BC; ///
enum GL_BUFFER_MAPPED_ARB = 0x88BC; ///
enum GL_BUFFER_MAPPED_OES = 0x88BC; ///
enum GL_BUFFER_MAP_LENGTH = 0x9120; ///
enum GL_BUFFER_MAP_OFFSET = 0x9121; ///
enum GL_BUFFER_MAP_POINTER = 0x88BD; ///
enum GL_BUFFER_MAP_POINTER_ARB = 0x88BD; ///
enum GL_BUFFER_MAP_POINTER_OES = 0x88BD; ///
enum GL_BUFFER_OBJECT_APPLE = 0x85B3; ///
enum GL_BUFFER_OBJECT_EXT = 0x9151; ///
enum GL_BUFFER_SERIALIZED_MODIFY_APPLE = 0x8A12; ///
enum GL_BUFFER_SIZE = 0x8764; ///
enum GL_BUFFER_SIZE_ARB = 0x8764; ///
enum GL_BUFFER_STORAGE_FLAGS = 0x8220; ///
enum GL_BUFFER_STORAGE_FLAGS_EXT = 0x8220; ///
enum GL_BUFFER_UPDATE_BARRIER_BIT = 0x00000200; ///
enum GL_BUFFER_UPDATE_BARRIER_BIT_EXT = 0x00000200; ///
enum GL_BUFFER_USAGE = 0x8765; ///
enum GL_BUFFER_USAGE_ARB = 0x8765; ///
enum GL_BUFFER_VARIABLE = 0x92E5; ///
enum GL_BUMP_ENVMAP_ATI = 0x877B; ///
enum GL_BUMP_NUM_TEX_UNITS_ATI = 0x8777; ///
enum GL_BUMP_ROT_MATRIX_ATI = 0x8775; ///
enum GL_BUMP_ROT_MATRIX_SIZE_ATI = 0x8776; ///
enum GL_BUMP_TARGET_ATI = 0x877C; ///
enum GL_BUMP_TEX_UNITS_ATI = 0x8778; ///
enum GL_BYTE = 0x1400; ///
enum GL_C3F_V3F = 0x2A24; ///
enum GL_C4F_N3F_V3F = 0x2A26; ///
enum GL_C4UB_V2F = 0x2A22; ///
enum GL_C4UB_V3F = 0x2A23; ///
enum GL_CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183; ///
enum GL_CAVEAT_SUPPORT = 0x82B8; ///
enum GL_CCW = 0x0901; ///
enum GL_CIRCULAR_CCW_ARC_TO_NV = 0xF8; ///
enum GL_CIRCULAR_CW_ARC_TO_NV = 0xFA; ///
enum GL_CIRCULAR_TANGENT_ARC_TO_NV = 0xFC; ///
enum GL_CLAMP = 0x2900; ///
enum GL_CLAMP_FRAGMENT_COLOR = 0x891B; ///
enum GL_CLAMP_FRAGMENT_COLOR_ARB = 0x891B; ///
enum GL_CLAMP_READ_COLOR = 0x891C; ///
enum GL_CLAMP_READ_COLOR_ARB = 0x891C; ///
enum GL_CLAMP_TO_BORDER = 0x812D; ///
enum GL_CLAMP_TO_BORDER_ARB = 0x812D; ///
enum GL_CLAMP_TO_BORDER_EXT = 0x812D; ///
enum GL_CLAMP_TO_BORDER_NV = 0x812D; ///
enum GL_CLAMP_TO_BORDER_OES = 0x812D; ///
enum GL_CLAMP_TO_BORDER_SGIS = 0x812D; ///
enum GL_CLAMP_TO_EDGE = 0x812F; ///
enum GL_CLAMP_TO_EDGE_SGIS = 0x812F; ///
enum GL_CLAMP_VERTEX_COLOR = 0x891A; ///
enum GL_CLAMP_VERTEX_COLOR_ARB = 0x891A; ///
enum GL_CLEAR = 0x1500; ///
enum GL_CLEAR_BUFFER = 0x82B4; ///
enum GL_CLEAR_TEXTURE = 0x9365; ///
enum GL_CLIENT_ACTIVE_TEXTURE = 0x84E1; ///
enum GL_CLIENT_ACTIVE_TEXTURE_ARB = 0x84E1; ///
enum GL_CLIENT_ALL_ATTRIB_BITS = 0xFFFFFFFF; ///
enum GL_CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1; ///
enum GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000; ///
enum GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT = 0x00004000; ///
enum GL_CLIENT_PIXEL_STORE_BIT = 0x00000001; ///
enum GL_CLIENT_STORAGE_BIT = 0x0200; ///
enum GL_CLIENT_STORAGE_BIT_EXT = 0x0200; ///
enum GL_CLIENT_VERTEX_ARRAY_BIT = 0x00000002; ///
enum GL_CLIPPING_INPUT_PRIMITIVES_ARB = 0x82F6; ///
enum GL_CLIPPING_OUTPUT_PRIMITIVES_ARB = 0x82F7; ///
enum GL_CLIP_DEPTH_MODE = 0x935D; ///
enum GL_CLIP_DISTANCE0 = 0x3000; ///
enum GL_CLIP_DISTANCE0_APPLE = 0x3000; ///
enum GL_CLIP_DISTANCE0_EXT = 0x3000; ///
enum GL_CLIP_DISTANCE1 = 0x3001; ///
enum GL_CLIP_DISTANCE1_APPLE = 0x3001; ///
enum GL_CLIP_DISTANCE1_EXT = 0x3001; ///
enum GL_CLIP_DISTANCE2 = 0x3002; ///
enum GL_CLIP_DISTANCE2_APPLE = 0x3002; ///
enum GL_CLIP_DISTANCE2_EXT = 0x3002; ///
enum GL_CLIP_DISTANCE3 = 0x3003; ///
enum GL_CLIP_DISTANCE3_APPLE = 0x3003; ///
enum GL_CLIP_DISTANCE3_EXT = 0x3003; ///
enum GL_CLIP_DISTANCE4 = 0x3004; ///
enum GL_CLIP_DISTANCE4_APPLE = 0x3004; ///
enum GL_CLIP_DISTANCE4_EXT = 0x3004; ///
enum GL_CLIP_DISTANCE5 = 0x3005; ///
enum GL_CLIP_DISTANCE5_APPLE = 0x3005; ///
enum GL_CLIP_DISTANCE5_EXT = 0x3005; ///
enum GL_CLIP_DISTANCE6 = 0x3006; ///
enum GL_CLIP_DISTANCE6_APPLE = 0x3006; ///
enum GL_CLIP_DISTANCE6_EXT = 0x3006; ///
enum GL_CLIP_DISTANCE7 = 0x3007; ///
enum GL_CLIP_DISTANCE7_APPLE = 0x3007; ///
enum GL_CLIP_DISTANCE7_EXT = 0x3007; ///
enum GL_CLIP_DISTANCE_NV = 0x8C7A; ///
enum GL_CLIP_FAR_HINT_PGI = 0x1A221; ///
enum GL_CLIP_NEAR_HINT_PGI = 0x1A220; ///
enum GL_CLIP_ORIGIN = 0x935C; ///
enum GL_CLIP_PLANE0 = 0x3000; ///
enum GL_CLIP_PLANE0_IMG = 0x3000; ///
enum GL_CLIP_PLANE1 = 0x3001; ///
enum GL_CLIP_PLANE1_IMG = 0x3001; ///
enum GL_CLIP_PLANE2 = 0x3002; ///
enum GL_CLIP_PLANE2_IMG = 0x3002; ///
enum GL_CLIP_PLANE3 = 0x3003; ///
enum GL_CLIP_PLANE3_IMG = 0x3003; ///
enum GL_CLIP_PLANE4 = 0x3004; ///
enum GL_CLIP_PLANE4_IMG = 0x3004; ///
enum GL_CLIP_PLANE5 = 0x3005; ///
enum GL_CLIP_PLANE5_IMG = 0x3005; ///
enum GL_CLIP_VOLUME_CLIPPING_HINT_EXT = 0x80F0; ///
enum GL_CLOSE_PATH_NV = 0x00; ///
enum GL_CMYKA_EXT = 0x800D; ///
enum GL_CMYK_EXT = 0x800C; ///
enum GL_CND0_ATI = 0x896B; ///
enum GL_CND_ATI = 0x896A; ///
enum GL_COEFF = 0x0A00; ///
enum GL_COLOR = 0x1800; ///
enum GL_COLOR3_BIT_PGI = 0x00010000; ///
enum GL_COLOR4_BIT_PGI = 0x00020000; ///
enum GL_COLORBURN = 0x929A; ///
enum GL_COLORBURN_KHR = 0x929A; ///
enum GL_COLORBURN_NV = 0x929A; ///
enum GL_COLORDODGE = 0x9299; ///
enum GL_COLORDODGE_KHR = 0x9299; ///
enum GL_COLORDODGE_NV = 0x9299; ///
enum GL_COLOR_ALPHA_PAIRING_ATI = 0x8975; ///
enum GL_COLOR_ARRAY = 0x8076; ///
enum GL_COLOR_ARRAY_ADDRESS_NV = 0x8F23; ///
enum GL_COLOR_ARRAY_BUFFER_BINDING = 0x8898; ///
enum GL_COLOR_ARRAY_BUFFER_BINDING_ARB = 0x8898; ///
enum GL_COLOR_ARRAY_COUNT_EXT = 0x8084; ///
enum GL_COLOR_ARRAY_EXT = 0x8076; ///
enum GL_COLOR_ARRAY_LENGTH_NV = 0x8F2D; ///
enum GL_COLOR_ARRAY_LIST_IBM = 0x103072; ///
enum GL_COLOR_ARRAY_LIST_STRIDE_IBM = 0x103082; ///
enum GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F7; ///
enum GL_COLOR_ARRAY_POINTER = 0x8090; ///
enum GL_COLOR_ARRAY_POINTER_EXT = 0x8090; ///
enum GL_COLOR_ARRAY_SIZE = 0x8081; ///
enum GL_COLOR_ARRAY_SIZE_EXT = 0x8081; ///
enum GL_COLOR_ARRAY_STRIDE = 0x8083; ///
enum GL_COLOR_ARRAY_STRIDE_EXT = 0x8083; ///
enum GL_COLOR_ARRAY_TYPE = 0x8082; ///
enum GL_COLOR_ARRAY_TYPE_EXT = 0x8082; ///
enum GL_COLOR_ATTACHMENT0 = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT0_EXT = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT0_NV = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT0_OES = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT1 = 0x8CE1; ///
enum GL_COLOR_ATTACHMENT10 = 0x8CEA; ///
enum GL_COLOR_ATTACHMENT10_EXT = 0x8CEA; ///
enum GL_COLOR_ATTACHMENT10_NV = 0x8CEA; ///
enum GL_COLOR_ATTACHMENT11 = 0x8CEB; ///
enum GL_COLOR_ATTACHMENT11_EXT = 0x8CEB; ///
enum GL_COLOR_ATTACHMENT11_NV = 0x8CEB; ///
enum GL_COLOR_ATTACHMENT12 = 0x8CEC; ///
enum GL_COLOR_ATTACHMENT12_EXT = 0x8CEC; ///
enum GL_COLOR_ATTACHMENT12_NV = 0x8CEC; ///
enum GL_COLOR_ATTACHMENT13 = 0x8CED; ///
enum GL_COLOR_ATTACHMENT13_EXT = 0x8CED; ///
enum GL_COLOR_ATTACHMENT13_NV = 0x8CED; ///
enum GL_COLOR_ATTACHMENT14 = 0x8CEE; ///
enum GL_COLOR_ATTACHMENT14_EXT = 0x8CEE; ///
enum GL_COLOR_ATTACHMENT14_NV = 0x8CEE; ///
enum GL_COLOR_ATTACHMENT15 = 0x8CEF; ///
enum GL_COLOR_ATTACHMENT15_EXT = 0x8CEF; ///
enum GL_COLOR_ATTACHMENT15_NV = 0x8CEF; ///
enum GL_COLOR_ATTACHMENT16 = 0x8CF0; ///
enum GL_COLOR_ATTACHMENT17 = 0x8CF1; ///
enum GL_COLOR_ATTACHMENT18 = 0x8CF2; ///
enum GL_COLOR_ATTACHMENT19 = 0x8CF3; ///
enum GL_COLOR_ATTACHMENT1_EXT = 0x8CE1; ///
enum GL_COLOR_ATTACHMENT1_NV = 0x8CE1; ///
enum GL_COLOR_ATTACHMENT2 = 0x8CE2; ///
enum GL_COLOR_ATTACHMENT20 = 0x8CF4; ///
enum GL_COLOR_ATTACHMENT21 = 0x8CF5; ///
enum GL_COLOR_ATTACHMENT22 = 0x8CF6; ///
enum GL_COLOR_ATTACHMENT23 = 0x8CF7; ///
enum GL_COLOR_ATTACHMENT24 = 0x8CF8; ///
enum GL_COLOR_ATTACHMENT25 = 0x8CF9; ///
enum GL_COLOR_ATTACHMENT26 = 0x8CFA; ///
enum GL_COLOR_ATTACHMENT27 = 0x8CFB; ///
enum GL_COLOR_ATTACHMENT28 = 0x8CFC; ///
enum GL_COLOR_ATTACHMENT29 = 0x8CFD; ///
enum GL_COLOR_ATTACHMENT2_EXT = 0x8CE2; ///
enum GL_COLOR_ATTACHMENT2_NV = 0x8CE2; ///
enum GL_COLOR_ATTACHMENT3 = 0x8CE3; ///
enum GL_COLOR_ATTACHMENT30 = 0x8CFE; ///
enum GL_COLOR_ATTACHMENT31 = 0x8CFF; ///
enum GL_COLOR_ATTACHMENT3_EXT = 0x8CE3; ///
enum GL_COLOR_ATTACHMENT3_NV = 0x8CE3; ///
enum GL_COLOR_ATTACHMENT4 = 0x8CE4; ///
enum GL_COLOR_ATTACHMENT4_EXT = 0x8CE4; ///
enum GL_COLOR_ATTACHMENT4_NV = 0x8CE4; ///
enum GL_COLOR_ATTACHMENT5 = 0x8CE5; ///
enum GL_COLOR_ATTACHMENT5_EXT = 0x8CE5; ///
enum GL_COLOR_ATTACHMENT5_NV = 0x8CE5; ///
enum GL_COLOR_ATTACHMENT6 = 0x8CE6; ///
enum GL_COLOR_ATTACHMENT6_EXT = 0x8CE6; ///
enum GL_COLOR_ATTACHMENT6_NV = 0x8CE6; ///
enum GL_COLOR_ATTACHMENT7 = 0x8CE7; ///
enum GL_COLOR_ATTACHMENT7_EXT = 0x8CE7; ///
enum GL_COLOR_ATTACHMENT7_NV = 0x8CE7; ///
enum GL_COLOR_ATTACHMENT8 = 0x8CE8; ///
enum GL_COLOR_ATTACHMENT8_EXT = 0x8CE8; ///
enum GL_COLOR_ATTACHMENT8_NV = 0x8CE8; ///
enum GL_COLOR_ATTACHMENT9 = 0x8CE9; ///
enum GL_COLOR_ATTACHMENT9_EXT = 0x8CE9; ///
enum GL_COLOR_ATTACHMENT9_NV = 0x8CE9; ///
enum GL_COLOR_ATTACHMENT_EXT = 0x90F0; ///
enum GL_COLOR_BUFFER_BIT = 0x00004000; ///
enum GL_COLOR_BUFFER_BIT0_QCOM = 0x00000001; ///
enum GL_COLOR_BUFFER_BIT1_QCOM = 0x00000002; ///
enum GL_COLOR_BUFFER_BIT2_QCOM = 0x00000004; ///
enum GL_COLOR_BUFFER_BIT3_QCOM = 0x00000008; ///
enum GL_COLOR_BUFFER_BIT4_QCOM = 0x00000010; ///
enum GL_COLOR_BUFFER_BIT5_QCOM = 0x00000020; ///
enum GL_COLOR_BUFFER_BIT6_QCOM = 0x00000040; ///
enum GL_COLOR_BUFFER_BIT7_QCOM = 0x00000080; ///
enum GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI = 0x8835; ///
enum GL_COLOR_CLEAR_VALUE = 0x0C22; ///
enum GL_COLOR_COMPONENTS = 0x8283; ///
enum GL_COLOR_ENCODING = 0x8296; ///
enum GL_COLOR_EXT = 0x1800; ///
enum GL_COLOR_FLOAT_APPLE = 0x8A0F; ///
enum GL_COLOR_INDEX = 0x1900; ///
enum GL_COLOR_INDEX12_EXT = 0x80E6; ///
enum GL_COLOR_INDEX16_EXT = 0x80E7; ///
enum GL_COLOR_INDEX1_EXT = 0x80E2; ///
enum GL_COLOR_INDEX2_EXT = 0x80E3; ///
enum GL_COLOR_INDEX4_EXT = 0x80E4; ///
enum GL_COLOR_INDEX8_EXT = 0x80E5; ///
enum GL_COLOR_INDEXES = 0x1603; ///
enum GL_COLOR_LOGIC_OP = 0x0BF2; ///
enum GL_COLOR_MATERIAL = 0x0B57; ///
enum GL_COLOR_MATERIAL_FACE = 0x0B55; ///
enum GL_COLOR_MATERIAL_PARAMETER = 0x0B56; ///
enum GL_COLOR_MATRIX = 0x80B1; ///
enum GL_COLOR_MATRIX_SGI = 0x80B1; ///
enum GL_COLOR_MATRIX_STACK_DEPTH = 0x80B2; ///
enum GL_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B2; ///
enum GL_COLOR_RENDERABLE = 0x8286; ///
enum GL_COLOR_SAMPLES_NV = 0x8E20; ///
enum GL_COLOR_SUM = 0x8458; ///
enum GL_COLOR_SUM_ARB = 0x8458; ///
enum GL_COLOR_SUM_CLAMP_NV = 0x854F; ///
enum GL_COLOR_SUM_EXT = 0x8458; ///
enum GL_COLOR_TABLE = 0x80D0; ///
enum GL_COLOR_TABLE_ALPHA_SIZE = 0x80DD; ///
enum GL_COLOR_TABLE_ALPHA_SIZE_SGI = 0x80DD; ///
enum GL_COLOR_TABLE_BIAS = 0x80D7; ///
enum GL_COLOR_TABLE_BIAS_SGI = 0x80D7; ///
enum GL_COLOR_TABLE_BLUE_SIZE = 0x80DC; ///
enum GL_COLOR_TABLE_BLUE_SIZE_SGI = 0x80DC; ///
enum GL_COLOR_TABLE_FORMAT = 0x80D8; ///
enum GL_COLOR_TABLE_FORMAT_SGI = 0x80D8; ///
enum GL_COLOR_TABLE_GREEN_SIZE = 0x80DB; ///
enum GL_COLOR_TABLE_GREEN_SIZE_SGI = 0x80DB; ///
enum GL_COLOR_TABLE_INTENSITY_SIZE = 0x80DF; ///
enum GL_COLOR_TABLE_INTENSITY_SIZE_SGI = 0x80DF; ///
enum GL_COLOR_TABLE_LUMINANCE_SIZE = 0x80DE; ///
enum GL_COLOR_TABLE_LUMINANCE_SIZE_SGI = 0x80DE; ///
enum GL_COLOR_TABLE_RED_SIZE = 0x80DA; ///
enum GL_COLOR_TABLE_RED_SIZE_SGI = 0x80DA; ///
enum GL_COLOR_TABLE_SCALE = 0x80D6; ///
enum GL_COLOR_TABLE_SCALE_SGI = 0x80D6; ///
enum GL_COLOR_TABLE_SGI = 0x80D0; ///
enum GL_COLOR_TABLE_WIDTH = 0x80D9; ///
enum GL_COLOR_TABLE_WIDTH_SGI = 0x80D9; ///
enum GL_COLOR_WRITEMASK = 0x0C23; ///
enum GL_COMBINE = 0x8570; ///
enum GL_COMBINE4_NV = 0x8503; ///
enum GL_COMBINER0_NV = 0x8550; ///
enum GL_COMBINER1_NV = 0x8551; ///
enum GL_COMBINER2_NV = 0x8552; ///
enum GL_COMBINER3_NV = 0x8553; ///
enum GL_COMBINER4_NV = 0x8554; ///
enum GL_COMBINER5_NV = 0x8555; ///
enum GL_COMBINER6_NV = 0x8556; ///
enum GL_COMBINER7_NV = 0x8557; ///
enum GL_COMBINER_AB_DOT_PRODUCT_NV = 0x8545; ///
enum GL_COMBINER_AB_OUTPUT_NV = 0x854A; ///
enum GL_COMBINER_BIAS_NV = 0x8549; ///
enum GL_COMBINER_CD_DOT_PRODUCT_NV = 0x8546; ///
enum GL_COMBINER_CD_OUTPUT_NV = 0x854B; ///
enum GL_COMBINER_COMPONENT_USAGE_NV = 0x8544; ///
enum GL_COMBINER_INPUT_NV = 0x8542; ///
enum GL_COMBINER_MAPPING_NV = 0x8543; ///
enum GL_COMBINER_MUX_SUM_NV = 0x8547; ///
enum GL_COMBINER_SCALE_NV = 0x8548; ///
enum GL_COMBINER_SUM_OUTPUT_NV = 0x854C; ///
enum GL_COMBINE_ALPHA = 0x8572; ///
enum GL_COMBINE_ALPHA_ARB = 0x8572; ///
enum GL_COMBINE_ALPHA_EXT = 0x8572; ///
enum GL_COMBINE_ARB = 0x8570; ///
enum GL_COMBINE_EXT = 0x8570; ///
enum GL_COMBINE_RGB = 0x8571; ///
enum GL_COMBINE_RGB_ARB = 0x8571; ///
enum GL_COMBINE_RGB_EXT = 0x8571; ///
enum GL_COMMAND_BARRIER_BIT = 0x00000040; ///
enum GL_COMMAND_BARRIER_BIT_EXT = 0x00000040; ///
enum GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT = 0x884E; ///
enum GL_COMPARE_REF_TO_TEXTURE = 0x884E; ///
enum GL_COMPARE_REF_TO_TEXTURE_EXT = 0x884E; ///
enum GL_COMPARE_R_TO_TEXTURE = 0x884E; ///
enum GL_COMPARE_R_TO_TEXTURE_ARB = 0x884E; ///
enum GL_COMPATIBLE_SUBROUTINES = 0x8E4B; ///
enum GL_COMPILE = 0x1300; ///
enum GL_COMPILE_AND_EXECUTE = 0x1301; ///
enum GL_COMPILE_STATUS = 0x8B81; ///
enum GL_COMPLETION_STATUS_ARB = 0x91B1; ///
enum GL_COMPRESSED_ALPHA = 0x84E9; ///
enum GL_COMPRESSED_ALPHA_ARB = 0x84E9; ///
enum GL_COMPRESSED_INTENSITY = 0x84EC; ///
enum GL_COMPRESSED_INTENSITY_ARB = 0x84EC; ///
enum GL_COMPRESSED_LUMINANCE = 0x84EA; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA = 0x84EB; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI = 0x8837; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA_ARB = 0x84EB; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT = 0x8C72; ///
enum GL_COMPRESSED_LUMINANCE_ARB = 0x84EA; ///
enum GL_COMPRESSED_LUMINANCE_LATC1_EXT = 0x8C70; ///
enum GL_COMPRESSED_R11_EAC = 0x9270; ///
enum GL_COMPRESSED_R11_EAC_OES = 0x9270; ///
enum GL_COMPRESSED_RED = 0x8225; ///
enum GL_COMPRESSED_RED_GREEN_RGTC2_EXT = 0x8DBD; ///
enum GL_COMPRESSED_RED_RGTC1 = 0x8DBB; ///
enum GL_COMPRESSED_RED_RGTC1_EXT = 0x8DBB; ///
enum GL_COMPRESSED_RG = 0x8226; ///
enum GL_COMPRESSED_RG11_EAC = 0x9272; ///
enum GL_COMPRESSED_RG11_EAC_OES = 0x9272; ///
enum GL_COMPRESSED_RGB = 0x84ED; ///
enum GL_COMPRESSED_RGB8_ETC2 = 0x9274; ///
enum GL_COMPRESSED_RGB8_ETC2_OES = 0x9274; ///
enum GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276; ///
enum GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = 0x9276; ///
enum GL_COMPRESSED_RGBA = 0x84EE; ///
enum GL_COMPRESSED_RGBA8_ETC2_EAC = 0x9278; ///
enum GL_COMPRESSED_RGBA8_ETC2_EAC_OES = 0x9278; ///
enum GL_COMPRESSED_RGBA_ARB = 0x84EE; ///
enum GL_COMPRESSED_RGBA_ASTC_10x10 = 0x93BB; ///
enum GL_COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB; ///
enum GL_COMPRESSED_RGBA_ASTC_10x5 = 0x93B8; ///
enum GL_COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8; ///
enum GL_COMPRESSED_RGBA_ASTC_10x6 = 0x93B9; ///
enum GL_COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9; ///
enum GL_COMPRESSED_RGBA_ASTC_10x8 = 0x93BA; ///
enum GL_COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA; ///
enum GL_COMPRESSED_RGBA_ASTC_12x10 = 0x93BC; ///
enum GL_COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC; ///
enum GL_COMPRESSED_RGBA_ASTC_12x12 = 0x93BD; ///
enum GL_COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD; ///
enum GL_COMPRESSED_RGBA_ASTC_3x3x3_OES = 0x93C0; ///
enum GL_COMPRESSED_RGBA_ASTC_4x3x3_OES = 0x93C1; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4 = 0x93B0; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4x3_OES = 0x93C2; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4x4_OES = 0x93C3; ///
enum GL_COMPRESSED_RGBA_ASTC_5x4 = 0x93B1; ///
enum GL_COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1; ///
enum GL_COMPRESSED_RGBA_ASTC_5x4x4_OES = 0x93C4; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5 = 0x93B2; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5x4_OES = 0x93C5; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5x5_OES = 0x93C6; ///
enum GL_COMPRESSED_RGBA_ASTC_6x5 = 0x93B3; ///
enum GL_COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3; ///
enum GL_COMPRESSED_RGBA_ASTC_6x5x5_OES = 0x93C7; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6 = 0x93B4; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6x5_OES = 0x93C8; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6x6_OES = 0x93C9; ///
enum GL_COMPRESSED_RGBA_ASTC_8x5 = 0x93B5; ///
enum GL_COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5; ///
enum GL_COMPRESSED_RGBA_ASTC_8x6 = 0x93B6; ///
enum GL_COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6; ///
enum GL_COMPRESSED_RGBA_ASTC_8x8 = 0x93B7; ///
enum GL_COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7; ///
enum GL_COMPRESSED_RGBA_BPTC_UNORM = 0x8E8C; ///
enum GL_COMPRESSED_RGBA_BPTC_UNORM_ARB = 0x8E8C; ///
enum GL_COMPRESSED_RGBA_FXT1_3DFX = 0x86B1; ///
enum GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03; ///
enum GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG = 0x9137; ///
enum GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02; ///
enum GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG = 0x9138; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE = 0x83F2; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE = 0x83F3; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3; ///
enum GL_COMPRESSED_RGB_ARB = 0x84ED; ///
enum GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 0x8E8E; ///
enum GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB = 0x8E8E; ///
enum GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 0x8E8F; ///
enum GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB = 0x8E8F; ///
enum GL_COMPRESSED_RGB_FXT1_3DFX = 0x86B0; ///
enum GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01; ///
enum GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00; ///
enum GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0; ///
enum GL_COMPRESSED_RG_RGTC2 = 0x8DBD; ///
enum GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT = 0x8C73; ///
enum GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT = 0x8C71; ///
enum GL_COMPRESSED_SIGNED_R11_EAC = 0x9271; ///
enum GL_COMPRESSED_SIGNED_R11_EAC_OES = 0x9271; ///
enum GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 0x8DBE; ///
enum GL_COMPRESSED_SIGNED_RED_RGTC1 = 0x8DBC; ///
enum GL_COMPRESSED_SIGNED_RED_RGTC1_EXT = 0x8DBC; ///
enum GL_COMPRESSED_SIGNED_RG11_EAC = 0x9273; ///
enum GL_COMPRESSED_SIGNED_RG11_EAC_OES = 0x9273; ///
enum GL_COMPRESSED_SIGNED_RG_RGTC2 = 0x8DBE; ///
enum GL_COMPRESSED_SLUMINANCE = 0x8C4A; ///
enum GL_COMPRESSED_SLUMINANCE_ALPHA = 0x8C4B; ///
enum GL_COMPRESSED_SLUMINANCE_ALPHA_EXT = 0x8C4B; ///
enum GL_COMPRESSED_SLUMINANCE_EXT = 0x8C4A; ///
enum GL_COMPRESSED_SRGB = 0x8C48; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10 = 0x93DB; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5 = 0x93D8; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6 = 0x93D9; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8 = 0x93DA; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10 = 0x93DC; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12 = 0x93DD; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES = 0x93E0; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES = 0x93E1; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4 = 0x93D0; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES = 0x93E2; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES = 0x93E3; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4 = 0x93D1; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES = 0x93E4; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5 = 0x93D2; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES = 0x93E5; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES = 0x93E6; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5 = 0x93D3; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES = 0x93E7; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6 = 0x93D4; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES = 0x93E8; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES = 0x93E9; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5 = 0x93D5; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6 = 0x93D6; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8 = 0x93D7; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC_OES = 0x9279; ///
enum GL_COMPRESSED_SRGB8_ETC2 = 0x9275; ///
enum GL_COMPRESSED_SRGB8_ETC2_OES = 0x9275; ///
enum GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277; ///
enum GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = 0x9277; ///
enum GL_COMPRESSED_SRGB_ALPHA = 0x8C49; ///
enum GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 0x8E8D; ///
enum GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB = 0x8E8D; ///
enum GL_COMPRESSED_SRGB_ALPHA_EXT = 0x8C49; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT = 0x8A56; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG = 0x93F0; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT = 0x8A57; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG = 0x93F1; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 0x8C4D; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV = 0x8C4D; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 0x8C4E; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV = 0x8C4E; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 0x8C4F; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV = 0x8C4F; ///
enum GL_COMPRESSED_SRGB_EXT = 0x8C48; ///
enum GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT = 0x8A54; ///
enum GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT = 0x8A55; ///
enum GL_COMPRESSED_SRGB_S3TC_DXT1_EXT = 0x8C4C; ///
enum GL_COMPRESSED_SRGB_S3TC_DXT1_NV = 0x8C4C; ///
enum GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3; ///
enum GL_COMPRESSED_TEXTURE_FORMATS_ARB = 0x86A3; ///
enum GL_COMPUTE_PROGRAM_NV = 0x90FB; ///
enum GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV = 0x90FC; ///
enum GL_COMPUTE_SHADER = 0x91B9; ///
enum GL_COMPUTE_SHADER_BIT = 0x00000020; ///
enum GL_COMPUTE_SHADER_INVOCATIONS_ARB = 0x82F5; ///
enum GL_COMPUTE_SUBROUTINE = 0x92ED; ///
enum GL_COMPUTE_SUBROUTINE_UNIFORM = 0x92F3; ///
enum GL_COMPUTE_TEXTURE = 0x82A0; ///
enum GL_COMPUTE_WORK_GROUP_SIZE = 0x8267; ///
enum GL_COMP_BIT_ATI = 0x00000002; ///
enum GL_CONDITION_SATISFIED = 0x911C; ///
enum GL_CONDITION_SATISFIED_APPLE = 0x911C; ///
enum GL_CONFORMANT_NV = 0x9374; ///
enum GL_CONIC_CURVE_TO_NV = 0x1A; ///
enum GL_CONJOINT_NV = 0x9284; ///
enum GL_CONSERVATIVE_RASTERIZATION_INTEL = 0x83FE; ///
enum GL_CONSERVATIVE_RASTERIZATION_NV = 0x9346; ///
enum GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV = 0x937B; ///
enum GL_CONSERVATIVE_RASTER_DILATE_NV = 0x9379; ///
enum GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV = 0x937A; ///
enum GL_CONSERVATIVE_RASTER_MODE_NV = 0x954D; ///
enum GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV = 0x954E; ///
enum GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV = 0x954F; ///
enum GL_CONSERVE_MEMORY_HINT_PGI = 0x1A1FD; ///
enum GL_CONSTANT = 0x8576; ///
enum GL_CONSTANT_ALPHA = 0x8003; ///
enum GL_CONSTANT_ALPHA_EXT = 0x8003; ///
enum GL_CONSTANT_ARB = 0x8576; ///
enum GL_CONSTANT_ATTENUATION = 0x1207; ///
enum GL_CONSTANT_BORDER = 0x8151; ///
enum GL_CONSTANT_BORDER_HP = 0x8151; ///
enum GL_CONSTANT_COLOR = 0x8001; ///
enum GL_CONSTANT_COLOR0_NV = 0x852A; ///
enum GL_CONSTANT_COLOR1_NV = 0x852B; ///
enum GL_CONSTANT_COLOR_EXT = 0x8001; ///
enum GL_CONSTANT_EXT = 0x8576; ///
enum GL_CONSTANT_NV = 0x8576; ///
enum GL_CONST_EYE_NV = 0x86E5; ///
enum GL_CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002; ///
enum GL_CONTEXT_CORE_PROFILE_BIT = 0x00000001; ///
enum GL_CONTEXT_FLAGS = 0x821E; ///
enum GL_CONTEXT_FLAG_DEBUG_BIT = 0x00000002; ///
enum GL_CONTEXT_FLAG_DEBUG_BIT_KHR = 0x00000002; ///
enum GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001; ///
enum GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR = 0x00000008; ///
enum GL_CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT = 0x00000010; ///
enum GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT = 0x00000004; ///
enum GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004; ///
enum GL_CONTEXT_LOST = 0x0507; ///
enum GL_CONTEXT_LOST_KHR = 0x0507; ///
enum GL_CONTEXT_LOST_WEBGL = 0x9242; ///
enum GL_CONTEXT_PROFILE_MASK = 0x9126; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR = 0x82FB; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x82FC; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR = 0x82FC; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR_KHR = 0x82FB; ///
enum GL_CONTEXT_ROBUST_ACCESS = 0x90F3; ///
enum GL_CONTEXT_ROBUST_ACCESS_EXT = 0x90F3; ///
enum GL_CONTEXT_ROBUST_ACCESS_KHR = 0x90F3; ///
enum GL_CONTINUOUS_AMD = 0x9007; ///
enum GL_CONTRAST_NV = 0x92A1; ///
enum GL_CONVEX_HULL_NV = 0x908B; ///
enum GL_CONVOLUTION_1D = 0x8010; ///
enum GL_CONVOLUTION_1D_EXT = 0x8010; ///
enum GL_CONVOLUTION_2D = 0x8011; ///
enum GL_CONVOLUTION_2D_EXT = 0x8011; ///
enum GL_CONVOLUTION_BORDER_COLOR = 0x8154; ///
enum GL_CONVOLUTION_BORDER_COLOR_HP = 0x8154; ///
enum GL_CONVOLUTION_BORDER_MODE = 0x8013; ///
enum GL_CONVOLUTION_BORDER_MODE_EXT = 0x8013; ///
enum GL_CONVOLUTION_FILTER_BIAS = 0x8015; ///
enum GL_CONVOLUTION_FILTER_BIAS_EXT = 0x8015; ///
enum GL_CONVOLUTION_FILTER_SCALE = 0x8014; ///
enum GL_CONVOLUTION_FILTER_SCALE_EXT = 0x8014; ///
enum GL_CONVOLUTION_FORMAT = 0x8017; ///
enum GL_CONVOLUTION_FORMAT_EXT = 0x8017; ///
enum GL_CONVOLUTION_HEIGHT = 0x8019; ///
enum GL_CONVOLUTION_HEIGHT_EXT = 0x8019; ///
enum GL_CONVOLUTION_HINT_SGIX = 0x8316; ///
enum GL_CONVOLUTION_WIDTH = 0x8018; ///
enum GL_CONVOLUTION_WIDTH_EXT = 0x8018; ///
enum GL_CON_0_ATI = 0x8941; ///
enum GL_CON_10_ATI = 0x894B; ///
enum GL_CON_11_ATI = 0x894C; ///
enum GL_CON_12_ATI = 0x894D; ///
enum GL_CON_13_ATI = 0x894E; ///
enum GL_CON_14_ATI = 0x894F; ///
enum GL_CON_15_ATI = 0x8950; ///
enum GL_CON_16_ATI = 0x8951; ///
enum GL_CON_17_ATI = 0x8952; ///
enum GL_CON_18_ATI = 0x8953; ///
enum GL_CON_19_ATI = 0x8954; ///
enum GL_CON_1_ATI = 0x8942; ///
enum GL_CON_20_ATI = 0x8955; ///
enum GL_CON_21_ATI = 0x8956; ///
enum GL_CON_22_ATI = 0x8957; ///
enum GL_CON_23_ATI = 0x8958; ///
enum GL_CON_24_ATI = 0x8959; ///
enum GL_CON_25_ATI = 0x895A; ///
enum GL_CON_26_ATI = 0x895B; ///
enum GL_CON_27_ATI = 0x895C; ///
enum GL_CON_28_ATI = 0x895D; ///
enum GL_CON_29_ATI = 0x895E; ///
enum GL_CON_2_ATI = 0x8943; ///
enum GL_CON_30_ATI = 0x895F; ///
enum GL_CON_31_ATI = 0x8960; ///
enum GL_CON_3_ATI = 0x8944; ///
enum GL_CON_4_ATI = 0x8945; ///
enum GL_CON_5_ATI = 0x8946; ///
enum GL_CON_6_ATI = 0x8947; ///
enum GL_CON_7_ATI = 0x8948; ///
enum GL_CON_8_ATI = 0x8949; ///
enum GL_CON_9_ATI = 0x894A; ///
enum GL_COORD_REPLACE = 0x8862; ///
enum GL_COORD_REPLACE_ARB = 0x8862; ///
enum GL_COORD_REPLACE_NV = 0x8862; ///
enum GL_COORD_REPLACE_OES = 0x8862; ///
enum GL_COPY = 0x1503; ///
enum GL_COPY_INVERTED = 0x150C; ///
enum GL_COPY_PIXEL_TOKEN = 0x0706; ///
enum GL_COPY_READ_BUFFER = 0x8F36; ///
enum GL_COPY_READ_BUFFER_BINDING = 0x8F36; ///
enum GL_COPY_READ_BUFFER_NV = 0x8F36; ///
enum GL_COPY_WRITE_BUFFER = 0x8F37; ///
enum GL_COPY_WRITE_BUFFER_BINDING = 0x8F37; ///
enum GL_COPY_WRITE_BUFFER_NV = 0x8F37; ///
enum GL_COUNTER_RANGE_AMD = 0x8BC1; ///
enum GL_COUNTER_TYPE_AMD = 0x8BC0; ///
enum GL_COUNT_DOWN_NV = 0x9089; ///
enum GL_COUNT_UP_NV = 0x9088; ///
enum GL_COVERAGE_ALL_FRAGMENTS_NV = 0x8ED5; ///
enum GL_COVERAGE_ATTACHMENT_NV = 0x8ED2; ///
enum GL_COVERAGE_AUTOMATIC_NV = 0x8ED7; ///
enum GL_COVERAGE_BUFFERS_NV = 0x8ED3; ///
enum GL_COVERAGE_BUFFER_BIT_NV = 0x00008000; ///
enum GL_COVERAGE_COMPONENT4_NV = 0x8ED1; ///
enum GL_COVERAGE_COMPONENT_NV = 0x8ED0; ///
enum GL_COVERAGE_EDGE_FRAGMENTS_NV = 0x8ED6; ///
enum GL_COVERAGE_MODULATION_NV = 0x9332; ///
enum GL_COVERAGE_MODULATION_TABLE_NV = 0x9331; ///
enum GL_COVERAGE_MODULATION_TABLE_SIZE_NV = 0x9333; ///
enum GL_COVERAGE_SAMPLES_NV = 0x8ED4; ///
enum GL_CPU_OPTIMIZED_QCOM = 0x8FB1; ///
enum GL_CUBIC_CURVE_TO_NV = 0x0C; ///
enum GL_CUBIC_EXT = 0x8334; ///
enum GL_CUBIC_HP = 0x815F; ///
enum GL_CUBIC_IMG = 0x9139; ///
enum GL_CUBIC_MIPMAP_LINEAR_IMG = 0x913B; ///
enum GL_CUBIC_MIPMAP_NEAREST_IMG = 0x913A; ///
enum GL_CULL_FACE = 0x0B44; ///
enum GL_CULL_FACE_MODE = 0x0B45; ///
enum GL_CULL_FRAGMENT_NV = 0x86E7; ///
enum GL_CULL_MODES_NV = 0x86E0; ///
enum GL_CULL_VERTEX_EXT = 0x81AA; ///
enum GL_CULL_VERTEX_EYE_POSITION_EXT = 0x81AB; ///
enum GL_CULL_VERTEX_IBM = 0x103050; ///
enum GL_CULL_VERTEX_OBJECT_POSITION_EXT = 0x81AC; ///
enum GL_CURRENT_ATTRIB_NV = 0x8626; ///
enum GL_CURRENT_BINORMAL_EXT = 0x843C; ///
enum GL_CURRENT_BIT = 0x00000001; ///
enum GL_CURRENT_COLOR = 0x0B00; ///
enum GL_CURRENT_FOG_COORD = 0x8453; ///
enum GL_CURRENT_FOG_COORDINATE = 0x8453; ///
enum GL_CURRENT_FOG_COORDINATE_EXT = 0x8453; ///
enum GL_CURRENT_INDEX = 0x0B01; ///
enum GL_CURRENT_MATRIX_ARB = 0x8641; ///
enum GL_CURRENT_MATRIX_INDEX_ARB = 0x8845; ///
enum GL_CURRENT_MATRIX_NV = 0x8641; ///
enum GL_CURRENT_MATRIX_STACK_DEPTH_ARB = 0x8640; ///
enum GL_CURRENT_MATRIX_STACK_DEPTH_NV = 0x8640; ///
enum GL_CURRENT_NORMAL = 0x0B02; ///
enum GL_CURRENT_OCCLUSION_QUERY_ID_NV = 0x8865; ///
enum GL_CURRENT_PALETTE_MATRIX_ARB = 0x8843; ///
enum GL_CURRENT_PALETTE_MATRIX_OES = 0x8843; ///
enum GL_CURRENT_PROGRAM = 0x8B8D; ///
enum GL_CURRENT_QUERY = 0x8865; ///
enum GL_CURRENT_QUERY_ARB = 0x8865; ///
enum GL_CURRENT_QUERY_EXT = 0x8865; ///
enum GL_CURRENT_RASTER_COLOR = 0x0B04; ///
enum GL_CURRENT_RASTER_DISTANCE = 0x0B09; ///
enum GL_CURRENT_RASTER_INDEX = 0x0B05; ///
enum GL_CURRENT_RASTER_NORMAL_SGIX = 0x8406; ///
enum GL_CURRENT_RASTER_POSITION = 0x0B07; ///
enum GL_CURRENT_RASTER_POSITION_VALID = 0x0B08; ///
enum GL_CURRENT_RASTER_SECONDARY_COLOR = 0x845F; ///
enum GL_CURRENT_RASTER_TEXTURE_COORDS = 0x0B06; ///
enum GL_CURRENT_SECONDARY_COLOR = 0x8459; ///
enum GL_CURRENT_SECONDARY_COLOR_EXT = 0x8459; ///
enum GL_CURRENT_TANGENT_EXT = 0x843B; ///
enum GL_CURRENT_TEXTURE_COORDS = 0x0B03; ///
enum GL_CURRENT_TIME_NV = 0x8E28; ///
enum GL_CURRENT_VERTEX_ATTRIB = 0x8626; ///
enum GL_CURRENT_VERTEX_ATTRIB_ARB = 0x8626; ///
enum GL_CURRENT_VERTEX_EXT = 0x87E2; ///
enum GL_CURRENT_VERTEX_WEIGHT_EXT = 0x850B; ///
enum GL_CURRENT_WEIGHT_ARB = 0x86A8; ///
enum GL_CW = 0x0900; ///
enum GL_DARKEN = 0x9297; ///
enum GL_DARKEN_KHR = 0x9297; ///
enum GL_DARKEN_NV = 0x9297; ///
enum GL_DATA_BUFFER_AMD = 0x9151; ///
enum GL_DEBUG_ASSERT_MESA = 0x875B; ///
enum GL_DEBUG_CALLBACK_FUNCTION = 0x8244; ///
enum GL_DEBUG_CALLBACK_FUNCTION_ARB = 0x8244; ///
enum GL_DEBUG_CALLBACK_FUNCTION_KHR = 0x8244; ///
enum GL_DEBUG_CALLBACK_USER_PARAM = 0x8245; ///
enum GL_DEBUG_CALLBACK_USER_PARAM_ARB = 0x8245; ///
enum GL_DEBUG_CALLBACK_USER_PARAM_KHR = 0x8245; ///
enum GL_DEBUG_CATEGORY_API_ERROR_AMD = 0x9149; ///
enum GL_DEBUG_CATEGORY_APPLICATION_AMD = 0x914F; ///
enum GL_DEBUG_CATEGORY_DEPRECATION_AMD = 0x914B; ///
enum GL_DEBUG_CATEGORY_OTHER_AMD = 0x9150; ///
enum GL_DEBUG_CATEGORY_PERFORMANCE_AMD = 0x914D; ///
enum GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD = 0x914E; ///
enum GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD = 0x914C; ///
enum GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD = 0x914A; ///
enum GL_DEBUG_GROUP_STACK_DEPTH = 0x826D; ///
enum GL_DEBUG_GROUP_STACK_DEPTH_KHR = 0x826D; ///
enum GL_DEBUG_LOGGED_MESSAGES = 0x9145; ///
enum GL_DEBUG_LOGGED_MESSAGES_AMD = 0x9145; ///
enum GL_DEBUG_LOGGED_MESSAGES_ARB = 0x9145; ///
enum GL_DEBUG_LOGGED_MESSAGES_KHR = 0x9145; ///
enum GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = 0x8243; ///
enum GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = 0x8243; ///
enum GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR = 0x8243; ///
enum GL_DEBUG_OBJECT_MESA = 0x8759; ///
enum GL_DEBUG_OUTPUT = 0x92E0; ///
enum GL_DEBUG_OUTPUT_KHR = 0x92E0; ///
enum GL_DEBUG_OUTPUT_SYNCHRONOUS = 0x8242; ///
enum GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB = 0x8242; ///
enum GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR = 0x8242; ///
enum GL_DEBUG_PRINT_MESA = 0x875A; ///
enum GL_DEBUG_SEVERITY_HIGH = 0x9146; ///
enum GL_DEBUG_SEVERITY_HIGH_AMD = 0x9146; ///
enum GL_DEBUG_SEVERITY_HIGH_ARB = 0x9146; ///
enum GL_DEBUG_SEVERITY_HIGH_KHR = 0x9146; ///
enum GL_DEBUG_SEVERITY_LOW = 0x9148; ///
enum GL_DEBUG_SEVERITY_LOW_AMD = 0x9148; ///
enum GL_DEBUG_SEVERITY_LOW_ARB = 0x9148; ///
enum GL_DEBUG_SEVERITY_LOW_KHR = 0x9148; ///
enum GL_DEBUG_SEVERITY_MEDIUM = 0x9147; ///
enum GL_DEBUG_SEVERITY_MEDIUM_AMD = 0x9147; ///
enum GL_DEBUG_SEVERITY_MEDIUM_ARB = 0x9147; ///
enum GL_DEBUG_SEVERITY_MEDIUM_KHR = 0x9147; ///
enum GL_DEBUG_SEVERITY_NOTIFICATION = 0x826B; ///
enum GL_DEBUG_SEVERITY_NOTIFICATION_KHR = 0x826B; ///
enum GL_DEBUG_SOURCE_API = 0x8246; ///
enum GL_DEBUG_SOURCE_API_ARB = 0x8246; ///
enum GL_DEBUG_SOURCE_API_KHR = 0x8246; ///
enum GL_DEBUG_SOURCE_APPLICATION = 0x824A; ///
enum GL_DEBUG_SOURCE_APPLICATION_ARB = 0x824A; ///
enum GL_DEBUG_SOURCE_APPLICATION_KHR = 0x824A; ///
enum GL_DEBUG_SOURCE_OTHER = 0x824B; ///
enum GL_DEBUG_SOURCE_OTHER_ARB = 0x824B; ///
enum GL_DEBUG_SOURCE_OTHER_KHR = 0x824B; ///
enum GL_DEBUG_SOURCE_SHADER_COMPILER = 0x8248; ///
enum GL_DEBUG_SOURCE_SHADER_COMPILER_ARB = 0x8248; ///
enum GL_DEBUG_SOURCE_SHADER_COMPILER_KHR = 0x8248; ///
enum GL_DEBUG_SOURCE_THIRD_PARTY = 0x8249; ///
enum GL_DEBUG_SOURCE_THIRD_PARTY_ARB = 0x8249; ///
enum GL_DEBUG_SOURCE_THIRD_PARTY_KHR = 0x8249; ///
enum GL_DEBUG_SOURCE_WINDOW_SYSTEM = 0x8247; ///
enum GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB = 0x8247; ///
enum GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR = 0x8247; ///
enum GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = 0x824D; ///
enum GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = 0x824D; ///
enum GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR = 0x824D; ///
enum GL_DEBUG_TYPE_ERROR = 0x824C; ///
enum GL_DEBUG_TYPE_ERROR_ARB = 0x824C; ///
enum GL_DEBUG_TYPE_ERROR_KHR = 0x824C; ///
enum GL_DEBUG_TYPE_MARKER = 0x8268; ///
enum GL_DEBUG_TYPE_MARKER_KHR = 0x8268; ///
enum GL_DEBUG_TYPE_OTHER = 0x8251; ///
enum GL_DEBUG_TYPE_OTHER_ARB = 0x8251; ///
enum GL_DEBUG_TYPE_OTHER_KHR = 0x8251; ///
enum GL_DEBUG_TYPE_PERFORMANCE = 0x8250; ///
enum GL_DEBUG_TYPE_PERFORMANCE_ARB = 0x8250; ///
enum GL_DEBUG_TYPE_PERFORMANCE_KHR = 0x8250; ///
enum GL_DEBUG_TYPE_POP_GROUP = 0x826A; ///
enum GL_DEBUG_TYPE_POP_GROUP_KHR = 0x826A; ///
enum GL_DEBUG_TYPE_PORTABILITY = 0x824F; ///
enum GL_DEBUG_TYPE_PORTABILITY_ARB = 0x824F; ///
enum GL_DEBUG_TYPE_PORTABILITY_KHR = 0x824F; ///
enum GL_DEBUG_TYPE_PUSH_GROUP = 0x8269; ///
enum GL_DEBUG_TYPE_PUSH_GROUP_KHR = 0x8269; ///
enum GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR = 0x824E; ///
enum GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = 0x824E; ///
enum GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR = 0x824E; ///
enum GL_DECAL = 0x2101; ///
enum GL_DECODE_EXT = 0x8A49; ///
enum GL_DECR = 0x1E03; ///
enum GL_DECR_WRAP = 0x8508; ///
enum GL_DECR_WRAP_EXT = 0x8508; ///
enum GL_DECR_WRAP_OES = 0x8508; ///
enum GL_DEFORMATIONS_MASK_SGIX = 0x8196; ///
enum GL_DELETE_STATUS = 0x8B80; ///
enum GL_DEPENDENT_AR_TEXTURE_2D_NV = 0x86E9; ///
enum GL_DEPENDENT_GB_TEXTURE_2D_NV = 0x86EA; ///
enum GL_DEPENDENT_HILO_TEXTURE_2D_NV = 0x8858; ///
enum GL_DEPENDENT_RGB_TEXTURE_3D_NV = 0x8859; ///
enum GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV = 0x885A; ///
enum GL_DEPTH = 0x1801; ///
enum GL_DEPTH24_STENCIL8 = 0x88F0; ///
enum GL_DEPTH24_STENCIL8_EXT = 0x88F0; ///
enum GL_DEPTH24_STENCIL8_OES = 0x88F0; ///
enum GL_DEPTH32F_STENCIL8 = 0x8CAD; ///
enum GL_DEPTH32F_STENCIL8_NV = 0x8DAC; ///
enum GL_DEPTH_ATTACHMENT = 0x8D00; ///
enum GL_DEPTH_ATTACHMENT_EXT = 0x8D00; ///
enum GL_DEPTH_ATTACHMENT_OES = 0x8D00; ///
enum GL_DEPTH_BIAS = 0x0D1F; ///
enum GL_DEPTH_BITS = 0x0D56; ///
enum GL_DEPTH_BOUNDS_EXT = 0x8891; ///
enum GL_DEPTH_BOUNDS_TEST_EXT = 0x8890; ///
enum GL_DEPTH_BUFFER_BIT = 0x00000100; ///
enum GL_DEPTH_BUFFER_BIT0_QCOM = 0x00000100; ///
enum GL_DEPTH_BUFFER_BIT1_QCOM = 0x00000200; ///
enum GL_DEPTH_BUFFER_BIT2_QCOM = 0x00000400; ///
enum GL_DEPTH_BUFFER_BIT3_QCOM = 0x00000800; ///
enum GL_DEPTH_BUFFER_BIT4_QCOM = 0x00001000; ///
enum GL_DEPTH_BUFFER_BIT5_QCOM = 0x00002000; ///
enum GL_DEPTH_BUFFER_BIT6_QCOM = 0x00004000; ///
enum GL_DEPTH_BUFFER_BIT7_QCOM = 0x00008000; ///
enum GL_DEPTH_BUFFER_FLOAT_MODE_NV = 0x8DAF; ///
enum GL_DEPTH_CLAMP = 0x864F; ///
enum GL_DEPTH_CLAMP_FAR_AMD = 0x901F; ///
enum GL_DEPTH_CLAMP_NEAR_AMD = 0x901E; ///
enum GL_DEPTH_CLAMP_NV = 0x864F; ///
enum GL_DEPTH_CLEAR_VALUE = 0x0B73; ///
enum GL_DEPTH_COMPONENT = 0x1902; ///
enum GL_DEPTH_COMPONENT16 = 0x81A5; ///
enum GL_DEPTH_COMPONENT16_ARB = 0x81A5; ///
enum GL_DEPTH_COMPONENT16_NONLINEAR_NV = 0x8E2C; ///
enum GL_DEPTH_COMPONENT16_OES = 0x81A5; ///
enum GL_DEPTH_COMPONENT16_SGIX = 0x81A5; ///
enum GL_DEPTH_COMPONENT24 = 0x81A6; ///
enum GL_DEPTH_COMPONENT24_ARB = 0x81A6; ///
enum GL_DEPTH_COMPONENT24_OES = 0x81A6; ///
enum GL_DEPTH_COMPONENT24_SGIX = 0x81A6; ///
enum GL_DEPTH_COMPONENT32 = 0x81A7; ///
enum GL_DEPTH_COMPONENT32F = 0x8CAC; ///
enum GL_DEPTH_COMPONENT32F_NV = 0x8DAB; ///
enum GL_DEPTH_COMPONENT32_ARB = 0x81A7; ///
enum GL_DEPTH_COMPONENT32_OES = 0x81A7; ///
enum GL_DEPTH_COMPONENT32_SGIX = 0x81A7; ///
enum GL_DEPTH_COMPONENTS = 0x8284; ///
enum GL_DEPTH_EXT = 0x1801; ///
enum GL_DEPTH_FUNC = 0x0B74; ///
enum GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX = 0x8311; ///
enum GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX = 0x8312; ///
enum GL_DEPTH_PASS_INSTRUMENT_SGIX = 0x8310; ///
enum GL_DEPTH_RANGE = 0x0B70; ///
enum GL_DEPTH_RENDERABLE = 0x8287; ///
enum GL_DEPTH_SAMPLES_NV = 0x932D; ///
enum GL_DEPTH_SCALE = 0x0D1E; ///
enum GL_DEPTH_STENCIL = 0x84F9; ///
enum GL_DEPTH_STENCIL_ATTACHMENT = 0x821A; ///
enum GL_DEPTH_STENCIL_EXT = 0x84F9; ///
enum GL_DEPTH_STENCIL_MESA = 0x8750; ///
enum GL_DEPTH_STENCIL_NV = 0x84F9; ///
enum GL_DEPTH_STENCIL_OES = 0x84F9; ///
enum GL_DEPTH_STENCIL_TEXTURE_MODE = 0x90EA; ///
enum GL_DEPTH_STENCIL_TO_BGRA_NV = 0x886F; ///
enum GL_DEPTH_STENCIL_TO_RGBA_NV = 0x886E; ///
enum GL_DEPTH_TEST = 0x0B71; ///
enum GL_DEPTH_TEXTURE_MODE = 0x884B; ///
enum GL_DEPTH_TEXTURE_MODE_ARB = 0x884B; ///
enum GL_DEPTH_WRITEMASK = 0x0B72; ///
enum GL_DETAIL_TEXTURE_2D_BINDING_SGIS = 0x8096; ///
enum GL_DETAIL_TEXTURE_2D_SGIS = 0x8095; ///
enum GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS = 0x809C; ///
enum GL_DETAIL_TEXTURE_LEVEL_SGIS = 0x809A; ///
enum GL_DETAIL_TEXTURE_MODE_SGIS = 0x809B; ///
enum GL_DIFFERENCE = 0x929E; ///
enum GL_DIFFERENCE_KHR = 0x929E; ///
enum GL_DIFFERENCE_NV = 0x929E; ///
enum GL_DIFFUSE = 0x1201; ///
enum GL_DISCARD_ATI = 0x8763; ///
enum GL_DISCARD_NV = 0x8530; ///
enum GL_DISCRETE_AMD = 0x9006; ///
enum GL_DISJOINT_NV = 0x9283; ///
enum GL_DISPATCH_INDIRECT_BUFFER = 0x90EE; ///
enum GL_DISPATCH_INDIRECT_BUFFER_BINDING = 0x90EF; ///
enum GL_DISPLAY_LIST = 0x82E7; ///
enum GL_DISTANCE_ATTENUATION_EXT = 0x8129; ///
enum GL_DISTANCE_ATTENUATION_SGIS = 0x8129; ///
enum GL_DITHER = 0x0BD0; ///
enum GL_DMP_PROGRAM_BINARY_DMP = 0x9253; ///
enum GL_DOMAIN = 0x0A02; ///
enum GL_DONT_CARE = 0x1100; ///
enum GL_DOT2_ADD_ATI = 0x896C; ///
enum GL_DOT3_ATI = 0x8966; ///
enum GL_DOT3_RGB = 0x86AE; ///
enum GL_DOT3_RGBA = 0x86AF; ///
enum GL_DOT3_RGBA_ARB = 0x86AF; ///
enum GL_DOT3_RGBA_EXT = 0x8741; ///
enum GL_DOT3_RGBA_IMG = 0x86AF; ///
enum GL_DOT3_RGB_ARB = 0x86AE; ///
enum GL_DOT3_RGB_EXT = 0x8740; ///
enum GL_DOT4_ATI = 0x8967; ///
enum GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV = 0x885D; ///
enum GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV = 0x86F3; ///
enum GL_DOT_PRODUCT_DEPTH_REPLACE_NV = 0x86ED; ///
enum GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV = 0x86F1; ///
enum GL_DOT_PRODUCT_NV = 0x86EC; ///
enum GL_DOT_PRODUCT_PASS_THROUGH_NV = 0x885B; ///
enum GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV = 0x86F2; ///
enum GL_DOT_PRODUCT_TEXTURE_1D_NV = 0x885C; ///
enum GL_DOT_PRODUCT_TEXTURE_2D_NV = 0x86EE; ///
enum GL_DOT_PRODUCT_TEXTURE_3D_NV = 0x86EF; ///
enum GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV = 0x86F0; ///
enum GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV = 0x864E; ///
enum GL_DOUBLE = 0x140A; ///
enum GL_DOUBLEBUFFER = 0x0C32; ///
enum GL_DOUBLE_EXT = 0x140A; ///
enum GL_DOUBLE_MAT2 = 0x8F46; ///
enum GL_DOUBLE_MAT2_EXT = 0x8F46; ///
enum GL_DOUBLE_MAT2x3 = 0x8F49; ///
enum GL_DOUBLE_MAT2x3_EXT = 0x8F49; ///
enum GL_DOUBLE_MAT2x4 = 0x8F4A; ///
enum GL_DOUBLE_MAT2x4_EXT = 0x8F4A; ///
enum GL_DOUBLE_MAT3 = 0x8F47; ///
enum GL_DOUBLE_MAT3_EXT = 0x8F47; ///
enum GL_DOUBLE_MAT3x2 = 0x8F4B; ///
enum GL_DOUBLE_MAT3x2_EXT = 0x8F4B; ///
enum GL_DOUBLE_MAT3x4 = 0x8F4C; ///
enum GL_DOUBLE_MAT3x4_EXT = 0x8F4C; ///
enum GL_DOUBLE_MAT4 = 0x8F48; ///
enum GL_DOUBLE_MAT4_EXT = 0x8F48; ///
enum GL_DOUBLE_MAT4x2 = 0x8F4D; ///
enum GL_DOUBLE_MAT4x2_EXT = 0x8F4D; ///
enum GL_DOUBLE_MAT4x3 = 0x8F4E; ///
enum GL_DOUBLE_MAT4x3_EXT = 0x8F4E; ///
enum GL_DOUBLE_VEC2 = 0x8FFC; ///
enum GL_DOUBLE_VEC2_EXT = 0x8FFC; ///
enum GL_DOUBLE_VEC3 = 0x8FFD; ///
enum GL_DOUBLE_VEC3_EXT = 0x8FFD; ///
enum GL_DOUBLE_VEC4 = 0x8FFE; ///
enum GL_DOUBLE_VEC4_EXT = 0x8FFE; ///
enum GL_DOWNSAMPLE_SCALES_IMG = 0x913E; ///
enum GL_DRAW_ARRAYS_COMMAND_NV = 0x0003; ///
enum GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV = 0x0007; ///
enum GL_DRAW_ARRAYS_STRIP_COMMAND_NV = 0x0005; ///
enum GL_DRAW_BUFFER = 0x0C01; ///
enum GL_DRAW_BUFFER0 = 0x8825; ///
enum GL_DRAW_BUFFER0_ARB = 0x8825; ///
enum GL_DRAW_BUFFER0_ATI = 0x8825; ///
enum GL_DRAW_BUFFER0_EXT = 0x8825; ///
enum GL_DRAW_BUFFER0_NV = 0x8825; ///
enum GL_DRAW_BUFFER1 = 0x8826; ///
enum GL_DRAW_BUFFER10 = 0x882F; ///
enum GL_DRAW_BUFFER10_ARB = 0x882F; ///
enum GL_DRAW_BUFFER10_ATI = 0x882F; ///
enum GL_DRAW_BUFFER10_EXT = 0x882F; ///
enum GL_DRAW_BUFFER10_NV = 0x882F; ///
enum GL_DRAW_BUFFER11 = 0x8830; ///
enum GL_DRAW_BUFFER11_ARB = 0x8830; ///
enum GL_DRAW_BUFFER11_ATI = 0x8830; ///
enum GL_DRAW_BUFFER11_EXT = 0x8830; ///
enum GL_DRAW_BUFFER11_NV = 0x8830; ///
enum GL_DRAW_BUFFER12 = 0x8831; ///
enum GL_DRAW_BUFFER12_ARB = 0x8831; ///
enum GL_DRAW_BUFFER12_ATI = 0x8831; ///
enum GL_DRAW_BUFFER12_EXT = 0x8831; ///
enum GL_DRAW_BUFFER12_NV = 0x8831; ///
enum GL_DRAW_BUFFER13 = 0x8832; ///
enum GL_DRAW_BUFFER13_ARB = 0x8832; ///
enum GL_DRAW_BUFFER13_ATI = 0x8832; ///
enum GL_DRAW_BUFFER13_EXT = 0x8832; ///
enum GL_DRAW_BUFFER13_NV = 0x8832; ///
enum GL_DRAW_BUFFER14 = 0x8833; ///
enum GL_DRAW_BUFFER14_ARB = 0x8833; ///
enum GL_DRAW_BUFFER14_ATI = 0x8833; ///
enum GL_DRAW_BUFFER14_EXT = 0x8833; ///
enum GL_DRAW_BUFFER14_NV = 0x8833; ///
enum GL_DRAW_BUFFER15 = 0x8834; ///
enum GL_DRAW_BUFFER15_ARB = 0x8834; ///
enum GL_DRAW_BUFFER15_ATI = 0x8834; ///
enum GL_DRAW_BUFFER15_EXT = 0x8834; ///
enum GL_DRAW_BUFFER15_NV = 0x8834; ///
enum GL_DRAW_BUFFER1_ARB = 0x8826; ///
enum GL_DRAW_BUFFER1_ATI = 0x8826; ///
enum GL_DRAW_BUFFER1_EXT = 0x8826; ///
enum GL_DRAW_BUFFER1_NV = 0x8826; ///
enum GL_DRAW_BUFFER2 = 0x8827; ///
enum GL_DRAW_BUFFER2_ARB = 0x8827; ///
enum GL_DRAW_BUFFER2_ATI = 0x8827; ///
enum GL_DRAW_BUFFER2_EXT = 0x8827; ///
enum GL_DRAW_BUFFER2_NV = 0x8827; ///
enum GL_DRAW_BUFFER3 = 0x8828; ///
enum GL_DRAW_BUFFER3_ARB = 0x8828; ///
enum GL_DRAW_BUFFER3_ATI = 0x8828; ///
enum GL_DRAW_BUFFER3_EXT = 0x8828; ///
enum GL_DRAW_BUFFER3_NV = 0x8828; ///
enum GL_DRAW_BUFFER4 = 0x8829; ///
enum GL_DRAW_BUFFER4_ARB = 0x8829; ///
enum GL_DRAW_BUFFER4_ATI = 0x8829; ///
enum GL_DRAW_BUFFER4_EXT = 0x8829; ///
enum GL_DRAW_BUFFER4_NV = 0x8829; ///
enum GL_DRAW_BUFFER5 = 0x882A; ///
enum GL_DRAW_BUFFER5_ARB = 0x882A; ///
enum GL_DRAW_BUFFER5_ATI = 0x882A; ///
enum GL_DRAW_BUFFER5_EXT = 0x882A; ///
enum GL_DRAW_BUFFER5_NV = 0x882A; ///
enum GL_DRAW_BUFFER6 = 0x882B; ///
enum GL_DRAW_BUFFER6_ARB = 0x882B; ///
enum GL_DRAW_BUFFER6_ATI = 0x882B; ///
enum GL_DRAW_BUFFER6_EXT = 0x882B; ///
enum GL_DRAW_BUFFER6_NV = 0x882B; ///
enum GL_DRAW_BUFFER7 = 0x882C; ///
enum GL_DRAW_BUFFER7_ARB = 0x882C; ///
enum GL_DRAW_BUFFER7_ATI = 0x882C; ///
enum GL_DRAW_BUFFER7_EXT = 0x882C; ///
enum GL_DRAW_BUFFER7_NV = 0x882C; ///
enum GL_DRAW_BUFFER8 = 0x882D; ///
enum GL_DRAW_BUFFER8_ARB = 0x882D; ///
enum GL_DRAW_BUFFER8_ATI = 0x882D; ///
enum GL_DRAW_BUFFER8_EXT = 0x882D; ///
enum GL_DRAW_BUFFER8_NV = 0x882D; ///
enum GL_DRAW_BUFFER9 = 0x882E; ///
enum GL_DRAW_BUFFER9_ARB = 0x882E; ///
enum GL_DRAW_BUFFER9_ATI = 0x882E; ///
enum GL_DRAW_BUFFER9_EXT = 0x882E; ///
enum GL_DRAW_BUFFER9_NV = 0x882E; ///
enum GL_DRAW_BUFFER_EXT = 0x0C01; ///
enum GL_DRAW_ELEMENTS_COMMAND_NV = 0x0002; ///
enum GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV = 0x0006; ///
enum GL_DRAW_ELEMENTS_STRIP_COMMAND_NV = 0x0004; ///
enum GL_DRAW_FRAMEBUFFER = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_ANGLE = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_APPLE = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_BINDING = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_ANGLE = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_APPLE = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_EXT = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_NV = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_EXT = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_NV = 0x8CA9; ///
enum GL_DRAW_INDIRECT_ADDRESS_NV = 0x8F41; ///
enum GL_DRAW_INDIRECT_BUFFER = 0x8F3F; ///
enum GL_DRAW_INDIRECT_BUFFER_BINDING = 0x8F43; ///
enum GL_DRAW_INDIRECT_LENGTH_NV = 0x8F42; ///
enum GL_DRAW_INDIRECT_UNIFIED_NV = 0x8F40; ///
enum GL_DRAW_PIXELS_APPLE = 0x8A0A; ///
enum GL_DRAW_PIXEL_TOKEN = 0x0705; ///
enum GL_DSDT8_MAG8_INTENSITY8_NV = 0x870B; ///
enum GL_DSDT8_MAG8_NV = 0x870A; ///
enum GL_DSDT8_NV = 0x8709; ///
enum GL_DSDT_MAG_INTENSITY_NV = 0x86DC; ///
enum GL_DSDT_MAG_NV = 0x86F6; ///
enum GL_DSDT_MAG_VIB_NV = 0x86F7; ///
enum GL_DSDT_NV = 0x86F5; ///
enum GL_DST_ALPHA = 0x0304; ///
enum GL_DST_ATOP_NV = 0x928F; ///
enum GL_DST_COLOR = 0x0306; ///
enum GL_DST_IN_NV = 0x928B; ///
enum GL_DST_NV = 0x9287; ///
enum GL_DST_OUT_NV = 0x928D; ///
enum GL_DST_OVER_NV = 0x9289; ///
enum GL_DS_BIAS_NV = 0x8716; ///
enum GL_DS_SCALE_NV = 0x8710; ///
enum GL_DT_BIAS_NV = 0x8717; ///
enum GL_DT_SCALE_NV = 0x8711; ///
enum GL_DU8DV8_ATI = 0x877A; ///
enum GL_DUAL_ALPHA12_SGIS = 0x8112; ///
enum GL_DUAL_ALPHA16_SGIS = 0x8113; ///
enum GL_DUAL_ALPHA4_SGIS = 0x8110; ///
enum GL_DUAL_ALPHA8_SGIS = 0x8111; ///
enum GL_DUAL_INTENSITY12_SGIS = 0x811A; ///
enum GL_DUAL_INTENSITY16_SGIS = 0x811B; ///
enum GL_DUAL_INTENSITY4_SGIS = 0x8118; ///
enum GL_DUAL_INTENSITY8_SGIS = 0x8119; ///
enum GL_DUAL_LUMINANCE12_SGIS = 0x8116; ///
enum GL_DUAL_LUMINANCE16_SGIS = 0x8117; ///
enum GL_DUAL_LUMINANCE4_SGIS = 0x8114; ///
enum GL_DUAL_LUMINANCE8_SGIS = 0x8115; ///
enum GL_DUAL_LUMINANCE_ALPHA4_SGIS = 0x811C; ///
enum GL_DUAL_LUMINANCE_ALPHA8_SGIS = 0x811D; ///
enum GL_DUAL_TEXTURE_SELECT_SGIS = 0x8124; ///
enum GL_DUDV_ATI = 0x8779; ///
enum GL_DUP_FIRST_CUBIC_CURVE_TO_NV = 0xF2; ///
enum GL_DUP_LAST_CUBIC_CURVE_TO_NV = 0xF4; ///
enum GL_DYNAMIC_ATI = 0x8761; ///
enum GL_DYNAMIC_COPY = 0x88EA; ///
enum GL_DYNAMIC_COPY_ARB = 0x88EA; ///
enum GL_DYNAMIC_DRAW = 0x88E8; ///
enum GL_DYNAMIC_DRAW_ARB = 0x88E8; ///
enum GL_DYNAMIC_READ = 0x88E9; ///
enum GL_DYNAMIC_READ_ARB = 0x88E9; ///
enum GL_DYNAMIC_STORAGE_BIT = 0x0100; ///
enum GL_DYNAMIC_STORAGE_BIT_EXT = 0x0100; ///
enum GL_EDGEFLAG_BIT_PGI = 0x00040000; ///
enum GL_EDGE_FLAG = 0x0B43; ///
enum GL_EDGE_FLAG_ARRAY = 0x8079; ///
enum GL_EDGE_FLAG_ARRAY_ADDRESS_NV = 0x8F26; ///
enum GL_EDGE_FLAG_ARRAY_BUFFER_BINDING = 0x889B; ///
enum GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB = 0x889B; ///
enum GL_EDGE_FLAG_ARRAY_COUNT_EXT = 0x808D; ///
enum GL_EDGE_FLAG_ARRAY_EXT = 0x8079; ///
enum GL_EDGE_FLAG_ARRAY_LENGTH_NV = 0x8F30; ///
enum GL_EDGE_FLAG_ARRAY_LIST_IBM = 0x103075; ///
enum GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM = 0x103085; ///
enum GL_EDGE_FLAG_ARRAY_POINTER = 0x8093; ///
enum GL_EDGE_FLAG_ARRAY_POINTER_EXT = 0x8093; ///
enum GL_EDGE_FLAG_ARRAY_STRIDE = 0x808C; ///
enum GL_EDGE_FLAG_ARRAY_STRIDE_EXT = 0x808C; ///
enum GL_EFFECTIVE_RASTER_SAMPLES_EXT = 0x932C; ///
enum GL_EIGHTH_BIT_ATI = 0x00000020; ///
enum GL_ELEMENT_ADDRESS_COMMAND_NV = 0x0008; ///
enum GL_ELEMENT_ARRAY_ADDRESS_NV = 0x8F29; ///
enum GL_ELEMENT_ARRAY_APPLE = 0x8A0C; ///
enum GL_ELEMENT_ARRAY_ATI = 0x8768; ///
enum GL_ELEMENT_ARRAY_BARRIER_BIT = 0x00000002; ///
enum GL_ELEMENT_ARRAY_BARRIER_BIT_EXT = 0x00000002; ///
enum GL_ELEMENT_ARRAY_BUFFER = 0x8893; ///
enum GL_ELEMENT_ARRAY_BUFFER_ARB = 0x8893; ///
enum GL_ELEMENT_ARRAY_BUFFER_BINDING = 0x8895; ///
enum GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB = 0x8895; ///
enum GL_ELEMENT_ARRAY_LENGTH_NV = 0x8F33; ///
enum GL_ELEMENT_ARRAY_POINTER_APPLE = 0x8A0E; ///
enum GL_ELEMENT_ARRAY_POINTER_ATI = 0x876A; ///
enum GL_ELEMENT_ARRAY_TYPE_APPLE = 0x8A0D; ///
enum GL_ELEMENT_ARRAY_TYPE_ATI = 0x8769; ///
enum GL_ELEMENT_ARRAY_UNIFIED_NV = 0x8F1F; ///
enum GL_EMBOSS_CONSTANT_NV = 0x855E; ///
enum GL_EMBOSS_LIGHT_NV = 0x855D; ///
enum GL_EMBOSS_MAP_NV = 0x855F; ///
enum GL_EMISSION = 0x1600; ///
enum GL_ENABLE_BIT = 0x00002000; ///
enum GL_EQUAL = 0x0202; ///
enum GL_EQUIV = 0x1509; ///
enum GL_ETC1_RGB8_OES = 0x8D64; ///
enum GL_ETC1_SRGB8_NV = 0x88EE; ///
enum GL_EVAL_2D_NV = 0x86C0; ///
enum GL_EVAL_BIT = 0x00010000; ///
enum GL_EVAL_FRACTIONAL_TESSELLATION_NV = 0x86C5; ///
enum GL_EVAL_TRIANGULAR_2D_NV = 0x86C1; ///
enum GL_EVAL_VERTEX_ATTRIB0_NV = 0x86C6; ///
enum GL_EVAL_VERTEX_ATTRIB10_NV = 0x86D0; ///
enum GL_EVAL_VERTEX_ATTRIB11_NV = 0x86D1; ///
enum GL_EVAL_VERTEX_ATTRIB12_NV = 0x86D2; ///
enum GL_EVAL_VERTEX_ATTRIB13_NV = 0x86D3; ///
enum GL_EVAL_VERTEX_ATTRIB14_NV = 0x86D4; ///
enum GL_EVAL_VERTEX_ATTRIB15_NV = 0x86D5; ///
enum GL_EVAL_VERTEX_ATTRIB1_NV = 0x86C7; ///
enum GL_EVAL_VERTEX_ATTRIB2_NV = 0x86C8; ///
enum GL_EVAL_VERTEX_ATTRIB3_NV = 0x86C9; ///
enum GL_EVAL_VERTEX_ATTRIB4_NV = 0x86CA; ///
enum GL_EVAL_VERTEX_ATTRIB5_NV = 0x86CB; ///
enum GL_EVAL_VERTEX_ATTRIB6_NV = 0x86CC; ///
enum GL_EVAL_VERTEX_ATTRIB7_NV = 0x86CD; ///
enum GL_EVAL_VERTEX_ATTRIB8_NV = 0x86CE; ///
enum GL_EVAL_VERTEX_ATTRIB9_NV = 0x86CF; ///
enum GL_EXCLUSION = 0x92A0; ///
enum GL_EXCLUSION_KHR = 0x92A0; ///
enum GL_EXCLUSION_NV = 0x92A0; ///
enum GL_EXCLUSIVE_EXT = 0x8F11; ///
enum GL_EXP = 0x0800; ///
enum GL_EXP2 = 0x0801; ///
enum GL_EXPAND_NEGATE_NV = 0x8539; ///
enum GL_EXPAND_NORMAL_NV = 0x8538; ///
enum GL_EXTENSIONS = 0x1F03; ///
enum GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD = 0x9160; ///
enum GL_EYE_DISTANCE_TO_LINE_SGIS = 0x81F2; ///
enum GL_EYE_DISTANCE_TO_POINT_SGIS = 0x81F0; ///
enum GL_EYE_LINEAR = 0x2400; ///
enum GL_EYE_LINEAR_NV = 0x2400; ///
enum GL_EYE_LINE_SGIS = 0x81F6; ///
enum GL_EYE_PLANE = 0x2502; ///
enum GL_EYE_PLANE_ABSOLUTE_NV = 0x855C; ///
enum GL_EYE_POINT_SGIS = 0x81F4; ///
enum GL_EYE_RADIAL_NV = 0x855B; ///
enum GL_E_TIMES_F_NV = 0x8531; ///
enum GL_FACTOR_ALPHA_MODULATE_IMG = 0x8C07; ///
enum GL_FACTOR_MAX_AMD = 0x901D; ///
enum GL_FACTOR_MIN_AMD = 0x901C; ///
enum GL_FAILURE_NV = 0x9030; ///
enum GL_FALSE = 0; ///
enum GL_FASTEST = 0x1101; ///
enum GL_FEEDBACK = 0x1C01; ///
enum GL_FEEDBACK_BUFFER_POINTER = 0x0DF0; ///
enum GL_FEEDBACK_BUFFER_SIZE = 0x0DF1; ///
enum GL_FEEDBACK_BUFFER_TYPE = 0x0DF2; ///
enum GL_FENCE_APPLE = 0x8A0B; ///
enum GL_FENCE_CONDITION_NV = 0x84F4; ///
enum GL_FENCE_STATUS_NV = 0x84F3; ///
enum GL_FETCH_PER_SAMPLE_ARM = 0x8F65; ///
enum GL_FIELDS_NV = 0x8E27; ///
enum GL_FIELD_LOWER_NV = 0x9023; ///
enum GL_FIELD_UPPER_NV = 0x9022; ///
enum GL_FILE_NAME_NV = 0x9074; ///
enum GL_FILL = 0x1B02; ///
enum GL_FILL_NV = 0x1B02; ///
enum GL_FILL_RECTANGLE_NV = 0x933C; ///
enum GL_FILTER = 0x829A; ///
enum GL_FILTER4_SGIS = 0x8146; ///
enum GL_FIRST_TO_REST_NV = 0x90AF; ///
enum GL_FIRST_VERTEX_CONVENTION = 0x8E4D; ///
enum GL_FIRST_VERTEX_CONVENTION_EXT = 0x8E4D; ///
enum GL_FIRST_VERTEX_CONVENTION_OES = 0x8E4D; ///
enum GL_FIXED = 0x140C; ///
enum GL_FIXED_OES = 0x140C; ///
enum GL_FIXED_ONLY = 0x891D; ///
enum GL_FIXED_ONLY_ARB = 0x891D; ///
enum GL_FLAT = 0x1D00; ///
enum GL_FLOAT = 0x1406; ///
enum GL_FLOAT16_MAT2_AMD = 0x91C5; ///
enum GL_FLOAT16_MAT2x3_AMD = 0x91C8; ///
enum GL_FLOAT16_MAT2x4_AMD = 0x91C9; ///
enum GL_FLOAT16_MAT3_AMD = 0x91C6; ///
enum GL_FLOAT16_MAT3x2_AMD = 0x91CA; ///
enum GL_FLOAT16_MAT3x4_AMD = 0x91CB; ///
enum GL_FLOAT16_MAT4_AMD = 0x91C7; ///
enum GL_FLOAT16_MAT4x2_AMD = 0x91CC; ///
enum GL_FLOAT16_MAT4x3_AMD = 0x91CD; ///
enum GL_FLOAT16_NV = 0x8FF8; ///
enum GL_FLOAT16_VEC2_NV = 0x8FF9; ///
enum GL_FLOAT16_VEC3_NV = 0x8FFA; ///
enum GL_FLOAT16_VEC4_NV = 0x8FFB; ///
enum GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD; ///
enum GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV = 0x8DAD; ///
enum GL_FLOAT_CLEAR_COLOR_VALUE_NV = 0x888D; ///
enum GL_FLOAT_MAT2 = 0x8B5A; ///
enum GL_FLOAT_MAT2_ARB = 0x8B5A; ///
enum GL_FLOAT_MAT2x3 = 0x8B65; ///
enum GL_FLOAT_MAT2x3_NV = 0x8B65; ///
enum GL_FLOAT_MAT2x4 = 0x8B66; ///
enum GL_FLOAT_MAT2x4_NV = 0x8B66; ///
enum GL_FLOAT_MAT3 = 0x8B5B; ///
enum GL_FLOAT_MAT3_ARB = 0x8B5B; ///
enum GL_FLOAT_MAT3x2 = 0x8B67; ///
enum GL_FLOAT_MAT3x2_NV = 0x8B67; ///
enum GL_FLOAT_MAT3x4 = 0x8B68; ///
enum GL_FLOAT_MAT3x4_NV = 0x8B68; ///
enum GL_FLOAT_MAT4 = 0x8B5C; ///
enum GL_FLOAT_MAT4_ARB = 0x8B5C; ///
enum GL_FLOAT_MAT4x2 = 0x8B69; ///
enum GL_FLOAT_MAT4x2_NV = 0x8B69; ///
enum GL_FLOAT_MAT4x3 = 0x8B6A; ///
enum GL_FLOAT_MAT4x3_NV = 0x8B6A; ///
enum GL_FLOAT_R16_NV = 0x8884; ///
enum GL_FLOAT_R32_NV = 0x8885; ///
enum GL_FLOAT_RG16_NV = 0x8886; ///
enum GL_FLOAT_RG32_NV = 0x8887; ///
enum GL_FLOAT_RGB16_NV = 0x8888; ///
enum GL_FLOAT_RGB32_NV = 0x8889; ///
enum GL_FLOAT_RGBA16_NV = 0x888A; ///
enum GL_FLOAT_RGBA32_NV = 0x888B; ///
enum GL_FLOAT_RGBA_MODE_NV = 0x888E; ///
enum GL_FLOAT_RGBA_NV = 0x8883; ///
enum GL_FLOAT_RGB_NV = 0x8882; ///
enum GL_FLOAT_RG_NV = 0x8881; ///
enum GL_FLOAT_R_NV = 0x8880; ///
enum GL_FLOAT_VEC2 = 0x8B50; ///
enum GL_FLOAT_VEC2_ARB = 0x8B50; ///
enum GL_FLOAT_VEC3 = 0x8B51; ///
enum GL_FLOAT_VEC3_ARB = 0x8B51; ///
enum GL_FLOAT_VEC4 = 0x8B52; ///
enum GL_FLOAT_VEC4_ARB = 0x8B52; ///
enum GL_FOG = 0x0B60; ///
enum GL_FOG_BIT = 0x00000080; ///
enum GL_FOG_COLOR = 0x0B66; ///
enum GL_FOG_COORD = 0x8451; ///
enum GL_FOG_COORDINATE = 0x8451; ///
enum GL_FOG_COORDINATE_ARRAY = 0x8457; ///
enum GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING = 0x889D; ///
enum GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB = 0x889D; ///
enum GL_FOG_COORDINATE_ARRAY_EXT = 0x8457; ///
enum GL_FOG_COORDINATE_ARRAY_LIST_IBM = 0x103076; ///
enum GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM = 0x103086; ///
enum GL_FOG_COORDINATE_ARRAY_POINTER = 0x8456; ///
enum GL_FOG_COORDINATE_ARRAY_POINTER_EXT = 0x8456; ///
enum GL_FOG_COORDINATE_ARRAY_STRIDE = 0x8455; ///
enum GL_FOG_COORDINATE_ARRAY_STRIDE_EXT = 0x8455; ///
enum GL_FOG_COORDINATE_ARRAY_TYPE = 0x8454; ///
enum GL_FOG_COORDINATE_ARRAY_TYPE_EXT = 0x8454; ///
enum GL_FOG_COORDINATE_EXT = 0x8451; ///
enum GL_FOG_COORDINATE_SOURCE = 0x8450; ///
enum GL_FOG_COORDINATE_SOURCE_EXT = 0x8450; ///
enum GL_FOG_COORD_ARRAY = 0x8457; ///
enum GL_FOG_COORD_ARRAY_ADDRESS_NV = 0x8F28; ///
enum GL_FOG_COORD_ARRAY_BUFFER_BINDING = 0x889D; ///
enum GL_FOG_COORD_ARRAY_LENGTH_NV = 0x8F32; ///
enum GL_FOG_COORD_ARRAY_POINTER = 0x8456; ///
enum GL_FOG_COORD_ARRAY_STRIDE = 0x8455; ///
enum GL_FOG_COORD_ARRAY_TYPE = 0x8454; ///
enum GL_FOG_COORD_SRC = 0x8450; ///
enum GL_FOG_DENSITY = 0x0B62; ///
enum GL_FOG_DISTANCE_MODE_NV = 0x855A; ///
enum GL_FOG_END = 0x0B64; ///
enum GL_FOG_FUNC_POINTS_SGIS = 0x812B; ///
enum GL_FOG_FUNC_SGIS = 0x812A; ///
enum GL_FOG_HINT = 0x0C54; ///
enum GL_FOG_INDEX = 0x0B61; ///
enum GL_FOG_MODE = 0x0B65; ///
enum GL_FOG_OFFSET_SGIX = 0x8198; ///
enum GL_FOG_OFFSET_VALUE_SGIX = 0x8199; ///
enum GL_FOG_SPECULAR_TEXTURE_WIN = 0x80EC; ///
enum GL_FOG_START = 0x0B63; ///
enum GL_FONT_ASCENDER_BIT_NV = 0x00200000; ///
enum GL_FONT_DESCENDER_BIT_NV = 0x00400000; ///
enum GL_FONT_GLYPHS_AVAILABLE_NV = 0x9368; ///
enum GL_FONT_HAS_KERNING_BIT_NV = 0x10000000; ///
enum GL_FONT_HEIGHT_BIT_NV = 0x00800000; ///
enum GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV = 0x02000000; ///
enum GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV = 0x01000000; ///
enum GL_FONT_NUM_GLYPH_INDICES_BIT_NV = 0x20000000; ///
enum GL_FONT_TARGET_UNAVAILABLE_NV = 0x9369; ///
enum GL_FONT_UNAVAILABLE_NV = 0x936A; ///
enum GL_FONT_UNDERLINE_POSITION_BIT_NV = 0x04000000; ///
enum GL_FONT_UNDERLINE_THICKNESS_BIT_NV = 0x08000000; ///
enum GL_FONT_UNINTELLIGIBLE_NV = 0x936B; ///
enum GL_FONT_UNITS_PER_EM_BIT_NV = 0x00100000; ///
enum GL_FONT_X_MAX_BOUNDS_BIT_NV = 0x00040000; ///
enum GL_FONT_X_MIN_BOUNDS_BIT_NV = 0x00010000; ///
enum GL_FONT_Y_MAX_BOUNDS_BIT_NV = 0x00080000; ///
enum GL_FONT_Y_MIN_BOUNDS_BIT_NV = 0x00020000; ///
enum GL_FORCE_BLUE_TO_ONE_NV = 0x8860; ///
enum GL_FORMAT_SUBSAMPLE_244_244_OML = 0x8983; ///
enum GL_FORMAT_SUBSAMPLE_24_24_OML = 0x8982; ///
enum GL_FRACTIONAL_EVEN = 0x8E7C; ///
enum GL_FRACTIONAL_EVEN_EXT = 0x8E7C; ///
enum GL_FRACTIONAL_EVEN_OES = 0x8E7C; ///
enum GL_FRACTIONAL_ODD = 0x8E7B; ///
enum GL_FRACTIONAL_ODD_EXT = 0x8E7B; ///
enum GL_FRACTIONAL_ODD_OES = 0x8E7B; ///
enum GL_FRAGMENTS_INSTRUMENT_COUNTERS_SGIX = 0x8314; ///
enum GL_FRAGMENTS_INSTRUMENT_MAX_SGIX = 0x8315; ///
enum GL_FRAGMENTS_INSTRUMENT_SGIX = 0x8313; ///
enum GL_FRAGMENT_ALPHA_MODULATE_IMG = 0x8C08; ///
enum GL_FRAGMENT_COLOR_EXT = 0x834C; ///
enum GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX = 0x8402; ///
enum GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = 0x8403; ///
enum GL_FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401; ///
enum GL_FRAGMENT_COVERAGE_COLOR_NV = 0x92DE; ///
enum GL_FRAGMENT_COVERAGE_TO_COLOR_NV = 0x92DD; ///
enum GL_FRAGMENT_DEPTH = 0x8452; ///
enum GL_FRAGMENT_DEPTH_EXT = 0x8452; ///
enum GL_FRAGMENT_INPUT_NV = 0x936D; ///
enum GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D; ///
enum GL_FRAGMENT_INTERPOLATION_OFFSET_BITS_OES = 0x8E5D; ///
enum GL_FRAGMENT_LIGHT0_SGIX = 0x840C; ///
enum GL_FRAGMENT_LIGHT1_SGIX = 0x840D; ///
enum GL_FRAGMENT_LIGHT2_SGIX = 0x840E; ///
enum GL_FRAGMENT_LIGHT3_SGIX = 0x840F; ///
enum GL_FRAGMENT_LIGHT4_SGIX = 0x8410; ///
enum GL_FRAGMENT_LIGHT5_SGIX = 0x8411; ///
enum GL_FRAGMENT_LIGHT6_SGIX = 0x8412; ///
enum GL_FRAGMENT_LIGHT7_SGIX = 0x8413; ///
enum GL_FRAGMENT_LIGHTING_SGIX = 0x8400; ///
enum GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A; ///
enum GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408; ///
enum GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B; ///
enum GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409; ///
enum GL_FRAGMENT_MATERIAL_EXT = 0x8349; ///
enum GL_FRAGMENT_NORMAL_EXT = 0x834A; ///
enum GL_FRAGMENT_PROGRAM_ARB = 0x8804; ///
enum GL_FRAGMENT_PROGRAM_BINDING_NV = 0x8873; ///
enum GL_FRAGMENT_PROGRAM_CALLBACK_DATA_MESA = 0x8BB3; ///
enum GL_FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA = 0x8BB2; ///
enum GL_FRAGMENT_PROGRAM_CALLBACK_MESA = 0x8BB1; ///
enum GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV = 0x8E5D; ///
enum GL_FRAGMENT_PROGRAM_NV = 0x8870; ///
enum GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA4; ///
enum GL_FRAGMENT_PROGRAM_POSITION_MESA = 0x8BB0; ///
enum GL_FRAGMENT_SHADER = 0x8B30; ///
enum GL_FRAGMENT_SHADER_ARB = 0x8B30; ///
enum GL_FRAGMENT_SHADER_ATI = 0x8920; ///
enum GL_FRAGMENT_SHADER_BIT = 0x00000002; ///
enum GL_FRAGMENT_SHADER_BIT_EXT = 0x00000002; ///
enum GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B; ///
enum GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = 0x8B8B; ///
enum GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B; ///
enum GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT = 0x8A52; ///
enum GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM = 0x8F66; ///
enum GL_FRAGMENT_SHADER_INVOCATIONS_ARB = 0x82F4; ///
enum GL_FRAGMENT_SUBROUTINE = 0x92EC; ///
enum GL_FRAGMENT_SUBROUTINE_UNIFORM = 0x92F2; ///
enum GL_FRAGMENT_TEXTURE = 0x829F; ///
enum GL_FRAMEBUFFER = 0x8D40; ///
enum GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215; ///
enum GL_FRAMEBUFFER_ATTACHMENT_ANGLE = 0x93A3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 0x8210; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 0x8211; ///
enum GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216; ///
enum GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED_OES = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT = 0x8CD1; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES = 0x8CD1; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT = 0x8CD0; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES = 0x8CD0; ///
enum GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212; ///
enum GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR = 0x9632; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT = 0x8CD3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES = 0x8CD3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT = 0x8CD2; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES = 0x8CD2; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR = 0x9630; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT = 0x8D6C; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG = 0x913F; ///
enum GL_FRAMEBUFFER_BARRIER_BIT = 0x00000400; ///
enum GL_FRAMEBUFFER_BARRIER_BIT_EXT = 0x00000400; ///
enum GL_FRAMEBUFFER_BINDING = 0x8CA6; ///
enum GL_FRAMEBUFFER_BINDING_ANGLE = 0x8CA6; ///
enum GL_FRAMEBUFFER_BINDING_EXT = 0x8CA6; ///
enum GL_FRAMEBUFFER_BINDING_OES = 0x8CA6; ///
enum GL_FRAMEBUFFER_BLEND = 0x828B; ///
enum GL_FRAMEBUFFER_COMPLETE = 0x8CD5; ///
enum GL_FRAMEBUFFER_COMPLETE_EXT = 0x8CD5; ///
enum GL_FRAMEBUFFER_COMPLETE_OES = 0x8CD5; ///
enum GL_FRAMEBUFFER_DEFAULT = 0x8218; ///
enum GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = 0x9314; ///
enum GL_FRAMEBUFFER_DEFAULT_HEIGHT = 0x9311; ///
enum GL_FRAMEBUFFER_DEFAULT_LAYERS = 0x9312; ///
enum GL_FRAMEBUFFER_DEFAULT_LAYERS_EXT = 0x9312; ///
enum GL_FRAMEBUFFER_DEFAULT_LAYERS_OES = 0x9312; ///
enum GL_FRAMEBUFFER_DEFAULT_SAMPLES = 0x9313; ///
enum GL_FRAMEBUFFER_DEFAULT_WIDTH = 0x9310; ///
enum GL_FRAMEBUFFER_EXT = 0x8D40; ///
enum GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6; ///
enum GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT = 0x8CD6; ///
enum GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_OES = 0x8CD6; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT = 0x8CD9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_OES = 0x8CD9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 0x8CDB; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT = 0x8CDB; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_OES = 0x8CDB; ///
enum GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT = 0x8CDA; ///
enum GL_FRAMEBUFFER_INCOMPLETE_FORMATS_OES = 0x8CDA; ///
enum GL_FRAMEBUFFER_INCOMPLETE_INSUFFICIENT_SHADER_COMBINED_LOCAL_STORAGE_EXT = 0x9652; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB = 0x8DA9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT = 0x8DA9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT = 0x8CD7; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_OES = 0x8CD7; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_AND_DOWNSAMPLE_IMG = 0x913C; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG = 0x9134; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 0x8CDC; ///
enum GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT = 0x8CDC; ///
enum GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_OES = 0x8CDC; ///
enum GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR = 0x9633; ///
enum GL_FRAMEBUFFER_OES = 0x8D40; ///
enum GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB = 0x9342; ///
enum GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV = 0x9342; ///
enum GL_FRAMEBUFFER_RENDERABLE = 0x8289; ///
enum GL_FRAMEBUFFER_RENDERABLE_LAYERED = 0x828A; ///
enum GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB = 0x9343; ///
enum GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV = 0x9343; ///
enum GL_FRAMEBUFFER_SRGB = 0x8DB9; ///
enum GL_FRAMEBUFFER_SRGB_CAPABLE_EXT = 0x8DBA; ///
enum GL_FRAMEBUFFER_SRGB_EXT = 0x8DB9; ///
enum GL_FRAMEBUFFER_UNDEFINED = 0x8219; ///
enum GL_FRAMEBUFFER_UNDEFINED_OES = 0x8219; ///
enum GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD; ///
enum GL_FRAMEBUFFER_UNSUPPORTED_EXT = 0x8CDD; ///
enum GL_FRAMEBUFFER_UNSUPPORTED_OES = 0x8CDD; ///
enum GL_FRAMEZOOM_FACTOR_SGIX = 0x818C; ///
enum GL_FRAMEZOOM_SGIX = 0x818B; ///
enum GL_FRAME_NV = 0x8E26; ///
enum GL_FRONT = 0x0404; ///
enum GL_FRONT_AND_BACK = 0x0408; ///
enum GL_FRONT_FACE = 0x0B46; ///
enum GL_FRONT_FACE_COMMAND_NV = 0x0012; ///
enum GL_FRONT_LEFT = 0x0400; ///
enum GL_FRONT_RIGHT = 0x0401; ///
enum GL_FULL_RANGE_EXT = 0x87E1; ///
enum GL_FULL_STIPPLE_HINT_PGI = 0x1A219; ///
enum GL_FULL_SUPPORT = 0x82B7; ///
enum GL_FUNC_ADD = 0x8006; ///
enum GL_FUNC_ADD_EXT = 0x8006; ///
enum GL_FUNC_ADD_OES = 0x8006; ///
enum GL_FUNC_REVERSE_SUBTRACT = 0x800B; ///
enum GL_FUNC_REVERSE_SUBTRACT_EXT = 0x800B; ///
enum GL_FUNC_REVERSE_SUBTRACT_OES = 0x800B; ///
enum GL_FUNC_SUBTRACT = 0x800A; ///
enum GL_FUNC_SUBTRACT_EXT = 0x800A; ///
enum GL_FUNC_SUBTRACT_OES = 0x800A; ///
enum GL_GCCSO_SHADER_BINARY_FJ = 0x9260; ///
enum GL_GENERATE_MIPMAP = 0x8191; ///
enum GL_GENERATE_MIPMAP_HINT = 0x8192; ///
enum GL_GENERATE_MIPMAP_HINT_SGIS = 0x8192; ///
enum GL_GENERATE_MIPMAP_SGIS = 0x8191; ///
enum GL_GENERIC_ATTRIB_NV = 0x8C7D; ///
enum GL_GEOMETRY_DEFORMATION_BIT_SGIX = 0x00000002; ///
enum GL_GEOMETRY_DEFORMATION_SGIX = 0x8194; ///
enum GL_GEOMETRY_INPUT_TYPE = 0x8917; ///
enum GL_GEOMETRY_INPUT_TYPE_ARB = 0x8DDB; ///
enum GL_GEOMETRY_INPUT_TYPE_EXT = 0x8DDB; ///
enum GL_GEOMETRY_LINKED_INPUT_TYPE_EXT = 0x8917; ///
enum GL_GEOMETRY_LINKED_INPUT_TYPE_OES = 0x8917; ///
enum GL_GEOMETRY_LINKED_OUTPUT_TYPE_EXT = 0x8918; ///
enum GL_GEOMETRY_LINKED_OUTPUT_TYPE_OES = 0x8918; ///
enum GL_GEOMETRY_LINKED_VERTICES_OUT_EXT = 0x8916; ///
enum GL_GEOMETRY_LINKED_VERTICES_OUT_OES = 0x8916; ///
enum GL_GEOMETRY_OUTPUT_TYPE = 0x8918; ///
enum GL_GEOMETRY_OUTPUT_TYPE_ARB = 0x8DDC; ///
enum GL_GEOMETRY_OUTPUT_TYPE_EXT = 0x8DDC; ///
enum GL_GEOMETRY_PROGRAM_NV = 0x8C26; ///
enum GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA3; ///
enum GL_GEOMETRY_SHADER = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_ARB = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_BIT = 0x00000004; ///
enum GL_GEOMETRY_SHADER_BIT_EXT = 0x00000004; ///
enum GL_GEOMETRY_SHADER_BIT_OES = 0x00000004; ///
enum GL_GEOMETRY_SHADER_EXT = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_INVOCATIONS = 0x887F; ///
enum GL_GEOMETRY_SHADER_INVOCATIONS_EXT = 0x887F; ///
enum GL_GEOMETRY_SHADER_INVOCATIONS_OES = 0x887F; ///
enum GL_GEOMETRY_SHADER_OES = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB = 0x82F3; ///
enum GL_GEOMETRY_SUBROUTINE = 0x92EB; ///
enum GL_GEOMETRY_SUBROUTINE_UNIFORM = 0x92F1; ///
enum GL_GEOMETRY_TEXTURE = 0x829E; ///
enum GL_GEOMETRY_VERTICES_OUT = 0x8916; ///
enum GL_GEOMETRY_VERTICES_OUT_ARB = 0x8DDA; ///
enum GL_GEOMETRY_VERTICES_OUT_EXT = 0x8DDA; ///
enum GL_GEQUAL = 0x0206; ///
enum GL_GET_TEXTURE_IMAGE_FORMAT = 0x8291; ///
enum GL_GET_TEXTURE_IMAGE_TYPE = 0x8292; ///
enum GL_GLOBAL_ALPHA_FACTOR_SUN = 0x81DA; ///
enum GL_GLOBAL_ALPHA_SUN = 0x81D9; ///
enum GL_GLYPH_HAS_KERNING_BIT_NV = 0x100; ///
enum GL_GLYPH_HEIGHT_BIT_NV = 0x02; ///
enum GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV = 0x10; ///
enum GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV = 0x04; ///
enum GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV = 0x08; ///
enum GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV = 0x80; ///
enum GL_GLYPH_VERTICAL_BEARING_X_BIT_NV = 0x20; ///
enum GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV = 0x40; ///
enum GL_GLYPH_WIDTH_BIT_NV = 0x01; ///
enum GL_GPU_ADDRESS_NV = 0x8F34; ///
enum GL_GPU_DISJOINT_EXT = 0x8FBB; ///
enum GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX = 0x9049; ///
enum GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX = 0x9047; ///
enum GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX = 0x904B; ///
enum GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX = 0x904A; ///
enum GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX = 0x9048; ///
enum GL_GPU_OPTIMIZED_QCOM = 0x8FB2; ///
enum GL_GREATER = 0x0204; ///
enum GL_GREEN = 0x1904; ///
enum GL_GREEN_BIAS = 0x0D19; ///
enum GL_GREEN_BITS = 0x0D53; ///
enum GL_GREEN_BIT_ATI = 0x00000002; ///
enum GL_GREEN_INTEGER = 0x8D95; ///
enum GL_GREEN_INTEGER_EXT = 0x8D95; ///
enum GL_GREEN_MAX_CLAMP_INGR = 0x8565; ///
enum GL_GREEN_MIN_CLAMP_INGR = 0x8561; ///
enum GL_GREEN_NV = 0x1904; ///
enum GL_GREEN_SCALE = 0x0D18; ///
enum GL_GS_PROGRAM_BINARY_MTK = 0x9641; ///
enum GL_GS_SHADER_BINARY_MTK = 0x9640; ///
enum GL_GUILTY_CONTEXT_RESET = 0x8253; ///
enum GL_GUILTY_CONTEXT_RESET_ARB = 0x8253; ///
enum GL_GUILTY_CONTEXT_RESET_EXT = 0x8253; ///
enum GL_GUILTY_CONTEXT_RESET_KHR = 0x8253; ///
enum GL_HALF_APPLE = 0x140B; ///
enum GL_HALF_BIAS_NEGATE_NV = 0x853B; ///
enum GL_HALF_BIAS_NORMAL_NV = 0x853A; ///
enum GL_HALF_BIT_ATI = 0x00000008; ///
enum GL_HALF_FLOAT = 0x140B; ///
enum GL_HALF_FLOAT_ARB = 0x140B; ///
enum GL_HALF_FLOAT_NV = 0x140B; ///
enum GL_HALF_FLOAT_OES = 0x8D61; ///
enum GL_HARDLIGHT = 0x929B; ///
enum GL_HARDLIGHT_KHR = 0x929B; ///
enum GL_HARDLIGHT_NV = 0x929B; ///
enum GL_HARDMIX_NV = 0x92A9; ///
enum GL_HIGH_FLOAT = 0x8DF2; ///
enum GL_HIGH_INT = 0x8DF5; ///
enum GL_HILO16_NV = 0x86F8; ///
enum GL_HILO8_NV = 0x885E; ///
enum GL_HILO_NV = 0x86F4; ///
enum GL_HINT_BIT = 0x00008000; ///
enum GL_HISTOGRAM = 0x8024; ///
enum GL_HISTOGRAM_ALPHA_SIZE = 0x802B; ///
enum GL_HISTOGRAM_ALPHA_SIZE_EXT = 0x802B; ///
enum GL_HISTOGRAM_BLUE_SIZE = 0x802A; ///
enum GL_HISTOGRAM_BLUE_SIZE_EXT = 0x802A; ///
enum GL_HISTOGRAM_EXT = 0x8024; ///
enum GL_HISTOGRAM_FORMAT = 0x8027; ///
enum GL_HISTOGRAM_FORMAT_EXT = 0x8027; ///
enum GL_HISTOGRAM_GREEN_SIZE = 0x8029; ///
enum GL_HISTOGRAM_GREEN_SIZE_EXT = 0x8029; ///
enum GL_HISTOGRAM_LUMINANCE_SIZE = 0x802C; ///
enum GL_HISTOGRAM_LUMINANCE_SIZE_EXT = 0x802C; ///
enum GL_HISTOGRAM_RED_SIZE = 0x8028; ///
enum GL_HISTOGRAM_RED_SIZE_EXT = 0x8028; ///
enum GL_HISTOGRAM_SINK = 0x802D; ///
enum GL_HISTOGRAM_SINK_EXT = 0x802D; ///
enum GL_HISTOGRAM_WIDTH = 0x8026; ///
enum GL_HISTOGRAM_WIDTH_EXT = 0x8026; ///
enum GL_HI_BIAS_NV = 0x8714; ///
enum GL_HI_SCALE_NV = 0x870E; ///
enum GL_HORIZONTAL_LINE_TO_NV = 0x06; ///
enum GL_HSL_COLOR = 0x92AF; ///
enum GL_HSL_COLOR_KHR = 0x92AF; ///
enum GL_HSL_COLOR_NV = 0x92AF; ///
enum GL_HSL_HUE = 0x92AD; ///
enum GL_HSL_HUE_KHR = 0x92AD; ///
enum GL_HSL_HUE_NV = 0x92AD; ///
enum GL_HSL_LUMINOSITY = 0x92B0; ///
enum GL_HSL_LUMINOSITY_KHR = 0x92B0; ///
enum GL_HSL_LUMINOSITY_NV = 0x92B0; ///
enum GL_HSL_SATURATION = 0x92AE; ///
enum GL_HSL_SATURATION_KHR = 0x92AE; ///
enum GL_HSL_SATURATION_NV = 0x92AE; ///
enum GL_IDENTITY_NV = 0x862A; ///
enum GL_IGNORE_BORDER_HP = 0x8150; ///
enum GL_IMAGE_1D = 0x904C; ///
enum GL_IMAGE_1D_ARRAY = 0x9052; ///
enum GL_IMAGE_1D_ARRAY_EXT = 0x9052; ///
enum GL_IMAGE_1D_EXT = 0x904C; ///
enum GL_IMAGE_2D = 0x904D; ///
enum GL_IMAGE_2D_ARRAY = 0x9053; ///
enum GL_IMAGE_2D_ARRAY_EXT = 0x9053; ///
enum GL_IMAGE_2D_EXT = 0x904D; ///
enum GL_IMAGE_2D_MULTISAMPLE = 0x9055; ///
enum GL_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9056; ///
enum GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x9056; ///
enum GL_IMAGE_2D_MULTISAMPLE_EXT = 0x9055; ///
enum GL_IMAGE_2D_RECT = 0x904F; ///
enum GL_IMAGE_2D_RECT_EXT = 0x904F; ///
enum GL_IMAGE_3D = 0x904E; ///
enum GL_IMAGE_3D_EXT = 0x904E; ///
enum GL_IMAGE_BINDING_ACCESS = 0x8F3E; ///
enum GL_IMAGE_BINDING_ACCESS_EXT = 0x8F3E; ///
enum GL_IMAGE_BINDING_FORMAT = 0x906E; ///
enum GL_IMAGE_BINDING_FORMAT_EXT = 0x906E; ///
enum GL_IMAGE_BINDING_LAYER = 0x8F3D; ///
enum GL_IMAGE_BINDING_LAYERED = 0x8F3C; ///
enum GL_IMAGE_BINDING_LAYERED_EXT = 0x8F3C; ///
enum GL_IMAGE_BINDING_LAYER_EXT = 0x8F3D; ///
enum GL_IMAGE_BINDING_LEVEL = 0x8F3B; ///
enum GL_IMAGE_BINDING_LEVEL_EXT = 0x8F3B; ///
enum GL_IMAGE_BINDING_NAME = 0x8F3A; ///
enum GL_IMAGE_BINDING_NAME_EXT = 0x8F3A; ///
enum GL_IMAGE_BUFFER = 0x9051; ///
enum GL_IMAGE_BUFFER_EXT = 0x9051; ///
enum GL_IMAGE_BUFFER_OES = 0x9051; ///
enum GL_IMAGE_CLASS_10_10_10_2 = 0x82C3; ///
enum GL_IMAGE_CLASS_11_11_10 = 0x82C2; ///
enum GL_IMAGE_CLASS_1_X_16 = 0x82BE; ///
enum GL_IMAGE_CLASS_1_X_32 = 0x82BB; ///
enum GL_IMAGE_CLASS_1_X_8 = 0x82C1; ///
enum GL_IMAGE_CLASS_2_X_16 = 0x82BD; ///
enum GL_IMAGE_CLASS_2_X_32 = 0x82BA; ///
enum GL_IMAGE_CLASS_2_X_8 = 0x82C0; ///
enum GL_IMAGE_CLASS_4_X_16 = 0x82BC; ///
enum GL_IMAGE_CLASS_4_X_32 = 0x82B9; ///
enum GL_IMAGE_CLASS_4_X_8 = 0x82BF; ///
enum GL_IMAGE_COMPATIBILITY_CLASS = 0x82A8; ///
enum GL_IMAGE_CUBE = 0x9050; ///
enum GL_IMAGE_CUBE_EXT = 0x9050; ///
enum GL_IMAGE_CUBE_MAP_ARRAY = 0x9054; ///
enum GL_IMAGE_CUBE_MAP_ARRAY_EXT = 0x9054; ///
enum GL_IMAGE_CUBE_MAP_ARRAY_OES = 0x9054; ///
enum GL_IMAGE_CUBIC_WEIGHT_HP = 0x815E; ///
enum GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9; ///
enum GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8; ///
enum GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7; ///
enum GL_IMAGE_MAG_FILTER_HP = 0x815C; ///
enum GL_IMAGE_MIN_FILTER_HP = 0x815D; ///
enum GL_IMAGE_PIXEL_FORMAT = 0x82A9; ///
enum GL_IMAGE_PIXEL_TYPE = 0x82AA; ///
enum GL_IMAGE_ROTATE_ANGLE_HP = 0x8159; ///
enum GL_IMAGE_ROTATE_ORIGIN_X_HP = 0x815A; ///
enum GL_IMAGE_ROTATE_ORIGIN_Y_HP = 0x815B; ///
enum GL_IMAGE_SCALE_X_HP = 0x8155; ///
enum GL_IMAGE_SCALE_Y_HP = 0x8156; ///
enum GL_IMAGE_TEXEL_SIZE = 0x82A7; ///
enum GL_IMAGE_TRANSFORM_2D_HP = 0x8161; ///
enum GL_IMAGE_TRANSLATE_X_HP = 0x8157; ///
enum GL_IMAGE_TRANSLATE_Y_HP = 0x8158; ///
enum GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B; ///
enum GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES = 0x8B9B; ///
enum GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A; ///
enum GL_IMPLEMENTATION_COLOR_READ_TYPE_OES = 0x8B9A; ///
enum GL_INCLUSIVE_EXT = 0x8F10; ///
enum GL_INCR = 0x1E02; ///
enum GL_INCR_WRAP = 0x8507; ///
enum GL_INCR_WRAP_EXT = 0x8507; ///
enum GL_INCR_WRAP_OES = 0x8507; ///
enum GL_INDEX = 0x8222; ///
enum GL_INDEX_ARRAY = 0x8077; ///
enum GL_INDEX_ARRAY_ADDRESS_NV = 0x8F24; ///
enum GL_INDEX_ARRAY_BUFFER_BINDING = 0x8899; ///
enum GL_INDEX_ARRAY_BUFFER_BINDING_ARB = 0x8899; ///
enum GL_INDEX_ARRAY_COUNT_EXT = 0x8087; ///
enum GL_INDEX_ARRAY_EXT = 0x8077; ///
enum GL_INDEX_ARRAY_LENGTH_NV = 0x8F2E; ///
enum GL_INDEX_ARRAY_LIST_IBM = 0x103073; ///
enum GL_INDEX_ARRAY_LIST_STRIDE_IBM = 0x103083; ///
enum GL_INDEX_ARRAY_POINTER = 0x8091; ///
enum GL_INDEX_ARRAY_POINTER_EXT = 0x8091; ///
enum GL_INDEX_ARRAY_STRIDE = 0x8086; ///
enum GL_INDEX_ARRAY_STRIDE_EXT = 0x8086; ///
enum GL_INDEX_ARRAY_TYPE = 0x8085; ///
enum GL_INDEX_ARRAY_TYPE_EXT = 0x8085; ///
enum GL_INDEX_BITS = 0x0D51; ///
enum GL_INDEX_BIT_PGI = 0x00080000; ///
enum GL_INDEX_CLEAR_VALUE = 0x0C20; ///
enum GL_INDEX_LOGIC_OP = 0x0BF1; ///
enum GL_INDEX_MATERIAL_EXT = 0x81B8; ///
enum GL_INDEX_MATERIAL_FACE_EXT = 0x81BA; ///
enum GL_INDEX_MATERIAL_PARAMETER_EXT = 0x81B9; ///
enum GL_INDEX_MODE = 0x0C30; ///
enum GL_INDEX_OFFSET = 0x0D13; ///
enum GL_INDEX_SHIFT = 0x0D12; ///
enum GL_INDEX_TEST_EXT = 0x81B5; ///
enum GL_INDEX_TEST_FUNC_EXT = 0x81B6; ///
enum GL_INDEX_TEST_REF_EXT = 0x81B7; ///
enum GL_INDEX_WRITEMASK = 0x0C21; ///
enum GL_INFO_LOG_LENGTH = 0x8B84; ///
enum GL_INNOCENT_CONTEXT_RESET = 0x8254; ///
enum GL_INNOCENT_CONTEXT_RESET_ARB = 0x8254; ///
enum GL_INNOCENT_CONTEXT_RESET_EXT = 0x8254; ///
enum GL_INNOCENT_CONTEXT_RESET_KHR = 0x8254; ///
enum GL_INSTRUMENT_BUFFER_POINTER_SGIX = 0x8180; ///
enum GL_INSTRUMENT_MEASUREMENTS_SGIX = 0x8181; ///
enum GL_INT = 0x1404; ///
enum GL_INT16_NV = 0x8FE4; ///
enum GL_INT16_VEC2_NV = 0x8FE5; ///
enum GL_INT16_VEC3_NV = 0x8FE6; ///
enum GL_INT16_VEC4_NV = 0x8FE7; ///
enum GL_INT64_ARB = 0x140E; ///
enum GL_INT64_NV = 0x140E; ///
enum GL_INT64_VEC2_ARB = 0x8FE9; ///
enum GL_INT64_VEC2_NV = 0x8FE9; ///
enum GL_INT64_VEC3_ARB = 0x8FEA; ///
enum GL_INT64_VEC3_NV = 0x8FEA; ///
enum GL_INT64_VEC4_ARB = 0x8FEB; ///
enum GL_INT64_VEC4_NV = 0x8FEB; ///
enum GL_INT8_NV = 0x8FE0; ///
enum GL_INT8_VEC2_NV = 0x8FE1; ///
enum GL_INT8_VEC3_NV = 0x8FE2; ///
enum GL_INT8_VEC4_NV = 0x8FE3; ///
enum GL_INTENSITY = 0x8049; ///
enum GL_INTENSITY12 = 0x804C; ///
enum GL_INTENSITY12_EXT = 0x804C; ///
enum GL_INTENSITY16 = 0x804D; ///
enum GL_INTENSITY16F_ARB = 0x881D; ///
enum GL_INTENSITY16I_EXT = 0x8D8B; ///
enum GL_INTENSITY16UI_EXT = 0x8D79; ///
enum GL_INTENSITY16_EXT = 0x804D; ///
enum GL_INTENSITY16_SNORM = 0x901B; ///
enum GL_INTENSITY32F_ARB = 0x8817; ///
enum GL_INTENSITY32I_EXT = 0x8D85; ///
enum GL_INTENSITY32UI_EXT = 0x8D73; ///
enum GL_INTENSITY4 = 0x804A; ///
enum GL_INTENSITY4_EXT = 0x804A; ///
enum GL_INTENSITY8 = 0x804B; ///
enum GL_INTENSITY8I_EXT = 0x8D91; ///
enum GL_INTENSITY8UI_EXT = 0x8D7F; ///
enum GL_INTENSITY8_EXT = 0x804B; ///
enum GL_INTENSITY8_SNORM = 0x9017; ///
enum GL_INTENSITY_EXT = 0x8049; ///
enum GL_INTENSITY_FLOAT16_APPLE = 0x881D; ///
enum GL_INTENSITY_FLOAT16_ATI = 0x881D; ///
enum GL_INTENSITY_FLOAT32_APPLE = 0x8817; ///
enum GL_INTENSITY_FLOAT32_ATI = 0x8817; ///
enum GL_INTENSITY_SNORM = 0x9013; ///
enum GL_INTERLACE_OML = 0x8980; ///
enum GL_INTERLACE_READ_INGR = 0x8568; ///
enum GL_INTERLACE_READ_OML = 0x8981; ///
enum GL_INTERLACE_SGIX = 0x8094; ///
enum GL_INTERLEAVED_ATTRIBS = 0x8C8C; ///
enum GL_INTERLEAVED_ATTRIBS_EXT = 0x8C8C; ///
enum GL_INTERLEAVED_ATTRIBS_NV = 0x8C8C; ///
enum GL_INTERNALFORMAT_ALPHA_SIZE = 0x8274; ///
enum GL_INTERNALFORMAT_ALPHA_TYPE = 0x827B; ///
enum GL_INTERNALFORMAT_BLUE_SIZE = 0x8273; ///
enum GL_INTERNALFORMAT_BLUE_TYPE = 0x827A; ///
enum GL_INTERNALFORMAT_DEPTH_SIZE = 0x8275; ///
enum GL_INTERNALFORMAT_DEPTH_TYPE = 0x827C; ///
enum GL_INTERNALFORMAT_GREEN_SIZE = 0x8272; ///
enum GL_INTERNALFORMAT_GREEN_TYPE = 0x8279; ///
enum GL_INTERNALFORMAT_PREFERRED = 0x8270; ///
enum GL_INTERNALFORMAT_RED_SIZE = 0x8271; ///
enum GL_INTERNALFORMAT_RED_TYPE = 0x8278; ///
enum GL_INTERNALFORMAT_SHARED_SIZE = 0x8277; ///
enum GL_INTERNALFORMAT_STENCIL_SIZE = 0x8276; ///
enum GL_INTERNALFORMAT_STENCIL_TYPE = 0x827D; ///
enum GL_INTERNALFORMAT_SUPPORTED = 0x826F; ///
enum GL_INTERPOLATE = 0x8575; ///
enum GL_INTERPOLATE_ARB = 0x8575; ///
enum GL_INTERPOLATE_EXT = 0x8575; ///
enum GL_INT_10_10_10_2_OES = 0x8DF7; ///
enum GL_INT_2_10_10_10_REV = 0x8D9F; ///
enum GL_INT_IMAGE_1D = 0x9057; ///
enum GL_INT_IMAGE_1D_ARRAY = 0x905D; ///
enum GL_INT_IMAGE_1D_ARRAY_EXT = 0x905D; ///
enum GL_INT_IMAGE_1D_EXT = 0x9057; ///
enum GL_INT_IMAGE_2D = 0x9058; ///
enum GL_INT_IMAGE_2D_ARRAY = 0x905E; ///
enum GL_INT_IMAGE_2D_ARRAY_EXT = 0x905E; ///
enum GL_INT_IMAGE_2D_EXT = 0x9058; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE = 0x9060; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x9061; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE_EXT = 0x9060; ///
enum GL_INT_IMAGE_2D_RECT = 0x905A; ///
enum GL_INT_IMAGE_2D_RECT_EXT = 0x905A; ///
enum GL_INT_IMAGE_3D = 0x9059; ///
enum GL_INT_IMAGE_3D_EXT = 0x9059; ///
enum GL_INT_IMAGE_BUFFER = 0x905C; ///
enum GL_INT_IMAGE_BUFFER_EXT = 0x905C; ///
enum GL_INT_IMAGE_BUFFER_OES = 0x905C; ///
enum GL_INT_IMAGE_CUBE = 0x905B; ///
enum GL_INT_IMAGE_CUBE_EXT = 0x905B; ///
enum GL_INT_IMAGE_CUBE_MAP_ARRAY = 0x905F; ///
enum GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x905F; ///
enum GL_INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x905F; ///
enum GL_INT_SAMPLER_1D = 0x8DC9; ///
enum GL_INT_SAMPLER_1D_ARRAY = 0x8DCE; ///
enum GL_INT_SAMPLER_1D_ARRAY_EXT = 0x8DCE; ///
enum GL_INT_SAMPLER_1D_EXT = 0x8DC9; ///
enum GL_INT_SAMPLER_2D = 0x8DCA; ///
enum GL_INT_SAMPLER_2D_ARRAY = 0x8DCF; ///
enum GL_INT_SAMPLER_2D_ARRAY_EXT = 0x8DCF; ///
enum GL_INT_SAMPLER_2D_EXT = 0x8DCA; ///
enum GL_INT_SAMPLER_2D_MULTISAMPLE = 0x9109; ///
enum GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C; ///
enum GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910C; ///
enum GL_INT_SAMPLER_2D_RECT = 0x8DCD; ///
enum GL_INT_SAMPLER_2D_RECT_EXT = 0x8DCD; ///
enum GL_INT_SAMPLER_3D = 0x8DCB; ///
enum GL_INT_SAMPLER_3D_EXT = 0x8DCB; ///
enum GL_INT_SAMPLER_BUFFER = 0x8DD0; ///
enum GL_INT_SAMPLER_BUFFER_AMD = 0x9002; ///
enum GL_INT_SAMPLER_BUFFER_EXT = 0x8DD0; ///
enum GL_INT_SAMPLER_BUFFER_OES = 0x8DD0; ///
enum GL_INT_SAMPLER_CUBE = 0x8DCC; ///
enum GL_INT_SAMPLER_CUBE_EXT = 0x8DCC; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900E; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900E; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900E; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900E; ///
enum GL_INT_SAMPLER_RENDERBUFFER_NV = 0x8E57; ///
enum GL_INT_VEC2 = 0x8B53; ///
enum GL_INT_VEC2_ARB = 0x8B53; ///
enum GL_INT_VEC3 = 0x8B54; ///
enum GL_INT_VEC3_ARB = 0x8B54; ///
enum GL_INT_VEC4 = 0x8B55; ///
enum GL_INT_VEC4_ARB = 0x8B55; ///
enum GL_INVALID_ENUM = 0x0500; ///
enum GL_INVALID_FRAMEBUFFER_OPERATION = 0x0506; ///
enum GL_INVALID_FRAMEBUFFER_OPERATION_EXT = 0x0506; ///
enum GL_INVALID_FRAMEBUFFER_OPERATION_OES = 0x0506; ///
enum GL_INVALID_INDEX = 0xFFFFFFFF; ///
enum GL_INVALID_OPERATION = 0x0502; ///
enum GL_INVALID_VALUE = 0x0501; ///
enum GL_INVARIANT_DATATYPE_EXT = 0x87EB; ///
enum GL_INVARIANT_EXT = 0x87C2; ///
enum GL_INVARIANT_VALUE_EXT = 0x87EA; ///
enum GL_INVERSE_NV = 0x862B; ///
enum GL_INVERSE_TRANSPOSE_NV = 0x862D; ///
enum GL_INVERT = 0x150A; ///
enum GL_INVERTED_SCREEN_W_REND = 0x8491; ///
enum GL_INVERT_OVG_NV = 0x92B4; ///
enum GL_INVERT_RGB_NV = 0x92A3; ///
enum GL_IR_INSTRUMENT1_SGIX = 0x817F; ///
enum GL_ISOLINES = 0x8E7A; ///
enum GL_ISOLINES_EXT = 0x8E7A; ///
enum GL_ISOLINES_OES = 0x8E7A; ///
enum GL_IS_PER_PATCH = 0x92E7; ///
enum GL_IS_PER_PATCH_EXT = 0x92E7; ///
enum GL_IS_PER_PATCH_OES = 0x92E7; ///
enum GL_IS_ROW_MAJOR = 0x9300; ///
enum GL_ITALIC_BIT_NV = 0x02; ///
enum GL_IUI_N3F_V2F_EXT = 0x81AF; ///
enum GL_IUI_N3F_V3F_EXT = 0x81B0; ///
enum GL_IUI_V2F_EXT = 0x81AD; ///
enum GL_IUI_V3F_EXT = 0x81AE; ///
enum GL_KEEP = 0x1E00; ///
enum GL_LARGE_CCW_ARC_TO_NV = 0x16; ///
enum GL_LARGE_CW_ARC_TO_NV = 0x18; ///
enum GL_LAST_VERTEX_CONVENTION = 0x8E4E; ///
enum GL_LAST_VERTEX_CONVENTION_EXT = 0x8E4E; ///
enum GL_LAST_VERTEX_CONVENTION_OES = 0x8E4E; ///
enum GL_LAST_VIDEO_CAPTURE_STATUS_NV = 0x9027; ///
enum GL_LAYER_NV = 0x8DAA; ///
enum GL_LAYER_PROVOKING_VERTEX = 0x825E; ///
enum GL_LAYER_PROVOKING_VERTEX_EXT = 0x825E; ///
enum GL_LAYER_PROVOKING_VERTEX_OES = 0x825E; ///
enum GL_LAYOUT_DEFAULT_INTEL = 0; ///
enum GL_LAYOUT_LINEAR_CPU_CACHED_INTEL = 2; ///
enum GL_LAYOUT_LINEAR_INTEL = 1; ///
enum GL_LEFT = 0x0406; ///
enum GL_LEQUAL = 0x0203; ///
enum GL_LERP_ATI = 0x8969; ///
enum GL_LESS = 0x0201; ///
enum GL_LIGHT0 = 0x4000; ///
enum GL_LIGHT1 = 0x4001; ///
enum GL_LIGHT2 = 0x4002; ///
enum GL_LIGHT3 = 0x4003; ///
enum GL_LIGHT4 = 0x4004; ///
enum GL_LIGHT5 = 0x4005; ///
enum GL_LIGHT6 = 0x4006; ///
enum GL_LIGHT7 = 0x4007; ///
enum GL_LIGHTEN = 0x9298; ///
enum GL_LIGHTEN_KHR = 0x9298; ///
enum GL_LIGHTEN_NV = 0x9298; ///
enum GL_LIGHTING = 0x0B50; ///
enum GL_LIGHTING_BIT = 0x00000040; ///
enum GL_LIGHT_ENV_MODE_SGIX = 0x8407; ///
enum GL_LIGHT_MODEL_AMBIENT = 0x0B53; ///
enum GL_LIGHT_MODEL_COLOR_CONTROL = 0x81F8; ///
enum GL_LIGHT_MODEL_COLOR_CONTROL_EXT = 0x81F8; ///
enum GL_LIGHT_MODEL_LOCAL_VIEWER = 0x0B51; ///
enum GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE = 0x85B0; ///
enum GL_LIGHT_MODEL_TWO_SIDE = 0x0B52; ///
enum GL_LINE = 0x1B01; ///
enum GL_LINEAR = 0x2601; ///
enum GL_LINEARBURN_NV = 0x92A5; ///
enum GL_LINEARDODGE_NV = 0x92A4; ///
enum GL_LINEARLIGHT_NV = 0x92A7; ///
enum GL_LINEAR_ATTENUATION = 0x1208; ///
enum GL_LINEAR_CLIPMAP_LINEAR_SGIX = 0x8170; ///
enum GL_LINEAR_CLIPMAP_NEAREST_SGIX = 0x844F; ///
enum GL_LINEAR_DETAIL_ALPHA_SGIS = 0x8098; ///
enum GL_LINEAR_DETAIL_COLOR_SGIS = 0x8099; ///
enum GL_LINEAR_DETAIL_SGIS = 0x8097; ///
enum GL_LINEAR_MIPMAP_LINEAR = 0x2703; ///
enum GL_LINEAR_MIPMAP_NEAREST = 0x2701; ///
enum GL_LINEAR_SHARPEN_ALPHA_SGIS = 0x80AE; ///
enum GL_LINEAR_SHARPEN_COLOR_SGIS = 0x80AF; ///
enum GL_LINEAR_SHARPEN_SGIS = 0x80AD; ///
enum GL_LINES = 0x0001; ///
enum GL_LINES_ADJACENCY = 0x000A; ///
enum GL_LINES_ADJACENCY_ARB = 0x000A; ///
enum GL_LINES_ADJACENCY_EXT = 0x000A; ///
enum GL_LINES_ADJACENCY_OES = 0x000A; ///
enum GL_LINE_BIT = 0x00000004; ///
enum GL_LINE_LOOP = 0x0002; ///
enum GL_LINE_NV = 0x1B01; ///
enum GL_LINE_QUALITY_HINT_SGIX = 0x835B; ///
enum GL_LINE_RESET_TOKEN = 0x0707; ///
enum GL_LINE_SMOOTH = 0x0B20; ///
enum GL_LINE_SMOOTH_HINT = 0x0C52; ///
enum GL_LINE_STIPPLE = 0x0B24; ///
enum GL_LINE_STIPPLE_PATTERN = 0x0B25; ///
enum GL_LINE_STIPPLE_REPEAT = 0x0B26; ///
enum GL_LINE_STRIP = 0x0003; ///
enum GL_LINE_STRIP_ADJACENCY = 0x000B; ///
enum GL_LINE_STRIP_ADJACENCY_ARB = 0x000B; ///
enum GL_LINE_STRIP_ADJACENCY_EXT = 0x000B; ///
enum GL_LINE_STRIP_ADJACENCY_OES = 0x000B; ///
enum GL_LINE_TOKEN = 0x0702; ///
enum GL_LINE_TO_NV = 0x04; ///
enum GL_LINE_WIDTH = 0x0B21; ///
enum GL_LINE_WIDTH_COMMAND_NV = 0x000D; ///
enum GL_LINE_WIDTH_GRANULARITY = 0x0B23; ///
enum GL_LINE_WIDTH_RANGE = 0x0B22; ///
enum GL_LINK_STATUS = 0x8B82; ///
enum GL_LIST_BASE = 0x0B32; ///
enum GL_LIST_BIT = 0x00020000; ///
enum GL_LIST_INDEX = 0x0B33; ///
enum GL_LIST_MODE = 0x0B30; ///
enum GL_LIST_PRIORITY_SGIX = 0x8182; ///
enum GL_LOAD = 0x0101; ///
enum GL_LOCAL_CONSTANT_DATATYPE_EXT = 0x87ED; ///
enum GL_LOCAL_CONSTANT_EXT = 0x87C3; ///
enum GL_LOCAL_CONSTANT_VALUE_EXT = 0x87EC; ///
enum GL_LOCAL_EXT = 0x87C4; ///
enum GL_LOCATION = 0x930E; ///
enum GL_LOCATION_COMPONENT = 0x934A; ///
enum GL_LOCATION_INDEX = 0x930F; ///
enum GL_LOCATION_INDEX_EXT = 0x930F; ///
enum GL_LOGIC_OP = 0x0BF1; ///
enum GL_LOGIC_OP_MODE = 0x0BF0; ///
enum GL_LOSE_CONTEXT_ON_RESET = 0x8252; ///
enum GL_LOSE_CONTEXT_ON_RESET_ARB = 0x8252; ///
enum GL_LOSE_CONTEXT_ON_RESET_EXT = 0x8252; ///
enum GL_LOSE_CONTEXT_ON_RESET_KHR = 0x8252; ///
enum GL_LOWER_LEFT = 0x8CA1; ///
enum GL_LOW_FLOAT = 0x8DF0; ///
enum GL_LOW_INT = 0x8DF3; ///
enum GL_LO_BIAS_NV = 0x8715; ///
enum GL_LO_SCALE_NV = 0x870F; ///
enum GL_LUMINANCE = 0x1909; ///
enum GL_LUMINANCE12 = 0x8041; ///
enum GL_LUMINANCE12_ALPHA12 = 0x8047; ///
enum GL_LUMINANCE12_ALPHA12_EXT = 0x8047; ///
enum GL_LUMINANCE12_ALPHA4 = 0x8046; ///
enum GL_LUMINANCE12_ALPHA4_EXT = 0x8046; ///
enum GL_LUMINANCE12_EXT = 0x8041; ///
enum GL_LUMINANCE16 = 0x8042; ///
enum GL_LUMINANCE16F_ARB = 0x881E; ///
enum GL_LUMINANCE16F_EXT = 0x881E; ///
enum GL_LUMINANCE16I_EXT = 0x8D8C; ///
enum GL_LUMINANCE16UI_EXT = 0x8D7A; ///
enum GL_LUMINANCE16_ALPHA16 = 0x8048; ///
enum GL_LUMINANCE16_ALPHA16_EXT = 0x8048; ///
enum GL_LUMINANCE16_ALPHA16_SNORM = 0x901A; ///
enum GL_LUMINANCE16_EXT = 0x8042; ///
enum GL_LUMINANCE16_SNORM = 0x9019; ///
enum GL_LUMINANCE32F_ARB = 0x8818; ///
enum GL_LUMINANCE32F_EXT = 0x8818; ///
enum GL_LUMINANCE32I_EXT = 0x8D86; ///
enum GL_LUMINANCE32UI_EXT = 0x8D74; ///
enum GL_LUMINANCE4 = 0x803F; ///
enum GL_LUMINANCE4_ALPHA4 = 0x8043; ///
enum GL_LUMINANCE4_ALPHA4_EXT = 0x8043; ///
enum GL_LUMINANCE4_ALPHA4_OES = 0x8043; ///
enum GL_LUMINANCE4_EXT = 0x803F; ///
enum GL_LUMINANCE6_ALPHA2 = 0x8044; ///
enum GL_LUMINANCE6_ALPHA2_EXT = 0x8044; ///
enum GL_LUMINANCE8 = 0x8040; ///
enum GL_LUMINANCE8I_EXT = 0x8D92; ///
enum GL_LUMINANCE8UI_EXT = 0x8D80; ///
enum GL_LUMINANCE8_ALPHA8 = 0x8045; ///
enum GL_LUMINANCE8_ALPHA8_EXT = 0x8045; ///
enum GL_LUMINANCE8_ALPHA8_OES = 0x8045; ///
enum GL_LUMINANCE8_ALPHA8_SNORM = 0x9016; ///
enum GL_LUMINANCE8_EXT = 0x8040; ///
enum GL_LUMINANCE8_OES = 0x8040; ///
enum GL_LUMINANCE8_SNORM = 0x9015; ///
enum GL_LUMINANCE_ALPHA = 0x190A; ///
enum GL_LUMINANCE_ALPHA16F_ARB = 0x881F; ///
enum GL_LUMINANCE_ALPHA16F_EXT = 0x881F; ///
enum GL_LUMINANCE_ALPHA16I_EXT = 0x8D8D; ///
enum GL_LUMINANCE_ALPHA16UI_EXT = 0x8D7B; ///
enum GL_LUMINANCE_ALPHA32F_ARB = 0x8819; ///
enum GL_LUMINANCE_ALPHA32F_EXT = 0x8819; ///
enum GL_LUMINANCE_ALPHA32I_EXT = 0x8D87; ///
enum GL_LUMINANCE_ALPHA32UI_EXT = 0x8D75; ///
enum GL_LUMINANCE_ALPHA8I_EXT = 0x8D93; ///
enum GL_LUMINANCE_ALPHA8UI_EXT = 0x8D81; ///
enum GL_LUMINANCE_ALPHA_FLOAT16_APPLE = 0x881F; ///
enum GL_LUMINANCE_ALPHA_FLOAT16_ATI = 0x881F; ///
enum GL_LUMINANCE_ALPHA_FLOAT32_APPLE = 0x8819; ///
enum GL_LUMINANCE_ALPHA_FLOAT32_ATI = 0x8819; ///
enum GL_LUMINANCE_ALPHA_INTEGER_EXT = 0x8D9D; ///
enum GL_LUMINANCE_ALPHA_SNORM = 0x9012; ///
enum GL_LUMINANCE_FLOAT16_APPLE = 0x881E; ///
enum GL_LUMINANCE_FLOAT16_ATI = 0x881E; ///
enum GL_LUMINANCE_FLOAT32_APPLE = 0x8818; ///
enum GL_LUMINANCE_FLOAT32_ATI = 0x8818; ///
enum GL_LUMINANCE_INTEGER_EXT = 0x8D9C; ///
enum GL_LUMINANCE_SNORM = 0x9011; ///
enum GL_MAD_ATI = 0x8968; ///
enum GL_MAGNITUDE_BIAS_NV = 0x8718; ///
enum GL_MAGNITUDE_SCALE_NV = 0x8712; ///
enum GL_MAJOR_VERSION = 0x821B; ///
enum GL_MALI_PROGRAM_BINARY_ARM = 0x8F61; ///
enum GL_MALI_SHADER_BINARY_ARM = 0x8F60; ///
enum GL_MANUAL_GENERATE_MIPMAP = 0x8294; ///
enum GL_MAP1_BINORMAL_EXT = 0x8446; ///
enum GL_MAP1_COLOR_4 = 0x0D90; ///
enum GL_MAP1_GRID_DOMAIN = 0x0DD0; ///
enum GL_MAP1_GRID_SEGMENTS = 0x0DD1; ///
enum GL_MAP1_INDEX = 0x0D91; ///
enum GL_MAP1_NORMAL = 0x0D92; ///
enum GL_MAP1_TANGENT_EXT = 0x8444; ///
enum GL_MAP1_TEXTURE_COORD_1 = 0x0D93; ///
enum GL_MAP1_TEXTURE_COORD_2 = 0x0D94; ///
enum GL_MAP1_TEXTURE_COORD_3 = 0x0D95; ///
enum GL_MAP1_TEXTURE_COORD_4 = 0x0D96; ///
enum GL_MAP1_VERTEX_3 = 0x0D97; ///
enum GL_MAP1_VERTEX_4 = 0x0D98; ///
enum GL_MAP1_VERTEX_ATTRIB0_4_NV = 0x8660; ///
enum GL_MAP1_VERTEX_ATTRIB10_4_NV = 0x866A; ///
enum GL_MAP1_VERTEX_ATTRIB11_4_NV = 0x866B; ///
enum GL_MAP1_VERTEX_ATTRIB12_4_NV = 0x866C; ///
enum GL_MAP1_VERTEX_ATTRIB13_4_NV = 0x866D; ///
enum GL_MAP1_VERTEX_ATTRIB14_4_NV = 0x866E; ///
enum GL_MAP1_VERTEX_ATTRIB15_4_NV = 0x866F; ///
enum GL_MAP1_VERTEX_ATTRIB1_4_NV = 0x8661; ///
enum GL_MAP1_VERTEX_ATTRIB2_4_NV = 0x8662; ///
enum GL_MAP1_VERTEX_ATTRIB3_4_NV = 0x8663; ///
enum GL_MAP1_VERTEX_ATTRIB4_4_NV = 0x8664; ///
enum GL_MAP1_VERTEX_ATTRIB5_4_NV = 0x8665; ///
enum GL_MAP1_VERTEX_ATTRIB6_4_NV = 0x8666; ///
enum GL_MAP1_VERTEX_ATTRIB7_4_NV = 0x8667; ///
enum GL_MAP1_VERTEX_ATTRIB8_4_NV = 0x8668; ///
enum GL_MAP1_VERTEX_ATTRIB9_4_NV = 0x8669; ///
enum GL_MAP2_BINORMAL_EXT = 0x8447; ///
enum GL_MAP2_COLOR_4 = 0x0DB0; ///
enum GL_MAP2_GRID_DOMAIN = 0x0DD2; ///
enum GL_MAP2_GRID_SEGMENTS = 0x0DD3; ///
enum GL_MAP2_INDEX = 0x0DB1; ///
enum GL_MAP2_NORMAL = 0x0DB2; ///
enum GL_MAP2_TANGENT_EXT = 0x8445; ///
enum GL_MAP2_TEXTURE_COORD_1 = 0x0DB3; ///
enum GL_MAP2_TEXTURE_COORD_2 = 0x0DB4; ///
enum GL_MAP2_TEXTURE_COORD_3 = 0x0DB5; ///
enum GL_MAP2_TEXTURE_COORD_4 = 0x0DB6; ///
enum GL_MAP2_VERTEX_3 = 0x0DB7; ///
enum GL_MAP2_VERTEX_4 = 0x0DB8; ///
enum GL_MAP2_VERTEX_ATTRIB0_4_NV = 0x8670; ///
enum GL_MAP2_VERTEX_ATTRIB10_4_NV = 0x867A; ///
enum GL_MAP2_VERTEX_ATTRIB11_4_NV = 0x867B; ///
enum GL_MAP2_VERTEX_ATTRIB12_4_NV = 0x867C; ///
enum GL_MAP2_VERTEX_ATTRIB13_4_NV = 0x867D; ///
enum GL_MAP2_VERTEX_ATTRIB14_4_NV = 0x867E; ///
enum GL_MAP2_VERTEX_ATTRIB15_4_NV = 0x867F; ///
enum GL_MAP2_VERTEX_ATTRIB1_4_NV = 0x8671; ///
enum GL_MAP2_VERTEX_ATTRIB2_4_NV = 0x8672; ///
enum GL_MAP2_VERTEX_ATTRIB3_4_NV = 0x8673; ///
enum GL_MAP2_VERTEX_ATTRIB4_4_NV = 0x8674; ///
enum GL_MAP2_VERTEX_ATTRIB5_4_NV = 0x8675; ///
enum GL_MAP2_VERTEX_ATTRIB6_4_NV = 0x8676; ///
enum GL_MAP2_VERTEX_ATTRIB7_4_NV = 0x8677; ///
enum GL_MAP2_VERTEX_ATTRIB8_4_NV = 0x8678; ///
enum GL_MAP2_VERTEX_ATTRIB9_4_NV = 0x8679; ///
enum GL_MAP_ATTRIB_U_ORDER_NV = 0x86C3; ///
enum GL_MAP_ATTRIB_V_ORDER_NV = 0x86C4; ///
enum GL_MAP_COHERENT_BIT = 0x0080; ///
enum GL_MAP_COHERENT_BIT_EXT = 0x0080; ///
enum GL_MAP_COLOR = 0x0D10; ///
enum GL_MAP_FLUSH_EXPLICIT_BIT = 0x0010; ///
enum GL_MAP_FLUSH_EXPLICIT_BIT_EXT = 0x0010; ///
enum GL_MAP_INVALIDATE_BUFFER_BIT = 0x0008; ///
enum GL_MAP_INVALIDATE_BUFFER_BIT_EXT = 0x0008; ///
enum GL_MAP_INVALIDATE_RANGE_BIT = 0x0004; ///
enum GL_MAP_INVALIDATE_RANGE_BIT_EXT = 0x0004; ///
enum GL_MAP_PERSISTENT_BIT = 0x0040; ///
enum GL_MAP_PERSISTENT_BIT_EXT = 0x0040; ///
enum GL_MAP_READ_BIT = 0x0001; ///
enum GL_MAP_READ_BIT_EXT = 0x0001; ///
enum GL_MAP_STENCIL = 0x0D11; ///
enum GL_MAP_TESSELLATION_NV = 0x86C2; ///
enum GL_MAP_UNSYNCHRONIZED_BIT = 0x0020; ///
enum GL_MAP_UNSYNCHRONIZED_BIT_EXT = 0x0020; ///
enum GL_MAP_WRITE_BIT = 0x0002; ///
enum GL_MAP_WRITE_BIT_EXT = 0x0002; ///
enum GL_MATERIAL_SIDE_HINT_PGI = 0x1A22C; ///
enum GL_MATRIX0_ARB = 0x88C0; ///
enum GL_MATRIX0_NV = 0x8630; ///
enum GL_MATRIX10_ARB = 0x88CA; ///
enum GL_MATRIX11_ARB = 0x88CB; ///
enum GL_MATRIX12_ARB = 0x88CC; ///
enum GL_MATRIX13_ARB = 0x88CD; ///
enum GL_MATRIX14_ARB = 0x88CE; ///
enum GL_MATRIX15_ARB = 0x88CF; ///
enum GL_MATRIX16_ARB = 0x88D0; ///
enum GL_MATRIX17_ARB = 0x88D1; ///
enum GL_MATRIX18_ARB = 0x88D2; ///
enum GL_MATRIX19_ARB = 0x88D3; ///
enum GL_MATRIX1_ARB = 0x88C1; ///
enum GL_MATRIX1_NV = 0x8631; ///
enum GL_MATRIX20_ARB = 0x88D4; ///
enum GL_MATRIX21_ARB = 0x88D5; ///
enum GL_MATRIX22_ARB = 0x88D6; ///
enum GL_MATRIX23_ARB = 0x88D7; ///
enum GL_MATRIX24_ARB = 0x88D8; ///
enum GL_MATRIX25_ARB = 0x88D9; ///
enum GL_MATRIX26_ARB = 0x88DA; ///
enum GL_MATRIX27_ARB = 0x88DB; ///
enum GL_MATRIX28_ARB = 0x88DC; ///
enum GL_MATRIX29_ARB = 0x88DD; ///
enum GL_MATRIX2_ARB = 0x88C2; ///
enum GL_MATRIX2_NV = 0x8632; ///
enum GL_MATRIX30_ARB = 0x88DE; ///
enum GL_MATRIX31_ARB = 0x88DF; ///
enum GL_MATRIX3_ARB = 0x88C3; ///
enum GL_MATRIX3_NV = 0x8633; ///
enum GL_MATRIX4_ARB = 0x88C4; ///
enum GL_MATRIX4_NV = 0x8634; ///
enum GL_MATRIX5_ARB = 0x88C5; ///
enum GL_MATRIX5_NV = 0x8635; ///
enum GL_MATRIX6_ARB = 0x88C6; ///
enum GL_MATRIX6_NV = 0x8636; ///
enum GL_MATRIX7_ARB = 0x88C7; ///
enum GL_MATRIX7_NV = 0x8637; ///
enum GL_MATRIX8_ARB = 0x88C8; ///
enum GL_MATRIX9_ARB = 0x88C9; ///
enum GL_MATRIX_EXT = 0x87C0; ///
enum GL_MATRIX_INDEX_ARRAY_ARB = 0x8844; ///
enum GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES = 0x8B9E; ///
enum GL_MATRIX_INDEX_ARRAY_OES = 0x8844; ///
enum GL_MATRIX_INDEX_ARRAY_POINTER_ARB = 0x8849; ///
enum GL_MATRIX_INDEX_ARRAY_POINTER_OES = 0x8849; ///
enum GL_MATRIX_INDEX_ARRAY_SIZE_ARB = 0x8846; ///
enum GL_MATRIX_INDEX_ARRAY_SIZE_OES = 0x8846; ///
enum GL_MATRIX_INDEX_ARRAY_STRIDE_ARB = 0x8848; ///
enum GL_MATRIX_INDEX_ARRAY_STRIDE_OES = 0x8848; ///
enum GL_MATRIX_INDEX_ARRAY_TYPE_ARB = 0x8847; ///
enum GL_MATRIX_INDEX_ARRAY_TYPE_OES = 0x8847; ///
enum GL_MATRIX_MODE = 0x0BA0; ///
enum GL_MATRIX_PALETTE_ARB = 0x8840; ///
enum GL_MATRIX_PALETTE_OES = 0x8840; ///
enum GL_MATRIX_STRIDE = 0x92FF; ///
enum GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI = 0x00200000; ///
enum GL_MAT_AMBIENT_BIT_PGI = 0x00100000; ///
enum GL_MAT_COLOR_INDEXES_BIT_PGI = 0x01000000; ///
enum GL_MAT_DIFFUSE_BIT_PGI = 0x00400000; ///
enum GL_MAT_EMISSION_BIT_PGI = 0x00800000; ///
enum GL_MAT_SHININESS_BIT_PGI = 0x02000000; ///
enum GL_MAT_SPECULAR_BIT_PGI = 0x04000000; ///
enum GL_MAX = 0x8008; ///
enum GL_MAX_3D_TEXTURE_SIZE = 0x8073; ///
enum GL_MAX_3D_TEXTURE_SIZE_EXT = 0x8073; ///
enum GL_MAX_3D_TEXTURE_SIZE_OES = 0x8073; ///
enum GL_MAX_4D_TEXTURE_SIZE_SGIS = 0x8138; ///
enum GL_MAX_ACTIVE_LIGHTS_SGIX = 0x8405; ///
enum GL_MAX_ARRAY_TEXTURE_LAYERS = 0x88FF; ///
enum GL_MAX_ARRAY_TEXTURE_LAYERS_EXT = 0x88FF; ///
enum GL_MAX_ASYNC_DRAW_PIXELS_SGIX = 0x8360; ///
enum GL_MAX_ASYNC_HISTOGRAM_SGIX = 0x832D; ///
enum GL_MAX_ASYNC_READ_PIXELS_SGIX = 0x8361; ///
enum GL_MAX_ASYNC_TEX_IMAGE_SGIX = 0x835F; ///
enum GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC; ///
enum GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8; ///
enum GL_MAX_ATTRIB_STACK_DEPTH = 0x0D35; ///
enum GL_MAX_BINDABLE_UNIFORM_SIZE_EXT = 0x8DED; ///
enum GL_MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B; ///
enum GL_MAX_CLIPMAP_DEPTH_SGIX = 0x8177; ///
enum GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8178; ///
enum GL_MAX_CLIP_DISTANCES = 0x0D32; ///
enum GL_MAX_CLIP_DISTANCES_APPLE = 0x0D32; ///
enum GL_MAX_CLIP_DISTANCES_EXT = 0x0D32; ///
enum GL_MAX_CLIP_PLANES = 0x0D32; ///
enum GL_MAX_CLIP_PLANES_IMG = 0x0D32; ///
enum GL_MAX_COLOR_ATTACHMENTS = 0x8CDF; ///
enum GL_MAX_COLOR_ATTACHMENTS_EXT = 0x8CDF; ///
enum GL_MAX_COLOR_ATTACHMENTS_NV = 0x8CDF; ///
enum GL_MAX_COLOR_MATRIX_STACK_DEPTH = 0x80B3; ///
enum GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B3; ///
enum GL_MAX_COLOR_TEXTURE_SAMPLES = 0x910E; ///
enum GL_MAX_COMBINED_ATOMIC_COUNTERS = 0x92D7; ///
enum GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1; ///
enum GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = 0x82FA; ///
enum GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES_EXT = 0x82FA; ///
enum GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = 0x8266; ///
enum GL_MAX_COMBINED_DIMENSIONS = 0x8282; ///
enum GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33; ///
enum GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32; ///
enum GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x8A32; ///
enum GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x8A32; ///
enum GL_MAX_COMBINED_IMAGE_UNIFORMS = 0x90CF; ///
enum GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39; ///
enum GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT = 0x8F39; ///
enum GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = 0x8F39; ///
enum GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = 0x90DC; ///
enum GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E; ///
enum GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x8E1E; ///
enum GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x8E1E; ///
enum GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F; ///
enum GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x8E1F; ///
enum GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x8E1F; ///
enum GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D; ///
enum GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB = 0x8B4D; ///
enum GL_MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E; ///
enum GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31; ///
enum GL_MAX_COMPUTE_ATOMIC_COUNTERS = 0x8265; ///
enum GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = 0x8264; ///
enum GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB = 0x90EB; ///
enum GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB = 0x91BF; ///
enum GL_MAX_COMPUTE_IMAGE_UNIFORMS = 0x91BD; ///
enum GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 0x90DB; ///
enum GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = 0x8262; ///
enum GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = 0x91BC; ///
enum GL_MAX_COMPUTE_UNIFORM_BLOCKS = 0x91BB; ///
enum GL_MAX_COMPUTE_UNIFORM_COMPONENTS = 0x8263; ///
enum GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB = 0x9344; ///
enum GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB = 0x9345; ///
enum GL_MAX_COMPUTE_WORK_GROUP_COUNT = 0x91BE; ///
enum GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS = 0x90EB; ///
enum GL_MAX_COMPUTE_WORK_GROUP_SIZE = 0x91BF; ///
enum GL_MAX_CONVOLUTION_HEIGHT = 0x801B; ///
enum GL_MAX_CONVOLUTION_HEIGHT_EXT = 0x801B; ///
enum GL_MAX_CONVOLUTION_WIDTH = 0x801A; ///
enum GL_MAX_CONVOLUTION_WIDTH_EXT = 0x801A; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB = 0x851C; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT = 0x851C; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE_OES = 0x851C; ///
enum GL_MAX_CULL_DISTANCES = 0x82F9; ///
enum GL_MAX_CULL_DISTANCES_EXT = 0x82F9; ///
enum GL_MAX_DEBUG_GROUP_STACK_DEPTH = 0x826C; ///
enum GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR = 0x826C; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES = 0x9144; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES_AMD = 0x9144; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES_ARB = 0x9144; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES_KHR = 0x9144; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH = 0x9143; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH_AMD = 0x9143; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH_ARB = 0x9143; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH_KHR = 0x9143; ///
enum GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV = 0x90D1; ///
enum GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV = 0x90D0; ///
enum GL_MAX_DEFORMATION_ORDER_SGIX = 0x8197; ///
enum GL_MAX_DEPTH = 0x8280; ///
enum GL_MAX_DEPTH_TEXTURE_SAMPLES = 0x910F; ///
enum GL_MAX_DRAW_BUFFERS = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_ARB = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_ATI = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_EXT = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_NV = 0x8824; ///
enum GL_MAX_DUAL_SOURCE_DRAW_BUFFERS = 0x88FC; ///
enum GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT = 0x88FC; ///
enum GL_MAX_ELEMENTS_INDICES = 0x80E9; ///
enum GL_MAX_ELEMENTS_INDICES_EXT = 0x80E9; ///
enum GL_MAX_ELEMENTS_VERTICES = 0x80E8; ///
enum GL_MAX_ELEMENTS_VERTICES_EXT = 0x80E8; ///
enum GL_MAX_ELEMENT_INDEX = 0x8D6B; ///
enum GL_MAX_EVAL_ORDER = 0x0D30; ///
enum GL_MAX_EXT = 0x8008; ///
enum GL_MAX_FOG_FUNC_POINTS_SGIS = 0x812C; ///
enum GL_MAX_FRAGMENT_ATOMIC_COUNTERS = 0x92D6; ///
enum GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0; ///
enum GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT = 0x8DE3; ///
enum GL_MAX_FRAGMENT_IMAGE_UNIFORMS = 0x90CE; ///
enum GL_MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125; ///
enum GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C; ///
enum GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV = 0x8E5C; ///
enum GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5C; ///
enum GL_MAX_FRAGMENT_LIGHTS_SGIX = 0x8404; ///
enum GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV = 0x8868; ///
enum GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = 0x90DA; ///
enum GL_MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D; ///
enum GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49; ///
enum GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB = 0x8B49; ///
enum GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD; ///
enum GL_MAX_FRAMEBUFFER_HEIGHT = 0x9316; ///
enum GL_MAX_FRAMEBUFFER_LAYERS = 0x9317; ///
enum GL_MAX_FRAMEBUFFER_LAYERS_EXT = 0x9317; ///
enum GL_MAX_FRAMEBUFFER_LAYERS_OES = 0x9317; ///
enum GL_MAX_FRAMEBUFFER_SAMPLES = 0x9318; ///
enum GL_MAX_FRAMEBUFFER_WIDTH = 0x9315; ///
enum GL_MAX_FRAMEZOOM_FACTOR_SGIX = 0x818D; ///
enum GL_MAX_GENERAL_COMBINERS_NV = 0x854D; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTERS = 0x92D5; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT = 0x92D5; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTERS_OES = 0x92D5; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CF; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES = 0x92CF; ///
enum GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT = 0x8DE4; ///
enum GL_MAX_GEOMETRY_IMAGE_UNIFORMS = 0x90CD; ///
enum GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT = 0x90CD; ///
enum GL_MAX_GEOMETRY_IMAGE_UNIFORMS_OES = 0x90CD; ///
enum GL_MAX_GEOMETRY_INPUT_COMPONENTS = 0x9123; ///
enum GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT = 0x9123; ///
enum GL_MAX_GEOMETRY_INPUT_COMPONENTS_OES = 0x9123; ///
enum GL_MAX_GEOMETRY_OUTPUT_COMPONENTS = 0x9124; ///
enum GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT = 0x9124; ///
enum GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_OES = 0x9124; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES = 0x8DE0; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB = 0x8DE0; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT = 0x8DE0; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES_OES = 0x8DE0; ///
enum GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_INVOCATIONS_OES = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = 0x90D7; ///
enum GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT = 0x90D7; ///
enum GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES = 0x90D7; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB = 0x8C29; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT = 0x8C29; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES = 0x8C29; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB = 0x8DE1; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT = 0x8DE1; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES = 0x8DE1; ///
enum GL_MAX_GEOMETRY_UNIFORM_BLOCKS = 0x8A2C; ///
enum GL_MAX_GEOMETRY_UNIFORM_BLOCKS_EXT = 0x8A2C; ///
enum GL_MAX_GEOMETRY_UNIFORM_BLOCKS_OES = 0x8A2C; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS = 0x8DDF; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB = 0x8DDF; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x8DDF; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x8DDF; ///
enum GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB = 0x8DDD; ///
enum GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT = 0x8DDD; ///
enum GL_MAX_HEIGHT = 0x827F; ///
enum GL_MAX_IMAGE_SAMPLES = 0x906D; ///
enum GL_MAX_IMAGE_SAMPLES_EXT = 0x906D; ///
enum GL_MAX_IMAGE_UNITS = 0x8F38; ///
enum GL_MAX_IMAGE_UNITS_EXT = 0x8F38; ///
enum GL_MAX_INTEGER_SAMPLES = 0x9110; ///
enum GL_MAX_LABEL_LENGTH = 0x82E8; ///
enum GL_MAX_LABEL_LENGTH_KHR = 0x82E8; ///
enum GL_MAX_LAYERS = 0x8281; ///
enum GL_MAX_LIGHTS = 0x0D31; ///
enum GL_MAX_LIST_NESTING = 0x0B31; ///
enum GL_MAX_MAP_TESSELLATION_NV = 0x86D6; ///
enum GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB = 0x8841; ///
enum GL_MAX_MODELVIEW_STACK_DEPTH = 0x0D36; ///
enum GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV = 0x8E11; ///
enum GL_MAX_MULTIVIEW_BUFFERS_EXT = 0x90F2; ///
enum GL_MAX_NAME_LENGTH = 0x92F6; ///
enum GL_MAX_NAME_STACK_DEPTH = 0x0D37; ///
enum GL_MAX_NUM_ACTIVE_VARIABLES = 0x92F7; ///
enum GL_MAX_NUM_COMPATIBLE_SUBROUTINES = 0x92F8; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87CA; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT = 0x87CD; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT = 0x87CE; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87CC; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT = 0x87CB; ///
enum GL_MAX_PALETTE_MATRICES_ARB = 0x8842; ///
enum GL_MAX_PALETTE_MATRICES_OES = 0x8842; ///
enum GL_MAX_PATCH_VERTICES = 0x8E7D; ///
enum GL_MAX_PATCH_VERTICES_EXT = 0x8E7D; ///
enum GL_MAX_PATCH_VERTICES_OES = 0x8E7D; ///
enum GL_MAX_PIXEL_MAP_TABLE = 0x0D34; ///
enum GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 0x8337; ///
enum GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 0x87F1; ///
enum GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB = 0x88B1; ///
enum GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB = 0x880B; ///
enum GL_MAX_PROGRAM_ATTRIBS_ARB = 0x88AD; ///
enum GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV = 0x8908; ///
enum GL_MAX_PROGRAM_CALL_DEPTH_NV = 0x88F5; ///
enum GL_MAX_PROGRAM_ENV_PARAMETERS_ARB = 0x88B5; ///
enum GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV = 0x88F4; ///
enum GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV = 0x8DA5; ///
enum GL_MAX_PROGRAM_GENERIC_RESULTS_NV = 0x8DA6; ///
enum GL_MAX_PROGRAM_IF_DEPTH_NV = 0x88F6; ///
enum GL_MAX_PROGRAM_INSTRUCTIONS_ARB = 0x88A1; ///
enum GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB = 0x88B4; ///
enum GL_MAX_PROGRAM_LOOP_COUNT_NV = 0x88F8; ///
enum GL_MAX_PROGRAM_LOOP_DEPTH_NV = 0x88F7; ///
enum GL_MAX_PROGRAM_MATRICES_ARB = 0x862F; ///
enum GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB = 0x862E; ///
enum GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 0x88B3; ///
enum GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 0x880E; ///
enum GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB = 0x88AF; ///
enum GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 0x88A3; ///
enum GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB = 0x88AB; ///
enum GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB = 0x88A7; ///
enum GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 0x8810; ///
enum GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 0x880F; ///
enum GL_MAX_PROGRAM_OUTPUT_VERTICES_NV = 0x8C27; ///
enum GL_MAX_PROGRAM_PARAMETERS_ARB = 0x88A9; ///
enum GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV = 0x8DA0; ///
enum GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV = 0x8DA1; ///
enum GL_MAX_PROGRAM_PATCH_ATTRIBS_NV = 0x86D8; ///
enum GL_MAX_PROGRAM_RESULT_COMPONENTS_NV = 0x8909; ///
enum GL_MAX_PROGRAM_SUBROUTINE_NUM_NV = 0x8F45; ///
enum GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV = 0x8F44; ///
enum GL_MAX_PROGRAM_TEMPORARIES_ARB = 0x88A5; ///
enum GL_MAX_PROGRAM_TEXEL_OFFSET = 0x8905; ///
enum GL_MAX_PROGRAM_TEXEL_OFFSET_EXT = 0x8905; ///
enum GL_MAX_PROGRAM_TEXEL_OFFSET_NV = 0x8905; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB = 0x8F9F; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5F; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5F; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV = 0x8E5F; ///
enum GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB = 0x880D; ///
enum GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB = 0x880C; ///
enum GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV = 0x8C28; ///
enum GL_MAX_PROJECTION_STACK_DEPTH = 0x0D38; ///
enum GL_MAX_RASTER_SAMPLES_EXT = 0x9329; ///
enum GL_MAX_RATIONAL_EVAL_ORDER_NV = 0x86D7; ///
enum GL_MAX_RECTANGLE_TEXTURE_SIZE = 0x84F8; ///
enum GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB = 0x84F8; ///
enum GL_MAX_RECTANGLE_TEXTURE_SIZE_NV = 0x84F8; ///
enum GL_MAX_RENDERBUFFER_SIZE = 0x84E8; ///
enum GL_MAX_RENDERBUFFER_SIZE_EXT = 0x84E8; ///
enum GL_MAX_RENDERBUFFER_SIZE_OES = 0x84E8; ///
enum GL_MAX_SAMPLES = 0x8D57; ///
enum GL_MAX_SAMPLES_ANGLE = 0x8D57; ///
enum GL_MAX_SAMPLES_APPLE = 0x8D57; ///
enum GL_MAX_SAMPLES_EXT = 0x8D57; ///
enum GL_MAX_SAMPLES_IMG = 0x9135; ///
enum GL_MAX_SAMPLES_NV = 0x8D57; ///
enum GL_MAX_SAMPLE_MASK_WORDS = 0x8E59; ///
enum GL_MAX_SAMPLE_MASK_WORDS_NV = 0x8E59; ///
enum GL_MAX_SERVER_WAIT_TIMEOUT = 0x9111; ///
enum GL_MAX_SERVER_WAIT_TIMEOUT_APPLE = 0x9111; ///
enum GL_MAX_SHADER_BUFFER_ADDRESS_NV = 0x8F35; ///
enum GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_FAST_SIZE_EXT = 0x9650; ///
enum GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_SIZE_EXT = 0x9651; ///
enum GL_MAX_SHADER_COMPILER_THREADS_ARB = 0x91B0; ///
enum GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT = 0x8F63; ///
enum GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT = 0x8F67; ///
enum GL_MAX_SHADER_STORAGE_BLOCK_SIZE = 0x90DE; ///
enum GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = 0x90DD; ///
enum GL_MAX_SHININESS_NV = 0x8504; ///
enum GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD = 0x9199; ///
enum GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB = 0x9199; ///
enum GL_MAX_SPARSE_3D_TEXTURE_SIZE_EXT = 0x9199; ///
enum GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS = 0x919A; ///
enum GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB = 0x919A; ///
enum GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT = 0x919A; ///
enum GL_MAX_SPARSE_TEXTURE_SIZE_AMD = 0x9198; ///
enum GL_MAX_SPARSE_TEXTURE_SIZE_ARB = 0x9198; ///
enum GL_MAX_SPARSE_TEXTURE_SIZE_EXT = 0x9198; ///
enum GL_MAX_SPOT_EXPONENT_NV = 0x8505; ///
enum GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV = 0x9349; ///
enum GL_MAX_SUBROUTINES = 0x8DE7; ///
enum GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT = 0x92D3; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES = 0x92D3; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CD; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES = 0x92CD; ///
enum GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB; ///
enum GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT = 0x90CB; ///
enum GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES = 0x90CB; ///
enum GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C; ///
enum GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT = 0x886C; ///
enum GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_OES = 0x886C; ///
enum GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83; ///
enum GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT = 0x8E83; ///
enum GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES = 0x8E83; ///
enum GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = 0x90D8; ///
enum GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT = 0x90D8; ///
enum GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES = 0x90D8; ///
enum GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81; ///
enum GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT = 0x8E81; ///
enum GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES = 0x8E81; ///
enum GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85; ///
enum GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT = 0x8E85; ///
enum GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES = 0x8E85; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT = 0x8E89; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES = 0x8E89; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x8E7F; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x8E7F; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT = 0x92D4; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES = 0x92D4; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CE; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES = 0x92CE; ///
enum GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC; ///
enum GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT = 0x90CC; ///
enum GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES = 0x90CC; ///
enum GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D; ///
enum GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT = 0x886D; ///
enum GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES = 0x886D; ///
enum GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86; ///
enum GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT = 0x8E86; ///
enum GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES = 0x8E86; ///
enum GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = 0x90D9; ///
enum GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT = 0x90D9; ///
enum GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES = 0x90D9; ///
enum GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82; ///
enum GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT = 0x8E82; ///
enum GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES = 0x8E82; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT = 0x8E8A; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES = 0x8E8A; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x8E80; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x8E80; ///
enum GL_MAX_TESS_GEN_LEVEL = 0x8E7E; ///
enum GL_MAX_TESS_GEN_LEVEL_EXT = 0x8E7E; ///
enum GL_MAX_TESS_GEN_LEVEL_OES = 0x8E7E; ///
enum GL_MAX_TESS_PATCH_COMPONENTS = 0x8E84; ///
enum GL_MAX_TESS_PATCH_COMPONENTS_EXT = 0x8E84; ///
enum GL_MAX_TESS_PATCH_COMPONENTS_OES = 0x8E84; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE = 0x8C2B; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE_ARB = 0x8C2B; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE_EXT = 0x8C2B; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE_OES = 0x8C2B; ///
enum GL_MAX_TEXTURE_COORDS = 0x8871; ///
enum GL_MAX_TEXTURE_COORDS_ARB = 0x8871; ///
enum GL_MAX_TEXTURE_COORDS_NV = 0x8871; ///
enum GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872; ///
enum GL_MAX_TEXTURE_IMAGE_UNITS_ARB = 0x8872; ///
enum GL_MAX_TEXTURE_IMAGE_UNITS_NV = 0x8872; ///
enum GL_MAX_TEXTURE_LOD_BIAS = 0x84FD; ///
enum GL_MAX_TEXTURE_LOD_BIAS_EXT = 0x84FD; ///
enum GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF; ///
enum GL_MAX_TEXTURE_SIZE = 0x0D33; ///
enum GL_MAX_TEXTURE_STACK_DEPTH = 0x0D39; ///
enum GL_MAX_TEXTURE_UNITS = 0x84E2; ///
enum GL_MAX_TEXTURE_UNITS_ARB = 0x84E2; ///
enum GL_MAX_TRACK_MATRICES_NV = 0x862F; ///
enum GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV = 0x862E; ///
enum GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70; ///
enum GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A; ///
enum GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT = 0x8C8A; ///
enum GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV = 0x8C8A; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT = 0x8C8B; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV = 0x8C8B; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT = 0x8C80; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV = 0x8C80; ///
enum GL_MAX_UNIFORM_BLOCK_SIZE = 0x8A30; ///
enum GL_MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F; ///
enum GL_MAX_UNIFORM_LOCATIONS = 0x826E; ///
enum GL_MAX_VARYING_COMPONENTS = 0x8B4B; ///
enum GL_MAX_VARYING_COMPONENTS_EXT = 0x8B4B; ///
enum GL_MAX_VARYING_FLOATS = 0x8B4B; ///
enum GL_MAX_VARYING_FLOATS_ARB = 0x8B4B; ///
enum GL_MAX_VARYING_VECTORS = 0x8DFC; ///
enum GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV = 0x8520; ///
enum GL_MAX_VERTEX_ATOMIC_COUNTERS = 0x92D2; ///
enum GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC; ///
enum GL_MAX_VERTEX_ATTRIBS = 0x8869; ///
enum GL_MAX_VERTEX_ATTRIBS_ARB = 0x8869; ///
enum GL_MAX_VERTEX_ATTRIB_BINDINGS = 0x82DA; ///
enum GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D9; ///
enum GL_MAX_VERTEX_ATTRIB_STRIDE = 0x82E5; ///
enum GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT = 0x8DE2; ///
enum GL_MAX_VERTEX_HINT_PGI = 0x1A22D; ///
enum GL_MAX_VERTEX_IMAGE_UNIFORMS = 0x90CA; ///
enum GL_MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122; ///
enum GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87C5; ///
enum GL_MAX_VERTEX_SHADER_INVARIANTS_EXT = 0x87C7; ///
enum GL_MAX_VERTEX_SHADER_LOCALS_EXT = 0x87C9; ///
enum GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87C8; ///
enum GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = 0x90D6; ///
enum GL_MAX_VERTEX_SHADER_VARIANTS_EXT = 0x87C6; ///
enum GL_MAX_VERTEX_STREAMS = 0x8E71; ///
enum GL_MAX_VERTEX_STREAMS_ATI = 0x876B; ///
enum GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C; ///
enum GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB = 0x8B4C; ///
enum GL_MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B; ///
enum GL_MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A; ///
enum GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB = 0x8B4A; ///
enum GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB; ///
enum GL_MAX_VERTEX_UNITS_ARB = 0x86A4; ///
enum GL_MAX_VERTEX_UNITS_OES = 0x86A4; ///
enum GL_MAX_VERTEX_VARYING_COMPONENTS_ARB = 0x8DDE; ///
enum GL_MAX_VERTEX_VARYING_COMPONENTS_EXT = 0x8DDE; ///
enum GL_MAX_VIEWPORTS = 0x825B; ///
enum GL_MAX_VIEWPORTS_NV = 0x825B; ///
enum GL_MAX_VIEWPORTS_OES = 0x825B; ///
enum GL_MAX_VIEWPORT_DIMS = 0x0D3A; ///
enum GL_MAX_VIEWS_OVR = 0x9631; ///
enum GL_MAX_WIDTH = 0x827E; ///
enum GL_MAX_WINDOW_RECTANGLES_EXT = 0x8F14; ///
enum GL_MEDIUM_FLOAT = 0x8DF1; ///
enum GL_MEDIUM_INT = 0x8DF4; ///
enum GL_MIN = 0x8007; ///
enum GL_MINMAX = 0x802E; ///
enum GL_MINMAX_EXT = 0x802E; ///
enum GL_MINMAX_FORMAT = 0x802F; ///
enum GL_MINMAX_FORMAT_EXT = 0x802F; ///
enum GL_MINMAX_SINK = 0x8030; ///
enum GL_MINMAX_SINK_EXT = 0x8030; ///
enum GL_MINOR_VERSION = 0x821C; ///
enum GL_MINUS_CLAMPED_NV = 0x92B3; ///
enum GL_MINUS_NV = 0x929F; ///
enum GL_MIN_EXT = 0x8007; ///
enum GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B; ///
enum GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV = 0x8E5B; ///
enum GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5B; ///
enum GL_MIN_LOD_WARNING_AMD = 0x919C; ///
enum GL_MIN_MAP_BUFFER_ALIGNMENT = 0x90BC; ///
enum GL_MIN_PROGRAM_TEXEL_OFFSET = 0x8904; ///
enum GL_MIN_PROGRAM_TEXEL_OFFSET_EXT = 0x8904; ///
enum GL_MIN_PROGRAM_TEXEL_OFFSET_NV = 0x8904; ///
enum GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5E; ///
enum GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5E; ///
enum GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV = 0x8E5E; ///
enum GL_MIN_SAMPLE_SHADING_VALUE = 0x8C37; ///
enum GL_MIN_SAMPLE_SHADING_VALUE_ARB = 0x8C37; ///
enum GL_MIN_SAMPLE_SHADING_VALUE_OES = 0x8C37; ///
enum GL_MIN_SPARSE_LEVEL_AMD = 0x919B; ///
enum GL_MIPMAP = 0x8293; ///
enum GL_MIRRORED_REPEAT = 0x8370; ///
enum GL_MIRRORED_REPEAT_ARB = 0x8370; ///
enum GL_MIRRORED_REPEAT_IBM = 0x8370; ///
enum GL_MIRRORED_REPEAT_OES = 0x8370; ///
enum GL_MIRROR_CLAMP_ATI = 0x8742; ///
enum GL_MIRROR_CLAMP_EXT = 0x8742; ///
enum GL_MIRROR_CLAMP_TO_BORDER_EXT = 0x8912; ///
enum GL_MIRROR_CLAMP_TO_EDGE = 0x8743; ///
enum GL_MIRROR_CLAMP_TO_EDGE_ATI = 0x8743; ///
enum GL_MIRROR_CLAMP_TO_EDGE_EXT = 0x8743; ///
enum GL_MITER_REVERT_NV = 0x90A7; ///
enum GL_MITER_TRUNCATE_NV = 0x90A8; ///
enum GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV = 0x932F; ///
enum GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV = 0x9330; ///
enum GL_MODELVIEW = 0x1700; ///
enum GL_MODELVIEW0_ARB = 0x1700; ///
enum GL_MODELVIEW0_EXT = 0x1700; ///
enum GL_MODELVIEW0_MATRIX_EXT = 0x0BA6; ///
enum GL_MODELVIEW0_STACK_DEPTH_EXT = 0x0BA3; ///
enum GL_MODELVIEW10_ARB = 0x872A; ///
enum GL_MODELVIEW11_ARB = 0x872B; ///
enum GL_MODELVIEW12_ARB = 0x872C; ///
enum GL_MODELVIEW13_ARB = 0x872D; ///
enum GL_MODELVIEW14_ARB = 0x872E; ///
enum GL_MODELVIEW15_ARB = 0x872F; ///
enum GL_MODELVIEW16_ARB = 0x8730; ///
enum GL_MODELVIEW17_ARB = 0x8731; ///
enum GL_MODELVIEW18_ARB = 0x8732; ///
enum GL_MODELVIEW19_ARB = 0x8733; ///
enum GL_MODELVIEW1_ARB = 0x850A; ///
enum GL_MODELVIEW1_EXT = 0x850A; ///
enum GL_MODELVIEW1_MATRIX_EXT = 0x8506; ///
enum GL_MODELVIEW1_STACK_DEPTH_EXT = 0x8502; ///
enum GL_MODELVIEW20_ARB = 0x8734; ///
enum GL_MODELVIEW21_ARB = 0x8735; ///
enum GL_MODELVIEW22_ARB = 0x8736; ///
enum GL_MODELVIEW23_ARB = 0x8737; ///
enum GL_MODELVIEW24_ARB = 0x8738; ///
enum GL_MODELVIEW25_ARB = 0x8739; ///
enum GL_MODELVIEW26_ARB = 0x873A; ///
enum GL_MODELVIEW27_ARB = 0x873B; ///
enum GL_MODELVIEW28_ARB = 0x873C; ///
enum GL_MODELVIEW29_ARB = 0x873D; ///
enum GL_MODELVIEW2_ARB = 0x8722; ///
enum GL_MODELVIEW30_ARB = 0x873E; ///
enum GL_MODELVIEW31_ARB = 0x873F; ///
enum GL_MODELVIEW3_ARB = 0x8723; ///
enum GL_MODELVIEW4_ARB = 0x8724; ///
enum GL_MODELVIEW5_ARB = 0x8725; ///
enum GL_MODELVIEW6_ARB = 0x8726; ///
enum GL_MODELVIEW7_ARB = 0x8727; ///
enum GL_MODELVIEW8_ARB = 0x8728; ///
enum GL_MODELVIEW9_ARB = 0x8729; ///
enum GL_MODELVIEW_MATRIX = 0x0BA6; ///
enum GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898D; ///
enum GL_MODELVIEW_PROJECTION_NV = 0x8629; ///
enum GL_MODELVIEW_STACK_DEPTH = 0x0BA3; ///
enum GL_MODULATE = 0x2100; ///
enum GL_MODULATE_ADD_ATI = 0x8744; ///
enum GL_MODULATE_COLOR_IMG = 0x8C04; ///
enum GL_MODULATE_SIGNED_ADD_ATI = 0x8745; ///
enum GL_MODULATE_SUBTRACT_ATI = 0x8746; ///
enum GL_MOVE_TO_CONTINUES_NV = 0x90B6; ///
enum GL_MOVE_TO_NV = 0x02; ///
enum GL_MOVE_TO_RESETS_NV = 0x90B5; ///
enum GL_MOV_ATI = 0x8961; ///
enum GL_MULT = 0x0103; ///
enum GL_MULTIPLY = 0x9294; ///
enum GL_MULTIPLY_KHR = 0x9294; ///
enum GL_MULTIPLY_NV = 0x9294; ///
enum GL_MULTISAMPLE = 0x809D; ///
enum GL_MULTISAMPLES_NV = 0x9371; ///
enum GL_MULTISAMPLE_3DFX = 0x86B2; ///
enum GL_MULTISAMPLE_ARB = 0x809D; ///
enum GL_MULTISAMPLE_BIT = 0x20000000; ///
enum GL_MULTISAMPLE_BIT_3DFX = 0x20000000; ///
enum GL_MULTISAMPLE_BIT_ARB = 0x20000000; ///
enum GL_MULTISAMPLE_BIT_EXT = 0x20000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT0_QCOM = 0x01000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT1_QCOM = 0x02000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT2_QCOM = 0x04000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT3_QCOM = 0x08000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT4_QCOM = 0x10000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT5_QCOM = 0x20000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT6_QCOM = 0x40000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT7_QCOM = 0x80000000; ///
enum GL_MULTISAMPLE_COVERAGE_MODES_NV = 0x8E12; ///
enum GL_MULTISAMPLE_EXT = 0x809D; ///
enum GL_MULTISAMPLE_FILTER_HINT_NV = 0x8534; ///
enum GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY = 0x9382; ///
enum GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB = 0x9382; ///
enum GL_MULTISAMPLE_LINE_WIDTH_RANGE = 0x9381; ///
enum GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB = 0x9381; ///
enum GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT = 0x932B; ///
enum GL_MULTISAMPLE_SGIS = 0x809D; ///
enum GL_MULTIVIEW_EXT = 0x90F1; ///
enum GL_MUL_ATI = 0x8964; ///
enum GL_MVP_MATRIX_EXT = 0x87E3; ///
enum GL_N3F_V3F = 0x2A25; ///
enum GL_NAMED_STRING_LENGTH_ARB = 0x8DE9; ///
enum GL_NAMED_STRING_TYPE_ARB = 0x8DEA; ///
enum GL_NAME_LENGTH = 0x92F9; ///
enum GL_NAME_STACK_DEPTH = 0x0D70; ///
enum GL_NAND = 0x150E; ///
enum GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI = 0x1A203; ///
enum GL_NATIVE_GRAPHICS_END_HINT_PGI = 0x1A204; ///
enum GL_NATIVE_GRAPHICS_HANDLE_PGI = 0x1A202; ///
enum GL_NEAREST = 0x2600; ///
enum GL_NEAREST_CLIPMAP_LINEAR_SGIX = 0x844E; ///
enum GL_NEAREST_CLIPMAP_NEAREST_SGIX = 0x844D; ///
enum GL_NEAREST_MIPMAP_LINEAR = 0x2702; ///
enum GL_NEAREST_MIPMAP_NEAREST = 0x2700; ///
enum GL_NEGATE_BIT_ATI = 0x00000004; ///
enum GL_NEGATIVE_ONE_EXT = 0x87DF; ///
enum GL_NEGATIVE_ONE_TO_ONE = 0x935E; ///
enum GL_NEGATIVE_W_EXT = 0x87DC; ///
enum GL_NEGATIVE_X_EXT = 0x87D9; ///
enum GL_NEGATIVE_Y_EXT = 0x87DA; ///
enum GL_NEGATIVE_Z_EXT = 0x87DB; ///
enum GL_NEVER = 0x0200; ///
enum GL_NEXT_BUFFER_NV = -2; ///
enum GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV = 0x9025; ///
enum GL_NICEST = 0x1102; ///
enum GL_NONE = 0; ///
enum GL_NONE_OES = 0; ///
enum GL_NOOP = 0x1505; ///
enum GL_NOP_COMMAND_NV = 0x0001; ///
enum GL_NOR = 0x1508; ///
enum GL_NORMALIZE = 0x0BA1; ///
enum GL_NORMALIZED_RANGE_EXT = 0x87E0; ///
enum GL_NORMAL_ARRAY = 0x8075; ///
enum GL_NORMAL_ARRAY_ADDRESS_NV = 0x8F22; ///
enum GL_NORMAL_ARRAY_BUFFER_BINDING = 0x8897; ///
enum GL_NORMAL_ARRAY_BUFFER_BINDING_ARB = 0x8897; ///
enum GL_NORMAL_ARRAY_COUNT_EXT = 0x8080; ///
enum GL_NORMAL_ARRAY_EXT = 0x8075; ///
enum GL_NORMAL_ARRAY_LENGTH_NV = 0x8F2C; ///
enum GL_NORMAL_ARRAY_LIST_IBM = 0x103071; ///
enum GL_NORMAL_ARRAY_LIST_STRIDE_IBM = 0x103081; ///
enum GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F6; ///
enum GL_NORMAL_ARRAY_POINTER = 0x808F; ///
enum GL_NORMAL_ARRAY_POINTER_EXT = 0x808F; ///
enum GL_NORMAL_ARRAY_STRIDE = 0x807F; ///
enum GL_NORMAL_ARRAY_STRIDE_EXT = 0x807F; ///
enum GL_NORMAL_ARRAY_TYPE = 0x807E; ///
enum GL_NORMAL_ARRAY_TYPE_EXT = 0x807E; ///
enum GL_NORMAL_BIT_PGI = 0x08000000; ///
enum GL_NORMAL_MAP = 0x8511; ///
enum GL_NORMAL_MAP_ARB = 0x8511; ///
enum GL_NORMAL_MAP_EXT = 0x8511; ///
enum GL_NORMAL_MAP_NV = 0x8511; ///
enum GL_NORMAL_MAP_OES = 0x8511; ///
enum GL_NOTEQUAL = 0x0205; ///
enum GL_NO_ERROR = 0; ///
enum GL_NO_RESET_NOTIFICATION = 0x8261; ///
enum GL_NO_RESET_NOTIFICATION_ARB = 0x8261; ///
enum GL_NO_RESET_NOTIFICATION_EXT = 0x8261; ///
enum GL_NO_RESET_NOTIFICATION_KHR = 0x8261; ///
enum GL_NUM_ACTIVE_VARIABLES = 0x9304; ///
enum GL_NUM_COMPATIBLE_SUBROUTINES = 0x8E4A; ///
enum GL_NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2; ///
enum GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB = 0x86A2; ///
enum GL_NUM_DOWNSAMPLE_SCALES_IMG = 0x913D; ///
enum GL_NUM_EXTENSIONS = 0x821D; ///
enum GL_NUM_FILL_STREAMS_NV = 0x8E29; ///
enum GL_NUM_FRAGMENT_CONSTANTS_ATI = 0x896F; ///
enum GL_NUM_FRAGMENT_REGISTERS_ATI = 0x896E; ///
enum GL_NUM_GENERAL_COMBINERS_NV = 0x854E; ///
enum GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI = 0x8973; ///
enum GL_NUM_INSTRUCTIONS_PER_PASS_ATI = 0x8971; ///
enum GL_NUM_INSTRUCTIONS_TOTAL_ATI = 0x8972; ///
enum GL_NUM_LOOPBACK_COMPONENTS_ATI = 0x8974; ///
enum GL_NUM_PASSES_ATI = 0x8970; ///
enum GL_NUM_PROGRAM_BINARY_FORMATS = 0x87FE; ///
enum GL_NUM_PROGRAM_BINARY_FORMATS_OES = 0x87FE; ///
enum GL_NUM_SAMPLE_COUNTS = 0x9380; ///
enum GL_NUM_SHADER_BINARY_FORMATS = 0x8DF9; ///
enum GL_NUM_SHADING_LANGUAGE_VERSIONS = 0x82E9; ///
enum GL_NUM_SPARSE_LEVELS_ARB = 0x91AA; ///
enum GL_NUM_SPARSE_LEVELS_EXT = 0x91AA; ///
enum GL_NUM_VIDEO_CAPTURE_STREAMS_NV = 0x9024; ///
enum GL_NUM_VIRTUAL_PAGE_SIZES_ARB = 0x91A8; ///
enum GL_NUM_VIRTUAL_PAGE_SIZES_EXT = 0x91A8; ///
enum GL_NUM_WINDOW_RECTANGLES_EXT = 0x8F15; ///
enum GL_OBJECT_ACTIVE_ATTRIBUTES_ARB = 0x8B89; ///
enum GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB = 0x8B8A; ///
enum GL_OBJECT_ACTIVE_UNIFORMS_ARB = 0x8B86; ///
enum GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB = 0x8B87; ///
enum GL_OBJECT_ATTACHED_OBJECTS_ARB = 0x8B85; ///
enum GL_OBJECT_BUFFER_SIZE_ATI = 0x8764; ///
enum GL_OBJECT_BUFFER_USAGE_ATI = 0x8765; ///
enum GL_OBJECT_COMPILE_STATUS_ARB = 0x8B81; ///
enum GL_OBJECT_DELETE_STATUS_ARB = 0x8B80; ///
enum GL_OBJECT_DISTANCE_TO_LINE_SGIS = 0x81F3; ///
enum GL_OBJECT_DISTANCE_TO_POINT_SGIS = 0x81F1; ///
enum GL_OBJECT_INFO_LOG_LENGTH_ARB = 0x8B84; ///
enum GL_OBJECT_LINEAR = 0x2401; ///
enum GL_OBJECT_LINEAR_NV = 0x2401; ///
enum GL_OBJECT_LINE_SGIS = 0x81F7; ///
enum GL_OBJECT_LINK_STATUS_ARB = 0x8B82; ///
enum GL_OBJECT_PLANE = 0x2501; ///
enum GL_OBJECT_POINT_SGIS = 0x81F5; ///
enum GL_OBJECT_SHADER_SOURCE_LENGTH_ARB = 0x8B88; ///
enum GL_OBJECT_SUBTYPE_ARB = 0x8B4F; ///
enum GL_OBJECT_TYPE = 0x9112; ///
enum GL_OBJECT_TYPE_APPLE = 0x9112; ///
enum GL_OBJECT_TYPE_ARB = 0x8B4E; ///
enum GL_OBJECT_VALIDATE_STATUS_ARB = 0x8B83; ///
enum GL_OCCLUSION_QUERY_EVENT_MASK_AMD = 0x874F; ///
enum GL_OCCLUSION_TEST_HP = 0x8165; ///
enum GL_OCCLUSION_TEST_RESULT_HP = 0x8166; ///
enum GL_OFFSET = 0x92FC; ///
enum GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV = 0x8856; ///
enum GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV = 0x8857; ///
enum GL_OFFSET_HILO_TEXTURE_2D_NV = 0x8854; ///
enum GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV = 0x8855; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV = 0x8850; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV = 0x8851; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV = 0x8852; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV = 0x8853; ///
enum GL_OFFSET_TEXTURE_2D_BIAS_NV = 0x86E3; ///
enum GL_OFFSET_TEXTURE_2D_MATRIX_NV = 0x86E1; ///
enum GL_OFFSET_TEXTURE_2D_NV = 0x86E8; ///
enum GL_OFFSET_TEXTURE_2D_SCALE_NV = 0x86E2; ///
enum GL_OFFSET_TEXTURE_BIAS_NV = 0x86E3; ///
enum GL_OFFSET_TEXTURE_MATRIX_NV = 0x86E1; ///
enum GL_OFFSET_TEXTURE_RECTANGLE_NV = 0x864C; ///
enum GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV = 0x864D; ///
enum GL_OFFSET_TEXTURE_SCALE_NV = 0x86E2; ///
enum GL_ONE = 1; ///
enum GL_ONE_EXT = 0x87DE; ///
enum GL_ONE_MINUS_CONSTANT_ALPHA = 0x8004; ///
enum GL_ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004; ///
enum GL_ONE_MINUS_CONSTANT_COLOR = 0x8002; ///
enum GL_ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002; ///
enum GL_ONE_MINUS_DST_ALPHA = 0x0305; ///
enum GL_ONE_MINUS_DST_COLOR = 0x0307; ///
enum GL_ONE_MINUS_SRC1_ALPHA = 0x88FB; ///
enum GL_ONE_MINUS_SRC1_ALPHA_EXT = 0x88FB; ///
enum GL_ONE_MINUS_SRC1_COLOR = 0x88FA; ///
enum GL_ONE_MINUS_SRC1_COLOR_EXT = 0x88FA; ///
enum GL_ONE_MINUS_SRC_ALPHA = 0x0303; ///
enum GL_ONE_MINUS_SRC_COLOR = 0x0301; ///
enum GL_OPERAND0_ALPHA = 0x8598; ///
enum GL_OPERAND0_ALPHA_ARB = 0x8598; ///
enum GL_OPERAND0_ALPHA_EXT = 0x8598; ///
enum GL_OPERAND0_RGB = 0x8590; ///
enum GL_OPERAND0_RGB_ARB = 0x8590; ///
enum GL_OPERAND0_RGB_EXT = 0x8590; ///
enum GL_OPERAND1_ALPHA = 0x8599; ///
enum GL_OPERAND1_ALPHA_ARB = 0x8599; ///
enum GL_OPERAND1_ALPHA_EXT = 0x8599; ///
enum GL_OPERAND1_RGB = 0x8591; ///
enum GL_OPERAND1_RGB_ARB = 0x8591; ///
enum GL_OPERAND1_RGB_EXT = 0x8591; ///
enum GL_OPERAND2_ALPHA = 0x859A; ///
enum GL_OPERAND2_ALPHA_ARB = 0x859A; ///
enum GL_OPERAND2_ALPHA_EXT = 0x859A; ///
enum GL_OPERAND2_RGB = 0x8592; ///
enum GL_OPERAND2_RGB_ARB = 0x8592; ///
enum GL_OPERAND2_RGB_EXT = 0x8592; ///
enum GL_OPERAND3_ALPHA_NV = 0x859B; ///
enum GL_OPERAND3_RGB_NV = 0x8593; ///
enum GL_OP_ADD_EXT = 0x8787; ///
enum GL_OP_CLAMP_EXT = 0x878E; ///
enum GL_OP_CROSS_PRODUCT_EXT = 0x8797; ///
enum GL_OP_DOT3_EXT = 0x8784; ///
enum GL_OP_DOT4_EXT = 0x8785; ///
enum GL_OP_EXP_BASE_2_EXT = 0x8791; ///
enum GL_OP_FLOOR_EXT = 0x878F; ///
enum GL_OP_FRAC_EXT = 0x8789; ///
enum GL_OP_INDEX_EXT = 0x8782; ///
enum GL_OP_LOG_BASE_2_EXT = 0x8792; ///
enum GL_OP_MADD_EXT = 0x8788; ///
enum GL_OP_MAX_EXT = 0x878A; ///
enum GL_OP_MIN_EXT = 0x878B; ///
enum GL_OP_MOV_EXT = 0x8799; ///
enum GL_OP_MULTIPLY_MATRIX_EXT = 0x8798; ///
enum GL_OP_MUL_EXT = 0x8786; ///
enum GL_OP_NEGATE_EXT = 0x8783; ///
enum GL_OP_POWER_EXT = 0x8793; ///
enum GL_OP_RECIP_EXT = 0x8794; ///
enum GL_OP_RECIP_SQRT_EXT = 0x8795; ///
enum GL_OP_ROUND_EXT = 0x8790; ///
enum GL_OP_SET_GE_EXT = 0x878C; ///
enum GL_OP_SET_LT_EXT = 0x878D; ///
enum GL_OP_SUB_EXT = 0x8796; ///
enum GL_OR = 0x1507; ///
enum GL_ORDER = 0x0A01; ///
enum GL_OR_INVERTED = 0x150D; ///
enum GL_OR_REVERSE = 0x150B; ///
enum GL_OUTPUT_COLOR0_EXT = 0x879B; ///
enum GL_OUTPUT_COLOR1_EXT = 0x879C; ///
enum GL_OUTPUT_FOG_EXT = 0x87BD; ///
enum GL_OUTPUT_TEXTURE_COORD0_EXT = 0x879D; ///
enum GL_OUTPUT_TEXTURE_COORD10_EXT = 0x87A7; ///
enum GL_OUTPUT_TEXTURE_COORD11_EXT = 0x87A8; ///
enum GL_OUTPUT_TEXTURE_COORD12_EXT = 0x87A9; ///
enum GL_OUTPUT_TEXTURE_COORD13_EXT = 0x87AA; ///
enum GL_OUTPUT_TEXTURE_COORD14_EXT = 0x87AB; ///
enum GL_OUTPUT_TEXTURE_COORD15_EXT = 0x87AC; ///
enum GL_OUTPUT_TEXTURE_COORD16_EXT = 0x87AD; ///
enum GL_OUTPUT_TEXTURE_COORD17_EXT = 0x87AE; ///
enum GL_OUTPUT_TEXTURE_COORD18_EXT = 0x87AF; ///
enum GL_OUTPUT_TEXTURE_COORD19_EXT = 0x87B0; ///
enum GL_OUTPUT_TEXTURE_COORD1_EXT = 0x879E; ///
enum GL_OUTPUT_TEXTURE_COORD20_EXT = 0x87B1; ///
enum GL_OUTPUT_TEXTURE_COORD21_EXT = 0x87B2; ///
enum GL_OUTPUT_TEXTURE_COORD22_EXT = 0x87B3; ///
enum GL_OUTPUT_TEXTURE_COORD23_EXT = 0x87B4; ///
enum GL_OUTPUT_TEXTURE_COORD24_EXT = 0x87B5; ///
enum GL_OUTPUT_TEXTURE_COORD25_EXT = 0x87B6; ///
enum GL_OUTPUT_TEXTURE_COORD26_EXT = 0x87B7; ///
enum GL_OUTPUT_TEXTURE_COORD27_EXT = 0x87B8; ///
enum GL_OUTPUT_TEXTURE_COORD28_EXT = 0x87B9; ///
enum GL_OUTPUT_TEXTURE_COORD29_EXT = 0x87BA; ///
enum GL_OUTPUT_TEXTURE_COORD2_EXT = 0x879F; ///
enum GL_OUTPUT_TEXTURE_COORD30_EXT = 0x87BB; ///
enum GL_OUTPUT_TEXTURE_COORD31_EXT = 0x87BC; ///
enum GL_OUTPUT_TEXTURE_COORD3_EXT = 0x87A0; ///
enum GL_OUTPUT_TEXTURE_COORD4_EXT = 0x87A1; ///
enum GL_OUTPUT_TEXTURE_COORD5_EXT = 0x87A2; ///
enum GL_OUTPUT_TEXTURE_COORD6_EXT = 0x87A3; ///
enum GL_OUTPUT_TEXTURE_COORD7_EXT = 0x87A4; ///
enum GL_OUTPUT_TEXTURE_COORD8_EXT = 0x87A5; ///
enum GL_OUTPUT_TEXTURE_COORD9_EXT = 0x87A6; ///
enum GL_OUTPUT_VERTEX_EXT = 0x879A; ///
enum GL_OUT_OF_MEMORY = 0x0505; ///
enum GL_OVERLAY = 0x9296; ///
enum GL_OVERLAY_KHR = 0x9296; ///
enum GL_OVERLAY_NV = 0x9296; ///
enum GL_PACK_ALIGNMENT = 0x0D05; ///
enum GL_PACK_CMYK_HINT_EXT = 0x800E; ///
enum GL_PACK_COMPRESSED_BLOCK_DEPTH = 0x912D; ///
enum GL_PACK_COMPRESSED_BLOCK_HEIGHT = 0x912C; ///
enum GL_PACK_COMPRESSED_BLOCK_SIZE = 0x912E; ///
enum GL_PACK_COMPRESSED_BLOCK_WIDTH = 0x912B; ///
enum GL_PACK_COMPRESSED_SIZE_SGIX = 0x831C; ///
enum GL_PACK_IMAGE_DEPTH_SGIS = 0x8131; ///
enum GL_PACK_IMAGE_HEIGHT = 0x806C; ///
enum GL_PACK_IMAGE_HEIGHT_EXT = 0x806C; ///
enum GL_PACK_INVERT_MESA = 0x8758; ///
enum GL_PACK_LSB_FIRST = 0x0D01; ///
enum GL_PACK_MAX_COMPRESSED_SIZE_SGIX = 0x831B; ///
enum GL_PACK_RESAMPLE_OML = 0x8984; ///
enum GL_PACK_RESAMPLE_SGIX = 0x842E; ///
enum GL_PACK_REVERSE_ROW_ORDER_ANGLE = 0x93A4; ///
enum GL_PACK_ROW_BYTES_APPLE = 0x8A15; ///
enum GL_PACK_ROW_LENGTH = 0x0D02; ///
enum GL_PACK_SKIP_IMAGES = 0x806B; ///
enum GL_PACK_SKIP_IMAGES_EXT = 0x806B; ///
enum GL_PACK_SKIP_PIXELS = 0x0D04; ///
enum GL_PACK_SKIP_ROWS = 0x0D03; ///
enum GL_PACK_SKIP_VOLUMES_SGIS = 0x8130; ///
enum GL_PACK_SUBSAMPLE_RATE_SGIX = 0x85A0; ///
enum GL_PACK_SWAP_BYTES = 0x0D00; ///
enum GL_PALETTE4_R5_G6_B5_OES = 0x8B92; ///
enum GL_PALETTE4_RGB5_A1_OES = 0x8B94; ///
enum GL_PALETTE4_RGB8_OES = 0x8B90; ///
enum GL_PALETTE4_RGBA4_OES = 0x8B93; ///
enum GL_PALETTE4_RGBA8_OES = 0x8B91; ///
enum GL_PALETTE8_R5_G6_B5_OES = 0x8B97; ///
enum GL_PALETTE8_RGB5_A1_OES = 0x8B99; ///
enum GL_PALETTE8_RGB8_OES = 0x8B95; ///
enum GL_PALETTE8_RGBA4_OES = 0x8B98; ///
enum GL_PALETTE8_RGBA8_OES = 0x8B96; ///
enum GL_PARALLEL_ARRAYS_INTEL = 0x83F4; ///
enum GL_PARAMETER_BUFFER_ARB = 0x80EE; ///
enum GL_PARAMETER_BUFFER_BINDING_ARB = 0x80EF; ///
enum GL_PARTIAL_SUCCESS_NV = 0x902E; ///
enum GL_PASS_THROUGH_NV = 0x86E6; ///
enum GL_PASS_THROUGH_TOKEN = 0x0700; ///
enum GL_PATCHES = 0x000E; ///
enum GL_PATCHES_EXT = 0x000E; ///
enum GL_PATCHES_OES = 0x000E; ///
enum GL_PATCH_DEFAULT_INNER_LEVEL = 0x8E73; ///
enum GL_PATCH_DEFAULT_INNER_LEVEL_EXT = 0x8E73; ///
enum GL_PATCH_DEFAULT_OUTER_LEVEL = 0x8E74; ///
enum GL_PATCH_DEFAULT_OUTER_LEVEL_EXT = 0x8E74; ///
enum GL_PATCH_VERTICES = 0x8E72; ///
enum GL_PATCH_VERTICES_EXT = 0x8E72; ///
enum GL_PATCH_VERTICES_OES = 0x8E72; ///
enum GL_PATH_CLIENT_LENGTH_NV = 0x907F; ///
enum GL_PATH_COMMAND_COUNT_NV = 0x909D; ///
enum GL_PATH_COMPUTED_LENGTH_NV = 0x90A0; ///
enum GL_PATH_COORD_COUNT_NV = 0x909E; ///
enum GL_PATH_COVER_DEPTH_FUNC_NV = 0x90BF; ///
enum GL_PATH_DASH_ARRAY_COUNT_NV = 0x909F; ///
enum GL_PATH_DASH_CAPS_NV = 0x907B; ///
enum GL_PATH_DASH_OFFSET_NV = 0x907E; ///
enum GL_PATH_DASH_OFFSET_RESET_NV = 0x90B4; ///
enum GL_PATH_END_CAPS_NV = 0x9076; ///
enum GL_PATH_ERROR_POSITION_NV = 0x90AB; ///
enum GL_PATH_FILL_BOUNDING_BOX_NV = 0x90A1; ///
enum GL_PATH_FILL_COVER_MODE_NV = 0x9082; ///
enum GL_PATH_FILL_MASK_NV = 0x9081; ///
enum GL_PATH_FILL_MODE_NV = 0x9080; ///
enum GL_PATH_FOG_GEN_MODE_NV = 0x90AC; ///
enum GL_PATH_FORMAT_PS_NV = 0x9071; ///
enum GL_PATH_FORMAT_SVG_NV = 0x9070; ///
enum GL_PATH_GEN_COEFF_NV = 0x90B1; ///
enum GL_PATH_GEN_COLOR_FORMAT_NV = 0x90B2; ///
enum GL_PATH_GEN_COMPONENTS_NV = 0x90B3; ///
enum GL_PATH_GEN_MODE_NV = 0x90B0; ///
enum GL_PATH_INITIAL_DASH_CAP_NV = 0x907C; ///
enum GL_PATH_INITIAL_END_CAP_NV = 0x9077; ///
enum GL_PATH_JOIN_STYLE_NV = 0x9079; ///
enum GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV = 0x0D36; ///
enum GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV = 0x0D38; ///
enum GL_PATH_MITER_LIMIT_NV = 0x907A; ///
enum GL_PATH_MODELVIEW_MATRIX_NV = 0x0BA6; ///
enum GL_PATH_MODELVIEW_NV = 0x1700; ///
enum GL_PATH_MODELVIEW_STACK_DEPTH_NV = 0x0BA3; ///
enum GL_PATH_OBJECT_BOUNDING_BOX_NV = 0x908A; ///
enum GL_PATH_PROJECTION_MATRIX_NV = 0x0BA7; ///
enum GL_PATH_PROJECTION_NV = 0x1701; ///
enum GL_PATH_PROJECTION_STACK_DEPTH_NV = 0x0BA4; ///
enum GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV = 0x90BD; ///
enum GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV = 0x90BE; ///
enum GL_PATH_STENCIL_FUNC_NV = 0x90B7; ///
enum GL_PATH_STENCIL_REF_NV = 0x90B8; ///
enum GL_PATH_STENCIL_VALUE_MASK_NV = 0x90B9; ///
enum GL_PATH_STROKE_BOUNDING_BOX_NV = 0x90A2; ///
enum GL_PATH_STROKE_COVER_MODE_NV = 0x9083; ///
enum GL_PATH_STROKE_MASK_NV = 0x9084; ///
enum GL_PATH_STROKE_WIDTH_NV = 0x9075; ///
enum GL_PATH_TERMINAL_DASH_CAP_NV = 0x907D; ///
enum GL_PATH_TERMINAL_END_CAP_NV = 0x9078; ///
enum GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV = 0x84E3; ///
enum GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV = 0x84E4; ///
enum GL_PERCENTAGE_AMD = 0x8BC3; ///
enum GL_PERFMON_GLOBAL_MODE_QCOM = 0x8FA0; ///
enum GL_PERFMON_RESULT_AMD = 0x8BC6; ///
enum GL_PERFMON_RESULT_AVAILABLE_AMD = 0x8BC4; ///
enum GL_PERFMON_RESULT_SIZE_AMD = 0x8BC5; ///
enum GL_PERFORMANCE_MONITOR_AMD = 0x9152; ///
enum GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL = 0x94FC; ///
enum GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL = 0x94FB; ///
enum GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL = 0x94FA; ///
enum GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL = 0x94F8; ///
enum GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL = 0x94F9; ///
enum GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL = 0x94FF; ///
enum GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL = 0x94F1; ///
enum GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL = 0x94F2; ///
enum GL_PERFQUERY_COUNTER_EVENT_INTEL = 0x94F0; ///
enum GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL = 0x94FE; ///
enum GL_PERFQUERY_COUNTER_RAW_INTEL = 0x94F4; ///
enum GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL = 0x94F3; ///
enum GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL = 0x94F5; ///
enum GL_PERFQUERY_DONOT_FLUSH_INTEL = 0x83F9; ///
enum GL_PERFQUERY_FLUSH_INTEL = 0x83FA; ///
enum GL_PERFQUERY_GLOBAL_CONTEXT_INTEL = 0x00000001; ///
enum GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL = 0x9500; ///
enum GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL = 0x94FD; ///
enum GL_PERFQUERY_SINGLE_CONTEXT_INTEL = 0x00000000; ///
enum GL_PERFQUERY_WAIT_INTEL = 0x83FB; ///
enum GL_PERSPECTIVE_CORRECTION_HINT = 0x0C50; ///
enum GL_PERTURB_EXT = 0x85AE; ///
enum GL_PER_STAGE_CONSTANTS_NV = 0x8535; ///
enum GL_PHONG_HINT_WIN = 0x80EB; ///
enum GL_PHONG_WIN = 0x80EA; ///
enum GL_PINLIGHT_NV = 0x92A8; ///
enum GL_PIXEL_BUFFER_BARRIER_BIT = 0x00000080; ///
enum GL_PIXEL_BUFFER_BARRIER_BIT_EXT = 0x00000080; ///
enum GL_PIXEL_COUNTER_BITS_NV = 0x8864; ///
enum GL_PIXEL_COUNT_AVAILABLE_NV = 0x8867; ///
enum GL_PIXEL_COUNT_NV = 0x8866; ///
enum GL_PIXEL_CUBIC_WEIGHT_EXT = 0x8333; ///
enum GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = 0x8355; ///
enum GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS = 0x8354; ///
enum GL_PIXEL_GROUP_COLOR_SGIS = 0x8356; ///
enum GL_PIXEL_MAG_FILTER_EXT = 0x8331; ///
enum GL_PIXEL_MAP_A_TO_A = 0x0C79; ///
enum GL_PIXEL_MAP_A_TO_A_SIZE = 0x0CB9; ///
enum GL_PIXEL_MAP_B_TO_B = 0x0C78; ///
enum GL_PIXEL_MAP_B_TO_B_SIZE = 0x0CB8; ///
enum GL_PIXEL_MAP_G_TO_G = 0x0C77; ///
enum GL_PIXEL_MAP_G_TO_G_SIZE = 0x0CB7; ///
enum GL_PIXEL_MAP_I_TO_A = 0x0C75; ///
enum GL_PIXEL_MAP_I_TO_A_SIZE = 0x0CB5; ///
enum GL_PIXEL_MAP_I_TO_B = 0x0C74; ///
enum GL_PIXEL_MAP_I_TO_B_SIZE = 0x0CB4; ///
enum GL_PIXEL_MAP_I_TO_G = 0x0C73; ///
enum GL_PIXEL_MAP_I_TO_G_SIZE = 0x0CB3; ///
enum GL_PIXEL_MAP_I_TO_I = 0x0C70; ///
enum GL_PIXEL_MAP_I_TO_I_SIZE = 0x0CB0; ///
enum GL_PIXEL_MAP_I_TO_R = 0x0C72; ///
enum GL_PIXEL_MAP_I_TO_R_SIZE = 0x0CB2; ///
enum GL_PIXEL_MAP_R_TO_R = 0x0C76; ///
enum GL_PIXEL_MAP_R_TO_R_SIZE = 0x0CB6; ///
enum GL_PIXEL_MAP_S_TO_S = 0x0C71; ///
enum GL_PIXEL_MAP_S_TO_S_SIZE = 0x0CB1; ///
enum GL_PIXEL_MIN_FILTER_EXT = 0x8332; ///
enum GL_PIXEL_MODE_BIT = 0x00000020; ///
enum GL_PIXEL_PACK_BUFFER = 0x88EB; ///
enum GL_PIXEL_PACK_BUFFER_ARB = 0x88EB; ///
enum GL_PIXEL_PACK_BUFFER_BINDING = 0x88ED; ///
enum GL_PIXEL_PACK_BUFFER_BINDING_ARB = 0x88ED; ///
enum GL_PIXEL_PACK_BUFFER_BINDING_EXT = 0x88ED; ///
enum GL_PIXEL_PACK_BUFFER_EXT = 0x88EB; ///
enum GL_PIXEL_SUBSAMPLE_2424_SGIX = 0x85A3; ///
enum GL_PIXEL_SUBSAMPLE_4242_SGIX = 0x85A4; ///
enum GL_PIXEL_SUBSAMPLE_4444_SGIX = 0x85A2; ///
enum GL_PIXEL_TEXTURE_SGIS = 0x8353; ///
enum GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX = 0x8189; ///
enum GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX = 0x818A; ///
enum GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX = 0x8188; ///
enum GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX = 0x8187; ///
enum GL_PIXEL_TEX_GEN_MODE_SGIX = 0x832B; ///
enum GL_PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184; ///
enum GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186; ///
enum GL_PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185; ///
enum GL_PIXEL_TEX_GEN_SGIX = 0x8139; ///
enum GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX = 0x813E; ///
enum GL_PIXEL_TILE_CACHE_INCREMENT_SGIX = 0x813F; ///
enum GL_PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145; ///
enum GL_PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144; ///
enum GL_PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143; ///
enum GL_PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142; ///
enum GL_PIXEL_TILE_HEIGHT_SGIX = 0x8141; ///
enum GL_PIXEL_TILE_WIDTH_SGIX = 0x8140; ///
enum GL_PIXEL_TRANSFORM_2D_EXT = 0x8330; ///
enum GL_PIXEL_TRANSFORM_2D_MATRIX_EXT = 0x8338; ///
enum GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 0x8336; ///
enum GL_PIXEL_UNPACK_BUFFER = 0x88EC; ///
enum GL_PIXEL_UNPACK_BUFFER_ARB = 0x88EC; ///
enum GL_PIXEL_UNPACK_BUFFER_BINDING = 0x88EF; ///
enum GL_PIXEL_UNPACK_BUFFER_BINDING_ARB = 0x88EF; ///
enum GL_PIXEL_UNPACK_BUFFER_BINDING_EXT = 0x88EF; ///
enum GL_PIXEL_UNPACK_BUFFER_EXT = 0x88EC; ///
enum GL_PLUS_CLAMPED_ALPHA_NV = 0x92B2; ///
enum GL_PLUS_CLAMPED_NV = 0x92B1; ///
enum GL_PLUS_DARKER_NV = 0x9292; ///
enum GL_PLUS_NV = 0x9291; ///
enum GL_PN_TRIANGLES_ATI = 0x87F0; ///
enum GL_PN_TRIANGLES_NORMAL_MODE_ATI = 0x87F3; ///
enum GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI = 0x87F7; ///
enum GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI = 0x87F8; ///
enum GL_PN_TRIANGLES_POINT_MODE_ATI = 0x87F2; ///
enum GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI = 0x87F6; ///
enum GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI = 0x87F5; ///
enum GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 0x87F4; ///
enum GL_POINT = 0x1B00; ///
enum GL_POINTS = 0x0000; ///
enum GL_POINT_BIT = 0x00000002; ///
enum GL_POINT_DISTANCE_ATTENUATION = 0x8129; ///
enum GL_POINT_DISTANCE_ATTENUATION_ARB = 0x8129; ///
enum GL_POINT_FADE_THRESHOLD_SIZE = 0x8128; ///
enum GL_POINT_FADE_THRESHOLD_SIZE_ARB = 0x8128; ///
enum GL_POINT_FADE_THRESHOLD_SIZE_EXT = 0x8128; ///
enum GL_POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128; ///
enum GL_POINT_NV = 0x1B00; ///
enum GL_POINT_SIZE = 0x0B11; ///
enum GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES = 0x8B9F; ///
enum GL_POINT_SIZE_ARRAY_OES = 0x8B9C; ///
enum GL_POINT_SIZE_ARRAY_POINTER_OES = 0x898C; ///
enum GL_POINT_SIZE_ARRAY_STRIDE_OES = 0x898B; ///
enum GL_POINT_SIZE_ARRAY_TYPE_OES = 0x898A; ///
enum GL_POINT_SIZE_GRANULARITY = 0x0B13; ///
enum GL_POINT_SIZE_MAX = 0x8127; ///
enum GL_POINT_SIZE_MAX_ARB = 0x8127; ///
enum GL_POINT_SIZE_MAX_EXT = 0x8127; ///
enum GL_POINT_SIZE_MAX_SGIS = 0x8127; ///
enum GL_POINT_SIZE_MIN = 0x8126; ///
enum GL_POINT_SIZE_MIN_ARB = 0x8126; ///
enum GL_POINT_SIZE_MIN_EXT = 0x8126; ///
enum GL_POINT_SIZE_MIN_SGIS = 0x8126; ///
enum GL_POINT_SIZE_RANGE = 0x0B12; ///
enum GL_POINT_SMOOTH = 0x0B10; ///
enum GL_POINT_SMOOTH_HINT = 0x0C51; ///
enum GL_POINT_SPRITE = 0x8861; ///
enum GL_POINT_SPRITE_ARB = 0x8861; ///
enum GL_POINT_SPRITE_COORD_ORIGIN = 0x8CA0; ///
enum GL_POINT_SPRITE_NV = 0x8861; ///
enum GL_POINT_SPRITE_OES = 0x8861; ///
enum GL_POINT_SPRITE_R_MODE_NV = 0x8863; ///
enum GL_POINT_TOKEN = 0x0701; ///
enum GL_POLYGON = 0x0009; ///
enum GL_POLYGON_BIT = 0x00000008; ///
enum GL_POLYGON_MODE = 0x0B40; ///
enum GL_POLYGON_MODE_NV = 0x0B40; ///
enum GL_POLYGON_OFFSET_BIAS_EXT = 0x8039; ///
enum GL_POLYGON_OFFSET_CLAMP_EXT = 0x8E1B; ///
enum GL_POLYGON_OFFSET_COMMAND_NV = 0x000E; ///
enum GL_POLYGON_OFFSET_EXT = 0x8037; ///
enum GL_POLYGON_OFFSET_FACTOR = 0x8038; ///
enum GL_POLYGON_OFFSET_FACTOR_EXT = 0x8038; ///
enum GL_POLYGON_OFFSET_FILL = 0x8037; ///
enum GL_POLYGON_OFFSET_LINE = 0x2A02; ///
enum GL_POLYGON_OFFSET_LINE_NV = 0x2A02; ///
enum GL_POLYGON_OFFSET_POINT = 0x2A01; ///
enum GL_POLYGON_OFFSET_POINT_NV = 0x2A01; ///
enum GL_POLYGON_OFFSET_UNITS = 0x2A00; ///
enum GL_POLYGON_SMOOTH = 0x0B41; ///
enum GL_POLYGON_SMOOTH_HINT = 0x0C53; ///
enum GL_POLYGON_STIPPLE = 0x0B42; ///
enum GL_POLYGON_STIPPLE_BIT = 0x00000010; ///
enum GL_POLYGON_TOKEN = 0x0703; ///
enum GL_POSITION = 0x1203; ///
enum GL_POST_COLOR_MATRIX_ALPHA_BIAS = 0x80BB; ///
enum GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB; ///
enum GL_POST_COLOR_MATRIX_ALPHA_SCALE = 0x80B7; ///
enum GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7; ///
enum GL_POST_COLOR_MATRIX_BLUE_BIAS = 0x80BA; ///
enum GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA; ///
enum GL_POST_COLOR_MATRIX_BLUE_SCALE = 0x80B6; ///
enum GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6; ///
enum GL_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D2; ///
enum GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2; ///
enum GL_POST_COLOR_MATRIX_GREEN_BIAS = 0x80B9; ///
enum GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9; ///
enum GL_POST_COLOR_MATRIX_GREEN_SCALE = 0x80B5; ///
enum GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5; ///
enum GL_POST_COLOR_MATRIX_RED_BIAS = 0x80B8; ///
enum GL_POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8; ///
enum GL_POST_COLOR_MATRIX_RED_SCALE = 0x80B4; ///
enum GL_POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4; ///
enum GL_POST_CONVOLUTION_ALPHA_BIAS = 0x8023; ///
enum GL_POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023; ///
enum GL_POST_CONVOLUTION_ALPHA_SCALE = 0x801F; ///
enum GL_POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F; ///
enum GL_POST_CONVOLUTION_BLUE_BIAS = 0x8022; ///
enum GL_POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022; ///
enum GL_POST_CONVOLUTION_BLUE_SCALE = 0x801E; ///
enum GL_POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E; ///
enum GL_POST_CONVOLUTION_COLOR_TABLE = 0x80D1; ///
enum GL_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1; ///
enum GL_POST_CONVOLUTION_GREEN_BIAS = 0x8021; ///
enum GL_POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021; ///
enum GL_POST_CONVOLUTION_GREEN_SCALE = 0x801D; ///
enum GL_POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D; ///
enum GL_POST_CONVOLUTION_RED_BIAS = 0x8020; ///
enum GL_POST_CONVOLUTION_RED_BIAS_EXT = 0x8020; ///
enum GL_POST_CONVOLUTION_RED_SCALE = 0x801C; ///
enum GL_POST_CONVOLUTION_RED_SCALE_EXT = 0x801C; ///
enum GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 0x8162; ///
enum GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = 0x817B; ///
enum GL_POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179; ///
enum GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = 0x817C; ///
enum GL_POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A; ///
enum GL_PREFER_DOUBLEBUFFER_HINT_PGI = 0x1A1F8; ///
enum GL_PRESENT_DURATION_NV = 0x8E2B; ///
enum GL_PRESENT_TIME_NV = 0x8E2A; ///
enum GL_PRESERVE_ATI = 0x8762; ///
enum GL_PREVIOUS = 0x8578; ///
enum GL_PREVIOUS_ARB = 0x8578; ///
enum GL_PREVIOUS_EXT = 0x8578; ///
enum GL_PREVIOUS_TEXTURE_INPUT_NV = 0x86E4; ///
enum GL_PRIMARY_COLOR = 0x8577; ///
enum GL_PRIMARY_COLOR_ARB = 0x8577; ///
enum GL_PRIMARY_COLOR_EXT = 0x8577; ///
enum GL_PRIMARY_COLOR_NV = 0x852C; ///
enum GL_PRIMITIVES_GENERATED = 0x8C87; ///
enum GL_PRIMITIVES_GENERATED_EXT = 0x8C87; ///
enum GL_PRIMITIVES_GENERATED_NV = 0x8C87; ///
enum GL_PRIMITIVES_GENERATED_OES = 0x8C87; ///
enum GL_PRIMITIVES_SUBMITTED_ARB = 0x82EF; ///
enum GL_PRIMITIVE_BOUNDING_BOX = 0x92BE; ///
enum GL_PRIMITIVE_BOUNDING_BOX_ARB = 0x92BE; ///
enum GL_PRIMITIVE_BOUNDING_BOX_EXT = 0x92BE; ///
enum GL_PRIMITIVE_BOUNDING_BOX_OES = 0x92BE; ///
enum GL_PRIMITIVE_ID_NV = 0x8C7C; ///
enum GL_PRIMITIVE_RESTART = 0x8F9D; ///
enum GL_PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69; ///
enum GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = 0x8221; ///
enum GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES = 0x8221; ///
enum GL_PRIMITIVE_RESTART_INDEX = 0x8F9E; ///
enum GL_PRIMITIVE_RESTART_INDEX_NV = 0x8559; ///
enum GL_PRIMITIVE_RESTART_NV = 0x8558; ///
enum GL_PROGRAM = 0x82E2; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB = 0x9341; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_NV = 0x9341; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB = 0x9340; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV = 0x9340; ///
enum GL_PROGRAM_ADDRESS_REGISTERS_ARB = 0x88B0; ///
enum GL_PROGRAM_ALU_INSTRUCTIONS_ARB = 0x8805; ///
enum GL_PROGRAM_ATTRIBS_ARB = 0x88AC; ///
enum GL_PROGRAM_ATTRIB_COMPONENTS_NV = 0x8906; ///
enum GL_PROGRAM_BINARY_ANGLE = 0x93A6; ///
enum GL_PROGRAM_BINARY_FORMATS = 0x87FF; ///
enum GL_PROGRAM_BINARY_FORMATS_OES = 0x87FF; ///
enum GL_PROGRAM_BINARY_LENGTH = 0x8741; ///
enum GL_PROGRAM_BINARY_LENGTH_OES = 0x8741; ///
enum GL_PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257; ///
enum GL_PROGRAM_BINDING_ARB = 0x8677; ///
enum GL_PROGRAM_ERROR_POSITION_ARB = 0x864B; ///
enum GL_PROGRAM_ERROR_POSITION_NV = 0x864B; ///
enum GL_PROGRAM_ERROR_STRING_ARB = 0x8874; ///
enum GL_PROGRAM_ERROR_STRING_NV = 0x8874; ///
enum GL_PROGRAM_FORMAT_ARB = 0x8876; ///
enum GL_PROGRAM_FORMAT_ASCII_ARB = 0x8875; ///
enum GL_PROGRAM_INPUT = 0x92E3; ///
enum GL_PROGRAM_INSTRUCTIONS_ARB = 0x88A0; ///
enum GL_PROGRAM_KHR = 0x82E2; ///
enum GL_PROGRAM_LENGTH_ARB = 0x8627; ///
enum GL_PROGRAM_LENGTH_NV = 0x8627; ///
enum GL_PROGRAM_MATRIX_EXT = 0x8E2D; ///
enum GL_PROGRAM_MATRIX_STACK_DEPTH_EXT = 0x8E2F; ///
enum GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 0x88B2; ///
enum GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 0x8808; ///
enum GL_PROGRAM_NATIVE_ATTRIBS_ARB = 0x88AE; ///
enum GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 0x88A2; ///
enum GL_PROGRAM_NATIVE_PARAMETERS_ARB = 0x88AA; ///
enum GL_PROGRAM_NATIVE_TEMPORARIES_ARB = 0x88A6; ///
enum GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 0x880A; ///
enum GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 0x8809; ///
enum GL_PROGRAM_OBJECT_ARB = 0x8B40; ///
enum GL_PROGRAM_OBJECT_EXT = 0x8B40; ///
enum GL_PROGRAM_OUTPUT = 0x92E4; ///
enum GL_PROGRAM_PARAMETERS_ARB = 0x88A8; ///
enum GL_PROGRAM_PARAMETER_NV = 0x8644; ///
enum GL_PROGRAM_PIPELINE = 0x82E4; ///
enum GL_PROGRAM_PIPELINE_BINDING = 0x825A; ///
enum GL_PROGRAM_PIPELINE_BINDING_EXT = 0x825A; ///
enum GL_PROGRAM_PIPELINE_KHR = 0x82E4; ///
enum GL_PROGRAM_PIPELINE_OBJECT_EXT = 0x8A4F; ///
enum GL_PROGRAM_POINT_SIZE = 0x8642; ///
enum GL_PROGRAM_POINT_SIZE_ARB = 0x8642; ///
enum GL_PROGRAM_POINT_SIZE_EXT = 0x8642; ///
enum GL_PROGRAM_RESIDENT_NV = 0x8647; ///
enum GL_PROGRAM_RESULT_COMPONENTS_NV = 0x8907; ///
enum GL_PROGRAM_SEPARABLE = 0x8258; ///
enum GL_PROGRAM_SEPARABLE_EXT = 0x8258; ///
enum GL_PROGRAM_STRING_ARB = 0x8628; ///
enum GL_PROGRAM_STRING_NV = 0x8628; ///
enum GL_PROGRAM_TARGET_NV = 0x8646; ///
enum GL_PROGRAM_TEMPORARIES_ARB = 0x88A4; ///
enum GL_PROGRAM_TEX_INDIRECTIONS_ARB = 0x8807; ///
enum GL_PROGRAM_TEX_INSTRUCTIONS_ARB = 0x8806; ///
enum GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB = 0x88B6; ///
enum GL_PROJECTION = 0x1701; ///
enum GL_PROJECTION_MATRIX = 0x0BA7; ///
enum GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898E; ///
enum GL_PROJECTION_STACK_DEPTH = 0x0BA4; ///
enum GL_PROVOKING_VERTEX = 0x8E4F; ///
enum GL_PROVOKING_VERTEX_EXT = 0x8E4F; ///
enum GL_PROXY_COLOR_TABLE = 0x80D3; ///
enum GL_PROXY_COLOR_TABLE_SGI = 0x80D3; ///
enum GL_PROXY_HISTOGRAM = 0x8025; ///
enum GL_PROXY_HISTOGRAM_EXT = 0x8025; ///
enum GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D5; ///
enum GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D5; ///
enum GL_PROXY_POST_CONVOLUTION_COLOR_TABLE = 0x80D4; ///
enum GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D4; ///
enum GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 0x8163; ///
enum GL_PROXY_TEXTURE_1D = 0x8063; ///
enum GL_PROXY_TEXTURE_1D_ARRAY = 0x8C19; ///
enum GL_PROXY_TEXTURE_1D_ARRAY_EXT = 0x8C19; ///
enum GL_PROXY_TEXTURE_1D_EXT = 0x8063; ///
enum GL_PROXY_TEXTURE_1D_STACK_MESAX = 0x875B; ///
enum GL_PROXY_TEXTURE_2D = 0x8064; ///
enum GL_PROXY_TEXTURE_2D_ARRAY = 0x8C1B; ///
enum GL_PROXY_TEXTURE_2D_ARRAY_EXT = 0x8C1B; ///
enum GL_PROXY_TEXTURE_2D_EXT = 0x8064; ///
enum GL_PROXY_TEXTURE_2D_MULTISAMPLE = 0x9101; ///
enum GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103; ///
enum GL_PROXY_TEXTURE_2D_STACK_MESAX = 0x875C; ///
enum GL_PROXY_TEXTURE_3D = 0x8070; ///
enum GL_PROXY_TEXTURE_3D_EXT = 0x8070; ///
enum GL_PROXY_TEXTURE_4D_SGIS = 0x8135; ///
enum GL_PROXY_TEXTURE_COLOR_TABLE_SGI = 0x80BD; ///
enum GL_PROXY_TEXTURE_CUBE_MAP = 0x851B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_ARB = 0x851B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_ARRAY = 0x900B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x900B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_EXT = 0x851B; ///
enum GL_PROXY_TEXTURE_RECTANGLE = 0x84F7; ///
enum GL_PROXY_TEXTURE_RECTANGLE_ARB = 0x84F7; ///
enum GL_PROXY_TEXTURE_RECTANGLE_NV = 0x84F7; ///
enum GL_PURGEABLE_APPLE = 0x8A1D; ///
enum GL_PURGED_CONTEXT_RESET_NV = 0x92BB; ///
enum GL_Q = 0x2003; ///
enum GL_QUADRATIC_ATTENUATION = 0x1209; ///
enum GL_QUADRATIC_CURVE_TO_NV = 0x0A; ///
enum GL_QUADS = 0x0007; ///
enum GL_QUADS_EXT = 0x0007; ///
enum GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C; ///
enum GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT = 0x8E4C; ///
enum GL_QUADS_OES = 0x0007; ///
enum GL_QUAD_ALPHA4_SGIS = 0x811E; ///
enum GL_QUAD_ALPHA8_SGIS = 0x811F; ///
enum GL_QUAD_INTENSITY4_SGIS = 0x8122; ///
enum GL_QUAD_INTENSITY8_SGIS = 0x8123; ///
enum GL_QUAD_LUMINANCE4_SGIS = 0x8120; ///
enum GL_QUAD_LUMINANCE8_SGIS = 0x8121; ///
enum GL_QUAD_MESH_SUN = 0x8614; ///
enum GL_QUAD_STRIP = 0x0008; ///
enum GL_QUAD_TEXTURE_SELECT_SGIS = 0x8125; ///
enum GL_QUARTER_BIT_ATI = 0x00000010; ///
enum GL_QUERY = 0x82E3; ///
enum GL_QUERY_ALL_EVENT_BITS_AMD = 0xFFFFFFFF; ///
enum GL_QUERY_BUFFER = 0x9192; ///
enum GL_QUERY_BUFFER_AMD = 0x9192; ///
enum GL_QUERY_BUFFER_BARRIER_BIT = 0x00008000; ///
enum GL_QUERY_BUFFER_BINDING = 0x9193; ///
enum GL_QUERY_BUFFER_BINDING_AMD = 0x9193; ///
enum GL_QUERY_BY_REGION_NO_WAIT = 0x8E16; ///
enum GL_QUERY_BY_REGION_NO_WAIT_INVERTED = 0x8E1A; ///
enum GL_QUERY_BY_REGION_NO_WAIT_NV = 0x8E16; ///
enum GL_QUERY_BY_REGION_WAIT = 0x8E15; ///
enum GL_QUERY_BY_REGION_WAIT_INVERTED = 0x8E19; ///
enum GL_QUERY_BY_REGION_WAIT_NV = 0x8E15; ///
enum GL_QUERY_COUNTER_BITS = 0x8864; ///
enum GL_QUERY_COUNTER_BITS_ARB = 0x8864; ///
enum GL_QUERY_COUNTER_BITS_EXT = 0x8864; ///
enum GL_QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD = 0x00000008; ///
enum GL_QUERY_DEPTH_FAIL_EVENT_BIT_AMD = 0x00000002; ///
enum GL_QUERY_DEPTH_PASS_EVENT_BIT_AMD = 0x00000001; ///
enum GL_QUERY_KHR = 0x82E3; ///
enum GL_QUERY_NO_WAIT = 0x8E14; ///
enum GL_QUERY_NO_WAIT_INVERTED = 0x8E18; ///
enum GL_QUERY_NO_WAIT_NV = 0x8E14; ///
enum GL_QUERY_OBJECT_AMD = 0x9153; ///
enum GL_QUERY_OBJECT_EXT = 0x9153; ///
enum GL_QUERY_RESULT = 0x8866; ///
enum GL_QUERY_RESULT_ARB = 0x8866; ///
enum GL_QUERY_RESULT_AVAILABLE = 0x8867; ///
enum GL_QUERY_RESULT_AVAILABLE_ARB = 0x8867; ///
enum GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867; ///
enum GL_QUERY_RESULT_EXT = 0x8866; ///
enum GL_QUERY_RESULT_NO_WAIT = 0x9194; ///
enum GL_QUERY_RESULT_NO_WAIT_AMD = 0x9194; ///
enum GL_QUERY_STENCIL_FAIL_EVENT_BIT_AMD = 0x00000004; ///
enum GL_QUERY_TARGET = 0x82EA; ///
enum GL_QUERY_WAIT = 0x8E13; ///
enum GL_QUERY_WAIT_INVERTED = 0x8E17; ///
enum GL_QUERY_WAIT_NV = 0x8E13; ///
enum GL_R = 0x2002; ///
enum GL_R11F_G11F_B10F = 0x8C3A; ///
enum GL_R11F_G11F_B10F_APPLE = 0x8C3A; ///
enum GL_R11F_G11F_B10F_EXT = 0x8C3A; ///
enum GL_R16 = 0x822A; ///
enum GL_R16F = 0x822D; ///
enum GL_R16F_EXT = 0x822D; ///
enum GL_R16I = 0x8233; ///
enum GL_R16UI = 0x8234; ///
enum GL_R16_EXT = 0x822A; ///
enum GL_R16_SNORM = 0x8F98; ///
enum GL_R16_SNORM_EXT = 0x8F98; ///
enum GL_R1UI_C3F_V3F_SUN = 0x85C6; ///
enum GL_R1UI_C4F_N3F_V3F_SUN = 0x85C8; ///
enum GL_R1UI_C4UB_V3F_SUN = 0x85C5; ///
enum GL_R1UI_N3F_V3F_SUN = 0x85C7; ///
enum GL_R1UI_T2F_C4F_N3F_V3F_SUN = 0x85CB; ///
enum GL_R1UI_T2F_N3F_V3F_SUN = 0x85CA; ///
enum GL_R1UI_T2F_V3F_SUN = 0x85C9; ///
enum GL_R1UI_V3F_SUN = 0x85C4; ///
enum GL_R32F = 0x822E; ///
enum GL_R32F_EXT = 0x822E; ///
enum GL_R32I = 0x8235; ///
enum GL_R32UI = 0x8236; ///
enum GL_R3_G3_B2 = 0x2A10; ///
enum GL_R8 = 0x8229; ///
enum GL_R8I = 0x8231; ///
enum GL_R8UI = 0x8232; ///
enum GL_R8_EXT = 0x8229; ///
enum GL_R8_SNORM = 0x8F94; ///
enum GL_RASTERIZER_DISCARD = 0x8C89; ///
enum GL_RASTERIZER_DISCARD_EXT = 0x8C89; ///
enum GL_RASTERIZER_DISCARD_NV = 0x8C89; ///
enum GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT = 0x932A; ///
enum GL_RASTER_MULTISAMPLE_EXT = 0x9327; ///
enum GL_RASTER_POSITION_UNCLIPPED_IBM = 0x19262; ///
enum GL_RASTER_SAMPLES_EXT = 0x9328; ///
enum GL_READ_BUFFER = 0x0C02; ///
enum GL_READ_BUFFER_EXT = 0x0C02; ///
enum GL_READ_BUFFER_NV = 0x0C02; ///
enum GL_READ_FRAMEBUFFER = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_ANGLE = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_APPLE = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_BINDING = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_ANGLE = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_APPLE = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_EXT = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_NV = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_EXT = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_NV = 0x8CA8; ///
enum GL_READ_ONLY = 0x88B8; ///
enum GL_READ_ONLY_ARB = 0x88B8; ///
enum GL_READ_PIXELS = 0x828C; ///
enum GL_READ_PIXELS_FORMAT = 0x828D; ///
enum GL_READ_PIXELS_TYPE = 0x828E; ///
enum GL_READ_PIXEL_DATA_RANGE_LENGTH_NV = 0x887B; ///
enum GL_READ_PIXEL_DATA_RANGE_NV = 0x8879; ///
enum GL_READ_PIXEL_DATA_RANGE_POINTER_NV = 0x887D; ///
enum GL_READ_WRITE = 0x88BA; ///
enum GL_READ_WRITE_ARB = 0x88BA; ///
enum GL_RECIP_ADD_SIGNED_ALPHA_IMG = 0x8C05; ///
enum GL_RECLAIM_MEMORY_HINT_PGI = 0x1A1FE; ///
enum GL_RECT_NV = 0xF6; ///
enum GL_RED = 0x1903; ///
enum GL_REDUCE = 0x8016; ///
enum GL_REDUCE_EXT = 0x8016; ///
enum GL_RED_BIAS = 0x0D15; ///
enum GL_RED_BITS = 0x0D52; ///
enum GL_RED_BIT_ATI = 0x00000001; ///
enum GL_RED_EXT = 0x1903; ///
enum GL_RED_INTEGER = 0x8D94; ///
enum GL_RED_INTEGER_EXT = 0x8D94; ///
enum GL_RED_MAX_CLAMP_INGR = 0x8564; ///
enum GL_RED_MIN_CLAMP_INGR = 0x8560; ///
enum GL_RED_NV = 0x1903; ///
enum GL_RED_SCALE = 0x0D14; ///
enum GL_RED_SNORM = 0x8F90; ///
enum GL_REFERENCED_BY_COMPUTE_SHADER = 0x930B; ///
enum GL_REFERENCED_BY_FRAGMENT_SHADER = 0x930A; ///
enum GL_REFERENCED_BY_GEOMETRY_SHADER = 0x9309; ///
enum GL_REFERENCED_BY_GEOMETRY_SHADER_EXT = 0x9309; ///
enum GL_REFERENCED_BY_GEOMETRY_SHADER_OES = 0x9309; ///
enum GL_REFERENCED_BY_TESS_CONTROL_SHADER = 0x9307; ///
enum GL_REFERENCED_BY_TESS_CONTROL_SHADER_EXT = 0x9307; ///
enum GL_REFERENCED_BY_TESS_CONTROL_SHADER_OES = 0x9307; ///
enum GL_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x9308; ///
enum GL_REFERENCED_BY_TESS_EVALUATION_SHADER_EXT = 0x9308; ///
enum GL_REFERENCED_BY_TESS_EVALUATION_SHADER_OES = 0x9308; ///
enum GL_REFERENCED_BY_VERTEX_SHADER = 0x9306; ///
enum GL_REFERENCE_PLANE_EQUATION_SGIX = 0x817E; ///
enum GL_REFERENCE_PLANE_SGIX = 0x817D; ///
enum GL_REFLECTION_MAP = 0x8512; ///
enum GL_REFLECTION_MAP_ARB = 0x8512; ///
enum GL_REFLECTION_MAP_EXT = 0x8512; ///
enum GL_REFLECTION_MAP_NV = 0x8512; ///
enum GL_REFLECTION_MAP_OES = 0x8512; ///
enum GL_REGISTER_COMBINERS_NV = 0x8522; ///
enum GL_REG_0_ATI = 0x8921; ///
enum GL_REG_10_ATI = 0x892B; ///
enum GL_REG_11_ATI = 0x892C; ///
enum GL_REG_12_ATI = 0x892D; ///
enum GL_REG_13_ATI = 0x892E; ///
enum GL_REG_14_ATI = 0x892F; ///
enum GL_REG_15_ATI = 0x8930; ///
enum GL_REG_16_ATI = 0x8931; ///
enum GL_REG_17_ATI = 0x8932; ///
enum GL_REG_18_ATI = 0x8933; ///
enum GL_REG_19_ATI = 0x8934; ///
enum GL_REG_1_ATI = 0x8922; ///
enum GL_REG_20_ATI = 0x8935; ///
enum GL_REG_21_ATI = 0x8936; ///
enum GL_REG_22_ATI = 0x8937; ///
enum GL_REG_23_ATI = 0x8938; ///
enum GL_REG_24_ATI = 0x8939; ///
enum GL_REG_25_ATI = 0x893A; ///
enum GL_REG_26_ATI = 0x893B; ///
enum GL_REG_27_ATI = 0x893C; ///
enum GL_REG_28_ATI = 0x893D; ///
enum GL_REG_29_ATI = 0x893E; ///
enum GL_REG_2_ATI = 0x8923; ///
enum GL_REG_30_ATI = 0x893F; ///
enum GL_REG_31_ATI = 0x8940; ///
enum GL_REG_3_ATI = 0x8924; ///
enum GL_REG_4_ATI = 0x8925; ///
enum GL_REG_5_ATI = 0x8926; ///
enum GL_REG_6_ATI = 0x8927; ///
enum GL_REG_7_ATI = 0x8928; ///
enum GL_REG_8_ATI = 0x8929; ///
enum GL_REG_9_ATI = 0x892A; ///
enum GL_RELATIVE_ARC_TO_NV = 0xFF; ///
enum GL_RELATIVE_CONIC_CURVE_TO_NV = 0x1B; ///
enum GL_RELATIVE_CUBIC_CURVE_TO_NV = 0x0D; ///
enum GL_RELATIVE_HORIZONTAL_LINE_TO_NV = 0x07; ///
enum GL_RELATIVE_LARGE_CCW_ARC_TO_NV = 0x17; ///
enum GL_RELATIVE_LARGE_CW_ARC_TO_NV = 0x19; ///
enum GL_RELATIVE_LINE_TO_NV = 0x05; ///
enum GL_RELATIVE_MOVE_TO_NV = 0x03; ///
enum GL_RELATIVE_QUADRATIC_CURVE_TO_NV = 0x0B; ///
enum GL_RELATIVE_RECT_NV = 0xF7; ///
enum GL_RELATIVE_ROUNDED_RECT2_NV = 0xEB; ///
enum GL_RELATIVE_ROUNDED_RECT4_NV = 0xED; ///
enum GL_RELATIVE_ROUNDED_RECT8_NV = 0xEF; ///
enum GL_RELATIVE_ROUNDED_RECT_NV = 0xE9; ///
enum GL_RELATIVE_SMALL_CCW_ARC_TO_NV = 0x13; ///
enum GL_RELATIVE_SMALL_CW_ARC_TO_NV = 0x15; ///
enum GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV = 0x11; ///
enum GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0F; ///
enum GL_RELATIVE_VERTICAL_LINE_TO_NV = 0x09; ///
enum GL_RELEASED_APPLE = 0x8A19; ///
enum GL_RENDER = 0x1C00; ///
enum GL_RENDERBUFFER = 0x8D41; ///
enum GL_RENDERBUFFER_ALPHA_SIZE = 0x8D53; ///
enum GL_RENDERBUFFER_ALPHA_SIZE_EXT = 0x8D53; ///
enum GL_RENDERBUFFER_ALPHA_SIZE_OES = 0x8D53; ///
enum GL_RENDERBUFFER_BINDING = 0x8CA7; ///
enum GL_RENDERBUFFER_BINDING_ANGLE = 0x8CA7; ///
enum GL_RENDERBUFFER_BINDING_EXT = 0x8CA7; ///
enum GL_RENDERBUFFER_BINDING_OES = 0x8CA7; ///
enum GL_RENDERBUFFER_BLUE_SIZE = 0x8D52; ///
enum GL_RENDERBUFFER_BLUE_SIZE_EXT = 0x8D52; ///
enum GL_RENDERBUFFER_BLUE_SIZE_OES = 0x8D52; ///
enum GL_RENDERBUFFER_COLOR_SAMPLES_NV = 0x8E10; ///
enum GL_RENDERBUFFER_COVERAGE_SAMPLES_NV = 0x8CAB; ///
enum GL_RENDERBUFFER_DEPTH_SIZE = 0x8D54; ///
enum GL_RENDERBUFFER_DEPTH_SIZE_EXT = 0x8D54; ///
enum GL_RENDERBUFFER_DEPTH_SIZE_OES = 0x8D54; ///
enum GL_RENDERBUFFER_EXT = 0x8D41; ///
enum GL_RENDERBUFFER_FREE_MEMORY_ATI = 0x87FD; ///
enum GL_RENDERBUFFER_GREEN_SIZE = 0x8D51; ///
enum GL_RENDERBUFFER_GREEN_SIZE_EXT = 0x8D51; ///
enum GL_RENDERBUFFER_GREEN_SIZE_OES = 0x8D51; ///
enum GL_RENDERBUFFER_HEIGHT = 0x8D43; ///
enum GL_RENDERBUFFER_HEIGHT_EXT = 0x8D43; ///
enum GL_RENDERBUFFER_HEIGHT_OES = 0x8D43; ///
enum GL_RENDERBUFFER_INTERNAL_FORMAT = 0x8D44; ///
enum GL_RENDERBUFFER_INTERNAL_FORMAT_EXT = 0x8D44; ///
enum GL_RENDERBUFFER_INTERNAL_FORMAT_OES = 0x8D44; ///
enum GL_RENDERBUFFER_OES = 0x8D41; ///
enum GL_RENDERBUFFER_RED_SIZE = 0x8D50; ///
enum GL_RENDERBUFFER_RED_SIZE_EXT = 0x8D50; ///
enum GL_RENDERBUFFER_RED_SIZE_OES = 0x8D50; ///
enum GL_RENDERBUFFER_SAMPLES = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_ANGLE = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_APPLE = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_EXT = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_IMG = 0x9133; ///
enum GL_RENDERBUFFER_SAMPLES_NV = 0x8CAB; ///
enum GL_RENDERBUFFER_STENCIL_SIZE = 0x8D55; ///
enum GL_RENDERBUFFER_STENCIL_SIZE_EXT = 0x8D55; ///
enum GL_RENDERBUFFER_STENCIL_SIZE_OES = 0x8D55; ///
enum GL_RENDERBUFFER_WIDTH = 0x8D42; ///
enum GL_RENDERBUFFER_WIDTH_EXT = 0x8D42; ///
enum GL_RENDERBUFFER_WIDTH_OES = 0x8D42; ///
enum GL_RENDERER = 0x1F01; ///
enum GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM = 0x8FB3; ///
enum GL_RENDER_MODE = 0x0C40; ///
enum GL_REPEAT = 0x2901; ///
enum GL_REPLACE = 0x1E01; ///
enum GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN = 0x85C3; ///
enum GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN = 0x85C2; ///
enum GL_REPLACEMENT_CODE_ARRAY_SUN = 0x85C0; ///
enum GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN = 0x85C1; ///
enum GL_REPLACEMENT_CODE_SUN = 0x81D8; ///
enum GL_REPLACE_EXT = 0x8062; ///
enum GL_REPLACE_MIDDLE_SUN = 0x0002; ///
enum GL_REPLACE_OLDEST_SUN = 0x0003; ///
enum GL_REPLACE_VALUE_AMD = 0x874B; ///
enum GL_REPLICATE_BORDER = 0x8153; ///
enum GL_REPLICATE_BORDER_HP = 0x8153; ///
enum GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES = 0x8D68; ///
enum GL_RESAMPLE_AVERAGE_OML = 0x8988; ///
enum GL_RESAMPLE_DECIMATE_OML = 0x8989; ///
enum GL_RESAMPLE_DECIMATE_SGIX = 0x8430; ///
enum GL_RESAMPLE_REPLICATE_OML = 0x8986; ///
enum GL_RESAMPLE_REPLICATE_SGIX = 0x8433; ///
enum GL_RESAMPLE_ZERO_FILL_OML = 0x8987; ///
enum GL_RESAMPLE_ZERO_FILL_SGIX = 0x8434; ///
enum GL_RESCALE_NORMAL = 0x803A; ///
enum GL_RESCALE_NORMAL_EXT = 0x803A; ///
enum GL_RESET_NOTIFICATION_STRATEGY = 0x8256; ///
enum GL_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256; ///
enum GL_RESET_NOTIFICATION_STRATEGY_EXT = 0x8256; ///
enum GL_RESET_NOTIFICATION_STRATEGY_KHR = 0x8256; ///
enum GL_RESTART_PATH_NV = 0xF0; ///
enum GL_RESTART_SUN = 0x0001; ///
enum GL_RETAINED_APPLE = 0x8A1B; ///
enum GL_RETURN = 0x0102; ///
enum GL_RG = 0x8227; ///
enum GL_RG16 = 0x822C; ///
enum GL_RG16F = 0x822F; ///
enum GL_RG16F_EXT = 0x822F; ///
enum GL_RG16I = 0x8239; ///
enum GL_RG16UI = 0x823A; ///
enum GL_RG16_EXT = 0x822C; ///
enum GL_RG16_SNORM = 0x8F99; ///
enum GL_RG16_SNORM_EXT = 0x8F99; ///
enum GL_RG32F = 0x8230; ///
enum GL_RG32F_EXT = 0x8230; ///
enum GL_RG32I = 0x823B; ///
enum GL_RG32UI = 0x823C; ///
enum GL_RG8 = 0x822B; ///
enum GL_RG8I = 0x8237; ///
enum GL_RG8UI = 0x8238; ///
enum GL_RG8_EXT = 0x822B; ///
enum GL_RG8_SNORM = 0x8F95; ///
enum GL_RGB = 0x1907; ///
enum GL_RGB10 = 0x8052; ///
enum GL_RGB10_A2 = 0x8059; ///
enum GL_RGB10_A2UI = 0x906F; ///
enum GL_RGB10_A2_EXT = 0x8059; ///
enum GL_RGB10_EXT = 0x8052; ///
enum GL_RGB12 = 0x8053; ///
enum GL_RGB12_EXT = 0x8053; ///
enum GL_RGB16 = 0x8054; ///
enum GL_RGB16F = 0x881B; ///
enum GL_RGB16F_ARB = 0x881B; ///
enum GL_RGB16F_EXT = 0x881B; ///
enum GL_RGB16I = 0x8D89; ///
enum GL_RGB16I_EXT = 0x8D89; ///
enum GL_RGB16UI = 0x8D77; ///
enum GL_RGB16UI_EXT = 0x8D77; ///
enum GL_RGB16_EXT = 0x8054; ///
enum GL_RGB16_SNORM = 0x8F9A; ///
enum GL_RGB16_SNORM_EXT = 0x8F9A; ///
enum GL_RGB2_EXT = 0x804E; ///
enum GL_RGB32F = 0x8815; ///
enum GL_RGB32F_ARB = 0x8815; ///
enum GL_RGB32F_EXT = 0x8815; ///
enum GL_RGB32I = 0x8D83; ///
enum GL_RGB32I_EXT = 0x8D83; ///
enum GL_RGB32UI = 0x8D71; ///
enum GL_RGB32UI_EXT = 0x8D71; ///
enum GL_RGB4 = 0x804F; ///
enum GL_RGB4_EXT = 0x804F; ///
enum GL_RGB4_S3TC = 0x83A1; ///
enum GL_RGB5 = 0x8050; ///
enum GL_RGB565 = 0x8D62; ///
enum GL_RGB565_OES = 0x8D62; ///
enum GL_RGB5_A1 = 0x8057; ///
enum GL_RGB5_A1_EXT = 0x8057; ///
enum GL_RGB5_A1_OES = 0x8057; ///
enum GL_RGB5_EXT = 0x8050; ///
enum GL_RGB8 = 0x8051; ///
enum GL_RGB8I = 0x8D8F; ///
enum GL_RGB8I_EXT = 0x8D8F; ///
enum GL_RGB8UI = 0x8D7D; ///
enum GL_RGB8UI_EXT = 0x8D7D; ///
enum GL_RGB8_EXT = 0x8051; ///
enum GL_RGB8_OES = 0x8051; ///
enum GL_RGB8_SNORM = 0x8F96; ///
enum GL_RGB9_E5 = 0x8C3D; ///
enum GL_RGB9_E5_APPLE = 0x8C3D; ///
enum GL_RGB9_E5_EXT = 0x8C3D; ///
enum GL_RGBA = 0x1908; ///
enum GL_RGBA12 = 0x805A; ///
enum GL_RGBA12_EXT = 0x805A; ///
enum GL_RGBA16 = 0x805B; ///
enum GL_RGBA16F = 0x881A; ///
enum GL_RGBA16F_ARB = 0x881A; ///
enum GL_RGBA16F_EXT = 0x881A; ///
enum GL_RGBA16I = 0x8D88; ///
enum GL_RGBA16I_EXT = 0x8D88; ///
enum GL_RGBA16UI = 0x8D76; ///
enum GL_RGBA16UI_EXT = 0x8D76; ///
enum GL_RGBA16_EXT = 0x805B; ///
enum GL_RGBA16_SNORM = 0x8F9B; ///
enum GL_RGBA16_SNORM_EXT = 0x8F9B; ///
enum GL_RGBA2 = 0x8055; ///
enum GL_RGBA2_EXT = 0x8055; ///
enum GL_RGBA32F = 0x8814; ///
enum GL_RGBA32F_ARB = 0x8814; ///
enum GL_RGBA32F_EXT = 0x8814; ///
enum GL_RGBA32I = 0x8D82; ///
enum GL_RGBA32I_EXT = 0x8D82; ///
enum GL_RGBA32UI = 0x8D70; ///
enum GL_RGBA32UI_EXT = 0x8D70; ///
enum GL_RGBA4 = 0x8056; ///
enum GL_RGBA4_DXT5_S3TC = 0x83A5; ///
enum GL_RGBA4_EXT = 0x8056; ///
enum GL_RGBA4_OES = 0x8056; ///
enum GL_RGBA4_S3TC = 0x83A3; ///
enum GL_RGBA8 = 0x8058; ///
enum GL_RGBA8I = 0x8D8E; ///
enum GL_RGBA8I_EXT = 0x8D8E; ///
enum GL_RGBA8UI = 0x8D7C; ///
enum GL_RGBA8UI_EXT = 0x8D7C; ///
enum GL_RGBA8_EXT = 0x8058; ///
enum GL_RGBA8_OES = 0x8058; ///
enum GL_RGBA8_SNORM = 0x8F97; ///
enum GL_RGBA_DXT5_S3TC = 0x83A4; ///
enum GL_RGBA_FLOAT16_APPLE = 0x881A; ///
enum GL_RGBA_FLOAT16_ATI = 0x881A; ///
enum GL_RGBA_FLOAT32_APPLE = 0x8814; ///
enum GL_RGBA_FLOAT32_ATI = 0x8814; ///
enum GL_RGBA_FLOAT_MODE_ARB = 0x8820; ///
enum GL_RGBA_FLOAT_MODE_ATI = 0x8820; ///
enum GL_RGBA_INTEGER = 0x8D99; ///
enum GL_RGBA_INTEGER_EXT = 0x8D99; ///
enum GL_RGBA_INTEGER_MODE_EXT = 0x8D9E; ///
enum GL_RGBA_MODE = 0x0C31; ///
enum GL_RGBA_S3TC = 0x83A2; ///
enum GL_RGBA_SIGNED_COMPONENTS_EXT = 0x8C3C; ///
enum GL_RGBA_SNORM = 0x8F93; ///
enum GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV = 0x86D9; ///
enum GL_RGB_422_APPLE = 0x8A1F; ///
enum GL_RGB_FLOAT16_APPLE = 0x881B; ///
enum GL_RGB_FLOAT16_ATI = 0x881B; ///
enum GL_RGB_FLOAT32_APPLE = 0x8815; ///
enum GL_RGB_FLOAT32_ATI = 0x8815; ///
enum GL_RGB_INTEGER = 0x8D98; ///
enum GL_RGB_INTEGER_EXT = 0x8D98; ///
enum GL_RGB_RAW_422_APPLE = 0x8A51; ///
enum GL_RGB_S3TC = 0x83A0; ///
enum GL_RGB_SCALE = 0x8573; ///
enum GL_RGB_SCALE_ARB = 0x8573; ///
enum GL_RGB_SCALE_EXT = 0x8573; ///
enum GL_RGB_SNORM = 0x8F92; ///
enum GL_RG_EXT = 0x8227; ///
enum GL_RG_INTEGER = 0x8228; ///
enum GL_RG_SNORM = 0x8F91; ///
enum GL_RIGHT = 0x0407; ///
enum GL_ROUNDED_RECT2_NV = 0xEA; ///
enum GL_ROUNDED_RECT4_NV = 0xEC; ///
enum GL_ROUNDED_RECT8_NV = 0xEE; ///
enum GL_ROUNDED_RECT_NV = 0xE8; ///
enum GL_ROUND_NV = 0x90A4; ///
enum GL_S = 0x2000; ///
enum GL_SAMPLER = 0x82E6; ///
enum GL_SAMPLER_1D = 0x8B5D; ///
enum GL_SAMPLER_1D_ARB = 0x8B5D; ///
enum GL_SAMPLER_1D_ARRAY = 0x8DC0; ///
enum GL_SAMPLER_1D_ARRAY_EXT = 0x8DC0; ///
enum GL_SAMPLER_1D_ARRAY_SHADOW = 0x8DC3; ///
enum GL_SAMPLER_1D_ARRAY_SHADOW_EXT = 0x8DC3; ///
enum GL_SAMPLER_1D_SHADOW = 0x8B61; ///
enum GL_SAMPLER_1D_SHADOW_ARB = 0x8B61; ///
enum GL_SAMPLER_2D = 0x8B5E; ///
enum GL_SAMPLER_2D_ARB = 0x8B5E; ///
enum GL_SAMPLER_2D_ARRAY = 0x8DC1; ///
enum GL_SAMPLER_2D_ARRAY_EXT = 0x8DC1; ///
enum GL_SAMPLER_2D_ARRAY_SHADOW = 0x8DC4; ///
enum GL_SAMPLER_2D_ARRAY_SHADOW_EXT = 0x8DC4; ///
enum GL_SAMPLER_2D_ARRAY_SHADOW_NV = 0x8DC4; ///
enum GL_SAMPLER_2D_MULTISAMPLE = 0x9108; ///
enum GL_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910B; ///
enum GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910B; ///
enum GL_SAMPLER_2D_RECT = 0x8B63; ///
enum GL_SAMPLER_2D_RECT_ARB = 0x8B63; ///
enum GL_SAMPLER_2D_RECT_SHADOW = 0x8B64; ///
enum GL_SAMPLER_2D_RECT_SHADOW_ARB = 0x8B64; ///
enum GL_SAMPLER_2D_SHADOW = 0x8B62; ///
enum GL_SAMPLER_2D_SHADOW_ARB = 0x8B62; ///
enum GL_SAMPLER_2D_SHADOW_EXT = 0x8B62; ///
enum GL_SAMPLER_3D = 0x8B5F; ///
enum GL_SAMPLER_3D_ARB = 0x8B5F; ///
enum GL_SAMPLER_3D_OES = 0x8B5F; ///
enum GL_SAMPLER_BINDING = 0x8919; ///
enum GL_SAMPLER_BUFFER = 0x8DC2; ///
enum GL_SAMPLER_BUFFER_AMD = 0x9001; ///
enum GL_SAMPLER_BUFFER_EXT = 0x8DC2; ///
enum GL_SAMPLER_BUFFER_OES = 0x8DC2; ///
enum GL_SAMPLER_CUBE = 0x8B60; ///
enum GL_SAMPLER_CUBE_ARB = 0x8B60; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW = 0x900D; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB = 0x900D; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT = 0x900D; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES = 0x900D; ///
enum GL_SAMPLER_CUBE_SHADOW = 0x8DC5; ///
enum GL_SAMPLER_CUBE_SHADOW_EXT = 0x8DC5; ///
enum GL_SAMPLER_CUBE_SHADOW_NV = 0x8DC5; ///
enum GL_SAMPLER_EXTERNAL_2D_Y2Y_EXT = 0x8BE7; ///
enum GL_SAMPLER_EXTERNAL_OES = 0x8D66; ///
enum GL_SAMPLER_KHR = 0x82E6; ///
enum GL_SAMPLER_OBJECT_AMD = 0x9155; ///
enum GL_SAMPLER_RENDERBUFFER_NV = 0x8E56; ///
enum GL_SAMPLES = 0x80A9; ///
enum GL_SAMPLES_3DFX = 0x86B4; ///
enum GL_SAMPLES_ARB = 0x80A9; ///
enum GL_SAMPLES_EXT = 0x80A9; ///
enum GL_SAMPLES_PASSED = 0x8914; ///
enum GL_SAMPLES_PASSED_ARB = 0x8914; ///
enum GL_SAMPLES_SGIS = 0x80A9; ///
enum GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_COVERAGE_ARB = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_MASK_EXT = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_ONE = 0x809F; ///
enum GL_SAMPLE_ALPHA_TO_ONE_ARB = 0x809F; ///
enum GL_SAMPLE_ALPHA_TO_ONE_EXT = 0x809F; ///
enum GL_SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F; ///
enum GL_SAMPLE_BUFFERS = 0x80A8; ///
enum GL_SAMPLE_BUFFERS_3DFX = 0x86B3; ///
enum GL_SAMPLE_BUFFERS_ARB = 0x80A8; ///
enum GL_SAMPLE_BUFFERS_EXT = 0x80A8; ///
enum GL_SAMPLE_BUFFERS_SGIS = 0x80A8; ///
enum GL_SAMPLE_COVERAGE = 0x80A0; ///
enum GL_SAMPLE_COVERAGE_ARB = 0x80A0; ///
enum GL_SAMPLE_COVERAGE_INVERT = 0x80AB; ///
enum GL_SAMPLE_COVERAGE_INVERT_ARB = 0x80AB; ///
enum GL_SAMPLE_COVERAGE_VALUE = 0x80AA; ///
enum GL_SAMPLE_COVERAGE_VALUE_ARB = 0x80AA; ///
enum GL_SAMPLE_LOCATION_ARB = 0x8E50; ///
enum GL_SAMPLE_LOCATION_NV = 0x8E50; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB = 0x933F; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV = 0x933F; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB = 0x933E; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV = 0x933E; ///
enum GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB = 0x933D; ///
enum GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV = 0x933D; ///
enum GL_SAMPLE_MASK = 0x8E51; ///
enum GL_SAMPLE_MASK_EXT = 0x80A0; ///
enum GL_SAMPLE_MASK_INVERT_EXT = 0x80AB; ///
enum GL_SAMPLE_MASK_INVERT_SGIS = 0x80AB; ///
enum GL_SAMPLE_MASK_NV = 0x8E51; ///
enum GL_SAMPLE_MASK_SGIS = 0x80A0; ///
enum GL_SAMPLE_MASK_VALUE = 0x8E52; ///
enum GL_SAMPLE_MASK_VALUE_EXT = 0x80AA; ///
enum GL_SAMPLE_MASK_VALUE_NV = 0x8E52; ///
enum GL_SAMPLE_MASK_VALUE_SGIS = 0x80AA; ///
enum GL_SAMPLE_PATTERN_EXT = 0x80AC; ///
enum GL_SAMPLE_PATTERN_SGIS = 0x80AC; ///
enum GL_SAMPLE_POSITION = 0x8E50; ///
enum GL_SAMPLE_POSITION_NV = 0x8E50; ///
enum GL_SAMPLE_SHADING = 0x8C36; ///
enum GL_SAMPLE_SHADING_ARB = 0x8C36; ///
enum GL_SAMPLE_SHADING_OES = 0x8C36; ///
enum GL_SATURATE_BIT_ATI = 0x00000040; ///
enum GL_SCALAR_EXT = 0x87BE; ///
enum GL_SCALEBIAS_HINT_SGIX = 0x8322; ///
enum GL_SCALED_RESOLVE_FASTEST_EXT = 0x90BA; ///
enum GL_SCALED_RESOLVE_NICEST_EXT = 0x90BB; ///
enum GL_SCALE_BY_FOUR_NV = 0x853F; ///
enum GL_SCALE_BY_ONE_HALF_NV = 0x8540; ///
enum GL_SCALE_BY_TWO_NV = 0x853E; ///
enum GL_SCISSOR_BIT = 0x00080000; ///
enum GL_SCISSOR_BOX = 0x0C10; ///
enum GL_SCISSOR_COMMAND_NV = 0x0011; ///
enum GL_SCISSOR_TEST = 0x0C11; ///
enum GL_SCREEN = 0x9295; ///
enum GL_SCREEN_COORDINATES_REND = 0x8490; ///
enum GL_SCREEN_KHR = 0x9295; ///
enum GL_SCREEN_NV = 0x9295; ///
enum GL_SECONDARY_COLOR_ARRAY = 0x845E; ///
enum GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV = 0x8F27; ///
enum GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING = 0x889C; ///
enum GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB = 0x889C; ///
enum GL_SECONDARY_COLOR_ARRAY_EXT = 0x845E; ///
enum GL_SECONDARY_COLOR_ARRAY_LENGTH_NV = 0x8F31; ///
enum GL_SECONDARY_COLOR_ARRAY_LIST_IBM = 0x103077; ///
enum GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM = 0x103087; ///
enum GL_SECONDARY_COLOR_ARRAY_POINTER = 0x845D; ///
enum GL_SECONDARY_COLOR_ARRAY_POINTER_EXT = 0x845D; ///
enum GL_SECONDARY_COLOR_ARRAY_SIZE = 0x845A; ///
enum GL_SECONDARY_COLOR_ARRAY_SIZE_EXT = 0x845A; ///
enum GL_SECONDARY_COLOR_ARRAY_STRIDE = 0x845C; ///
enum GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT = 0x845C; ///
enum GL_SECONDARY_COLOR_ARRAY_TYPE = 0x845B; ///
enum GL_SECONDARY_COLOR_ARRAY_TYPE_EXT = 0x845B; ///
enum GL_SECONDARY_COLOR_NV = 0x852D; ///
enum GL_SECONDARY_INTERPOLATOR_ATI = 0x896D; ///
enum GL_SELECT = 0x1C02; ///
enum GL_SELECTION_BUFFER_POINTER = 0x0DF3; ///
enum GL_SELECTION_BUFFER_SIZE = 0x0DF4; ///
enum GL_SEPARABLE_2D = 0x8012; ///
enum GL_SEPARABLE_2D_EXT = 0x8012; ///
enum GL_SEPARATE_ATTRIBS = 0x8C8D; ///
enum GL_SEPARATE_ATTRIBS_EXT = 0x8C8D; ///
enum GL_SEPARATE_ATTRIBS_NV = 0x8C8D; ///
enum GL_SEPARATE_SPECULAR_COLOR = 0x81FA; ///
enum GL_SEPARATE_SPECULAR_COLOR_EXT = 0x81FA; ///
enum GL_SET = 0x150F; ///
enum GL_SET_AMD = 0x874A; ///
enum GL_SGX_BINARY_IMG = 0x8C0A; ///
enum GL_SGX_PROGRAM_BINARY_IMG = 0x9130; ///
enum GL_SHADER = 0x82E1; ///
enum GL_SHADER_BINARY_DMP = 0x9250; ///
enum GL_SHADER_BINARY_FORMATS = 0x8DF8; ///
enum GL_SHADER_BINARY_VIV = 0x8FC4; ///
enum GL_SHADER_COMPILER = 0x8DFA; ///
enum GL_SHADER_CONSISTENT_NV = 0x86DD; ///
enum GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV = 0x00000010; ///
enum GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020; ///
enum GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT = 0x00000020; ///
enum GL_SHADER_IMAGE_ATOMIC = 0x82A6; ///
enum GL_SHADER_IMAGE_LOAD = 0x82A4; ///
enum GL_SHADER_IMAGE_STORE = 0x82A5; ///
enum GL_SHADER_INCLUDE_ARB = 0x8DAE; ///
enum GL_SHADER_KHR = 0x82E1; ///
enum GL_SHADER_OBJECT_ARB = 0x8B48; ///
enum GL_SHADER_OBJECT_EXT = 0x8B48; ///
enum GL_SHADER_OPERATION_NV = 0x86DF; ///
enum GL_SHADER_PIXEL_LOCAL_STORAGE_EXT = 0x8F64; ///
enum GL_SHADER_SOURCE_LENGTH = 0x8B88; ///
enum GL_SHADER_STORAGE_BARRIER_BIT = 0x00002000; ///
enum GL_SHADER_STORAGE_BLOCK = 0x92E6; ///
enum GL_SHADER_STORAGE_BUFFER = 0x90D2; ///
enum GL_SHADER_STORAGE_BUFFER_BINDING = 0x90D3; ///
enum GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = 0x90DF; ///
enum GL_SHADER_STORAGE_BUFFER_SIZE = 0x90D5; ///
enum GL_SHADER_STORAGE_BUFFER_START = 0x90D4; ///
enum GL_SHADER_TYPE = 0x8B4F; ///
enum GL_SHADE_MODEL = 0x0B54; ///
enum GL_SHADING_LANGUAGE_VERSION = 0x8B8C; ///
enum GL_SHADING_LANGUAGE_VERSION_ARB = 0x8B8C; ///
enum GL_SHADOW_AMBIENT_SGIX = 0x80BF; ///
enum GL_SHADOW_ATTENUATION_EXT = 0x834E; ///
enum GL_SHARED_EDGE_NV = 0xC0; ///
enum GL_SHARED_TEXTURE_PALETTE_EXT = 0x81FB; ///
enum GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS = 0x80B0; ///
enum GL_SHININESS = 0x1601; ///
enum GL_SHORT = 0x1402; ///
enum GL_SIGNALED = 0x9119; ///
enum GL_SIGNALED_APPLE = 0x9119; ///
enum GL_SIGNED_ALPHA8_NV = 0x8706; ///
enum GL_SIGNED_ALPHA_NV = 0x8705; ///
enum GL_SIGNED_HILO16_NV = 0x86FA; ///
enum GL_SIGNED_HILO8_NV = 0x885F; ///
enum GL_SIGNED_HILO_NV = 0x86F9; ///
enum GL_SIGNED_IDENTITY_NV = 0x853C; ///
enum GL_SIGNED_INTENSITY8_NV = 0x8708; ///
enum GL_SIGNED_INTENSITY_NV = 0x8707; ///
enum GL_SIGNED_LUMINANCE8_ALPHA8_NV = 0x8704; ///
enum GL_SIGNED_LUMINANCE8_NV = 0x8702; ///
enum GL_SIGNED_LUMINANCE_ALPHA_NV = 0x8703; ///
enum GL_SIGNED_LUMINANCE_NV = 0x8701; ///
enum GL_SIGNED_NEGATE_NV = 0x853D; ///
enum GL_SIGNED_NORMALIZED = 0x8F9C; ///
enum GL_SIGNED_RGB8_NV = 0x86FF; ///
enum GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV = 0x870D; ///
enum GL_SIGNED_RGBA8_NV = 0x86FC; ///
enum GL_SIGNED_RGBA_NV = 0x86FB; ///
enum GL_SIGNED_RGB_NV = 0x86FE; ///
enum GL_SIGNED_RGB_UNSIGNED_ALPHA_NV = 0x870C; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = 0x82AC; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = 0x82AE; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = 0x82AD; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = 0x82AF; ///
enum GL_SINGLE_COLOR = 0x81F9; ///
enum GL_SINGLE_COLOR_EXT = 0x81F9; ///
enum GL_SKIP_COMPONENTS1_NV = -6; ///
enum GL_SKIP_COMPONENTS2_NV = -5; ///
enum GL_SKIP_COMPONENTS3_NV = -4; ///
enum GL_SKIP_COMPONENTS4_NV = -3; ///
enum GL_SKIP_DECODE_EXT = 0x8A4A; ///
enum GL_SKIP_MISSING_GLYPH_NV = 0x90A9; ///
enum GL_SLICE_ACCUM_SUN = 0x85CC; ///
enum GL_SLIM10U_SGIX = 0x831E; ///
enum GL_SLIM12S_SGIX = 0x831F; ///
enum GL_SLIM8U_SGIX = 0x831D; ///
enum GL_SLUMINANCE = 0x8C46; ///
enum GL_SLUMINANCE8 = 0x8C47; ///
enum GL_SLUMINANCE8_ALPHA8 = 0x8C45; ///
enum GL_SLUMINANCE8_ALPHA8_EXT = 0x8C45; ///
enum GL_SLUMINANCE8_ALPHA8_NV = 0x8C45; ///
enum GL_SLUMINANCE8_EXT = 0x8C47; ///
enum GL_SLUMINANCE8_NV = 0x8C47; ///
enum GL_SLUMINANCE_ALPHA = 0x8C44; ///
enum GL_SLUMINANCE_ALPHA_EXT = 0x8C44; ///
enum GL_SLUMINANCE_ALPHA_NV = 0x8C44; ///
enum GL_SLUMINANCE_EXT = 0x8C46; ///
enum GL_SLUMINANCE_NV = 0x8C46; ///
enum GL_SMALL_CCW_ARC_TO_NV = 0x12; ///
enum GL_SMALL_CW_ARC_TO_NV = 0x14; ///
enum GL_SMAPHS30_PROGRAM_BINARY_DMP = 0x9251; ///
enum GL_SMAPHS_PROGRAM_BINARY_DMP = 0x9252; ///
enum GL_SMOOTH = 0x1D01; ///
enum GL_SMOOTH_CUBIC_CURVE_TO_NV = 0x10; ///
enum GL_SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23; ///
enum GL_SMOOTH_LINE_WIDTH_RANGE = 0x0B22; ///
enum GL_SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13; ///
enum GL_SMOOTH_POINT_SIZE_RANGE = 0x0B12; ///
enum GL_SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0E; ///
enum GL_SM_COUNT_NV = 0x933B; ///
enum GL_SOFTLIGHT = 0x929C; ///
enum GL_SOFTLIGHT_KHR = 0x929C; ///
enum GL_SOFTLIGHT_NV = 0x929C; ///
enum GL_SOURCE0_ALPHA = 0x8588; ///
enum GL_SOURCE0_ALPHA_ARB = 0x8588; ///
enum GL_SOURCE0_ALPHA_EXT = 0x8588; ///
enum GL_SOURCE0_RGB = 0x8580; ///
enum GL_SOURCE0_RGB_ARB = 0x8580; ///
enum GL_SOURCE0_RGB_EXT = 0x8580; ///
enum GL_SOURCE1_ALPHA = 0x8589; ///
enum GL_SOURCE1_ALPHA_ARB = 0x8589; ///
enum GL_SOURCE1_ALPHA_EXT = 0x8589; ///
enum GL_SOURCE1_RGB = 0x8581; ///
enum GL_SOURCE1_RGB_ARB = 0x8581; ///
enum GL_SOURCE1_RGB_EXT = 0x8581; ///
enum GL_SOURCE2_ALPHA = 0x858A; ///
enum GL_SOURCE2_ALPHA_ARB = 0x858A; ///
enum GL_SOURCE2_ALPHA_EXT = 0x858A; ///
enum GL_SOURCE2_RGB = 0x8582; ///
enum GL_SOURCE2_RGB_ARB = 0x8582; ///
enum GL_SOURCE2_RGB_EXT = 0x8582; ///
enum GL_SOURCE3_ALPHA_NV = 0x858B; ///
enum GL_SOURCE3_RGB_NV = 0x8583; ///
enum GL_SPARE0_NV = 0x852E; ///
enum GL_SPARE0_PLUS_SECONDARY_COLOR_NV = 0x8532; ///
enum GL_SPARE1_NV = 0x852F; ///
enum GL_SPARSE_BUFFER_PAGE_SIZE_ARB = 0x82F8; ///
enum GL_SPARSE_STORAGE_BIT_ARB = 0x0400; ///
enum GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB = 0x91A9; ///
enum GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT = 0x91A9; ///
enum GL_SPECULAR = 0x1202; ///
enum GL_SPHERE_MAP = 0x2402; ///
enum GL_SPOT_CUTOFF = 0x1206; ///
enum GL_SPOT_DIRECTION = 0x1204; ///
enum GL_SPOT_EXPONENT = 0x1205; ///
enum GL_SPRITE_AXIAL_SGIX = 0x814C; ///
enum GL_SPRITE_AXIS_SGIX = 0x814A; ///
enum GL_SPRITE_EYE_ALIGNED_SGIX = 0x814E; ///
enum GL_SPRITE_MODE_SGIX = 0x8149; ///
enum GL_SPRITE_OBJECT_ALIGNED_SGIX = 0x814D; ///
enum GL_SPRITE_SGIX = 0x8148; ///
enum GL_SPRITE_TRANSLATION_SGIX = 0x814B; ///
enum GL_SQUARE_NV = 0x90A3; ///
enum GL_SR8_EXT = 0x8FBD; ///
enum GL_SRC0_ALPHA = 0x8588; ///
enum GL_SRC0_RGB = 0x8580; ///
enum GL_SRC1_ALPHA = 0x8589; ///
enum GL_SRC1_ALPHA_EXT = 0x8589; ///
enum GL_SRC1_COLOR = 0x88F9; ///
enum GL_SRC1_COLOR_EXT = 0x88F9; ///
enum GL_SRC1_RGB = 0x8581; ///
enum GL_SRC2_ALPHA = 0x858A; ///
enum GL_SRC2_RGB = 0x8582; ///
enum GL_SRC_ALPHA = 0x0302; ///
enum GL_SRC_ALPHA_SATURATE = 0x0308; ///
enum GL_SRC_ALPHA_SATURATE_EXT = 0x0308; ///
enum GL_SRC_ATOP_NV = 0x928E; ///
enum GL_SRC_COLOR = 0x0300; ///
enum GL_SRC_IN_NV = 0x928A; ///
enum GL_SRC_NV = 0x9286; ///
enum GL_SRC_OUT_NV = 0x928C; ///
enum GL_SRC_OVER_NV = 0x9288; ///
enum GL_SRG8_EXT = 0x8FBE; ///
enum GL_SRGB = 0x8C40; ///
enum GL_SRGB8 = 0x8C41; ///
enum GL_SRGB8_ALPHA8 = 0x8C43; ///
enum GL_SRGB8_ALPHA8_EXT = 0x8C43; ///
enum GL_SRGB8_EXT = 0x8C41; ///
enum GL_SRGB8_NV = 0x8C41; ///
enum GL_SRGB_ALPHA = 0x8C42; ///
enum GL_SRGB_ALPHA_EXT = 0x8C42; ///
enum GL_SRGB_DECODE_ARB = 0x8299; ///
enum GL_SRGB_EXT = 0x8C40; ///
enum GL_SRGB_READ = 0x8297; ///
enum GL_SRGB_WRITE = 0x8298; ///
enum GL_STACK_OVERFLOW = 0x0503; ///
enum GL_STACK_OVERFLOW_KHR = 0x0503; ///
enum GL_STACK_UNDERFLOW = 0x0504; ///
enum GL_STACK_UNDERFLOW_KHR = 0x0504; ///
enum GL_STANDARD_FONT_FORMAT_NV = 0x936C; ///
enum GL_STANDARD_FONT_NAME_NV = 0x9072; ///
enum GL_STATE_RESTORE = 0x8BDC; ///
enum GL_STATIC_ATI = 0x8760; ///
enum GL_STATIC_COPY = 0x88E6; ///
enum GL_STATIC_COPY_ARB = 0x88E6; ///
enum GL_STATIC_DRAW = 0x88E4; ///
enum GL_STATIC_DRAW_ARB = 0x88E4; ///
enum GL_STATIC_READ = 0x88E5; ///
enum GL_STATIC_READ_ARB = 0x88E5; ///
enum GL_STATIC_VERTEX_ARRAY_IBM = 0x103061; ///
enum GL_STENCIL = 0x1802; ///
enum GL_STENCIL_ATTACHMENT = 0x8D20; ///
enum GL_STENCIL_ATTACHMENT_EXT = 0x8D20; ///
enum GL_STENCIL_ATTACHMENT_OES = 0x8D20; ///
enum GL_STENCIL_BACK_FAIL = 0x8801; ///
enum GL_STENCIL_BACK_FAIL_ATI = 0x8801; ///
enum GL_STENCIL_BACK_FUNC = 0x8800; ///
enum GL_STENCIL_BACK_FUNC_ATI = 0x8800; ///
enum GL_STENCIL_BACK_OP_VALUE_AMD = 0x874D; ///
enum GL_STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802; ///
enum GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI = 0x8802; ///
enum GL_STENCIL_BACK_PASS_DEPTH_PASS = 0x8803; ///
enum GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI = 0x8803; ///
enum GL_STENCIL_BACK_REF = 0x8CA3; ///
enum GL_STENCIL_BACK_VALUE_MASK = 0x8CA4; ///
enum GL_STENCIL_BACK_WRITEMASK = 0x8CA5; ///
enum GL_STENCIL_BITS = 0x0D57; ///
enum GL_STENCIL_BUFFER_BIT = 0x00000400; ///
enum GL_STENCIL_BUFFER_BIT0_QCOM = 0x00010000; ///
enum GL_STENCIL_BUFFER_BIT1_QCOM = 0x00020000; ///
enum GL_STENCIL_BUFFER_BIT2_QCOM = 0x00040000; ///
enum GL_STENCIL_BUFFER_BIT3_QCOM = 0x00080000; ///
enum GL_STENCIL_BUFFER_BIT4_QCOM = 0x00100000; ///
enum GL_STENCIL_BUFFER_BIT5_QCOM = 0x00200000; ///
enum GL_STENCIL_BUFFER_BIT6_QCOM = 0x00400000; ///
enum GL_STENCIL_BUFFER_BIT7_QCOM = 0x00800000; ///
enum GL_STENCIL_CLEAR_TAG_VALUE_EXT = 0x88F3; ///
enum GL_STENCIL_CLEAR_VALUE = 0x0B91; ///
enum GL_STENCIL_COMPONENTS = 0x8285; ///
enum GL_STENCIL_EXT = 0x1802; ///
enum GL_STENCIL_FAIL = 0x0B94; ///
enum GL_STENCIL_FUNC = 0x0B92; ///
enum GL_STENCIL_INDEX = 0x1901; ///
enum GL_STENCIL_INDEX1 = 0x8D46; ///
enum GL_STENCIL_INDEX16 = 0x8D49; ///
enum GL_STENCIL_INDEX16_EXT = 0x8D49; ///
enum GL_STENCIL_INDEX1_EXT = 0x8D46; ///
enum GL_STENCIL_INDEX1_OES = 0x8D46; ///
enum GL_STENCIL_INDEX4 = 0x8D47; ///
enum GL_STENCIL_INDEX4_EXT = 0x8D47; ///
enum GL_STENCIL_INDEX4_OES = 0x8D47; ///
enum GL_STENCIL_INDEX8 = 0x8D48; ///
enum GL_STENCIL_INDEX8_EXT = 0x8D48; ///
enum GL_STENCIL_INDEX8_OES = 0x8D48; ///
enum GL_STENCIL_INDEX_OES = 0x1901; ///
enum GL_STENCIL_OP_VALUE_AMD = 0x874C; ///
enum GL_STENCIL_PASS_DEPTH_FAIL = 0x0B95; ///
enum GL_STENCIL_PASS_DEPTH_PASS = 0x0B96; ///
enum GL_STENCIL_REF = 0x0B97; ///
enum GL_STENCIL_REF_COMMAND_NV = 0x000C; ///
enum GL_STENCIL_RENDERABLE = 0x8288; ///
enum GL_STENCIL_SAMPLES_NV = 0x932E; ///
enum GL_STENCIL_TAG_BITS_EXT = 0x88F2; ///
enum GL_STENCIL_TEST = 0x0B90; ///
enum GL_STENCIL_TEST_TWO_SIDE_EXT = 0x8910; ///
enum GL_STENCIL_VALUE_MASK = 0x0B93; ///
enum GL_STENCIL_WRITEMASK = 0x0B98; ///
enum GL_STEREO = 0x0C33; ///
enum GL_STORAGE_CACHED_APPLE = 0x85BE; ///
enum GL_STORAGE_CLIENT_APPLE = 0x85B4; ///
enum GL_STORAGE_PRIVATE_APPLE = 0x85BD; ///
enum GL_STORAGE_SHARED_APPLE = 0x85BF; ///
enum GL_STREAM_COPY = 0x88E2; ///
enum GL_STREAM_COPY_ARB = 0x88E2; ///
enum GL_STREAM_DRAW = 0x88E0; ///
enum GL_STREAM_DRAW_ARB = 0x88E0; ///
enum GL_STREAM_RASTERIZATION_AMD = 0x91A0; ///
enum GL_STREAM_READ = 0x88E1; ///
enum GL_STREAM_READ_ARB = 0x88E1; ///
enum GL_STRICT_DEPTHFUNC_HINT_PGI = 0x1A216; ///
enum GL_STRICT_LIGHTING_HINT_PGI = 0x1A217; ///
enum GL_STRICT_SCISSOR_HINT_PGI = 0x1A218; ///
enum GL_SUBPIXEL_BITS = 0x0D50; ///
enum GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV = 0x9347; ///
enum GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV = 0x9348; ///
enum GL_SUBSAMPLE_DISTANCE_AMD = 0x883F; ///
enum GL_SUBTRACT = 0x84E7; ///
enum GL_SUBTRACT_ARB = 0x84E7; ///
enum GL_SUB_ATI = 0x8965; ///
enum GL_SUCCESS_NV = 0x902F; ///
enum GL_SUPERSAMPLE_SCALE_X_NV = 0x9372; ///
enum GL_SUPERSAMPLE_SCALE_Y_NV = 0x9373; ///
enum GL_SURFACE_MAPPED_NV = 0x8700; ///
enum GL_SURFACE_REGISTERED_NV = 0x86FD; ///
enum GL_SURFACE_STATE_NV = 0x86EB; ///
enum GL_SWIZZLE_STQ_ATI = 0x8977; ///
enum GL_SWIZZLE_STQ_DQ_ATI = 0x8979; ///
enum GL_SWIZZLE_STRQ_ATI = 0x897A; ///
enum GL_SWIZZLE_STRQ_DQ_ATI = 0x897B; ///
enum GL_SWIZZLE_STR_ATI = 0x8976; ///
enum GL_SWIZZLE_STR_DR_ATI = 0x8978; ///
enum GL_SYNC_CL_EVENT_ARB = 0x8240; ///
enum GL_SYNC_CL_EVENT_COMPLETE_ARB = 0x8241; ///
enum GL_SYNC_CONDITION = 0x9113; ///
enum GL_SYNC_CONDITION_APPLE = 0x9113; ///
enum GL_SYNC_FENCE = 0x9116; ///
enum GL_SYNC_FENCE_APPLE = 0x9116; ///
enum GL_SYNC_FLAGS = 0x9115; ///
enum GL_SYNC_FLAGS_APPLE = 0x9115; ///
enum GL_SYNC_FLUSH_COMMANDS_BIT = 0x00000001; ///
enum GL_SYNC_FLUSH_COMMANDS_BIT_APPLE = 0x00000001; ///
enum GL_SYNC_GPU_COMMANDS_COMPLETE = 0x9117; ///
enum GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE = 0x9117; ///
enum GL_SYNC_OBJECT_APPLE = 0x8A53; ///
enum GL_SYNC_STATUS = 0x9114; ///
enum GL_SYNC_STATUS_APPLE = 0x9114; ///
enum GL_SYNC_X11_FENCE_EXT = 0x90E1; ///
enum GL_SYSTEM_FONT_NAME_NV = 0x9073; ///
enum GL_T = 0x2001; ///
enum GL_T2F_C3F_V3F = 0x2A2A; ///
enum GL_T2F_C4F_N3F_V3F = 0x2A2C; ///
enum GL_T2F_C4UB_V3F = 0x2A29; ///
enum GL_T2F_IUI_N3F_V2F_EXT = 0x81B3; ///
enum GL_T2F_IUI_N3F_V3F_EXT = 0x81B4; ///
enum GL_T2F_IUI_V2F_EXT = 0x81B1; ///
enum GL_T2F_IUI_V3F_EXT = 0x81B2; ///
enum GL_T2F_N3F_V3F = 0x2A2B; ///
enum GL_T2F_V3F = 0x2A27; ///
enum GL_T4F_C4F_N3F_V4F = 0x2A2D; ///
enum GL_T4F_V4F = 0x2A28; ///
enum GL_TABLE_TOO_LARGE = 0x8031; ///
enum GL_TABLE_TOO_LARGE_EXT = 0x8031; ///
enum GL_TANGENT_ARRAY_EXT = 0x8439; ///
enum GL_TANGENT_ARRAY_POINTER_EXT = 0x8442; ///
enum GL_TANGENT_ARRAY_STRIDE_EXT = 0x843F; ///
enum GL_TANGENT_ARRAY_TYPE_EXT = 0x843E; ///
enum GL_TERMINATE_SEQUENCE_COMMAND_NV = 0x0000; ///
enum GL_TESSELLATION_FACTOR_AMD = 0x9005; ///
enum GL_TESSELLATION_MODE_AMD = 0x9004; ///
enum GL_TESS_CONTROL_OUTPUT_VERTICES = 0x8E75; ///
enum GL_TESS_CONTROL_OUTPUT_VERTICES_EXT = 0x8E75; ///
enum GL_TESS_CONTROL_OUTPUT_VERTICES_OES = 0x8E75; ///
enum GL_TESS_CONTROL_PROGRAM_NV = 0x891E; ///
enum GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV = 0x8C74; ///
enum GL_TESS_CONTROL_SHADER = 0x8E88; ///
enum GL_TESS_CONTROL_SHADER_BIT = 0x00000008; ///
enum GL_TESS_CONTROL_SHADER_BIT_EXT = 0x00000008; ///
enum GL_TESS_CONTROL_SHADER_BIT_OES = 0x00000008; ///
enum GL_TESS_CONTROL_SHADER_EXT = 0x8E88; ///
enum GL_TESS_CONTROL_SHADER_OES = 0x8E88; ///
enum GL_TESS_CONTROL_SHADER_PATCHES_ARB = 0x82F1; ///
enum GL_TESS_CONTROL_SUBROUTINE = 0x92E9; ///
enum GL_TESS_CONTROL_SUBROUTINE_UNIFORM = 0x92EF; ///
enum GL_TESS_CONTROL_TEXTURE = 0x829C; ///
enum GL_TESS_EVALUATION_PROGRAM_NV = 0x891F; ///
enum GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV = 0x8C75; ///
enum GL_TESS_EVALUATION_SHADER = 0x8E87; ///
enum GL_TESS_EVALUATION_SHADER_BIT = 0x00000010; ///
enum GL_TESS_EVALUATION_SHADER_BIT_EXT = 0x00000010; ///
enum GL_TESS_EVALUATION_SHADER_BIT_OES = 0x00000010; ///
enum GL_TESS_EVALUATION_SHADER_EXT = 0x8E87; ///
enum GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB = 0x82F2; ///
enum GL_TESS_EVALUATION_SHADER_OES = 0x8E87; ///
enum GL_TESS_EVALUATION_SUBROUTINE = 0x92EA; ///
enum GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = 0x92F0; ///
enum GL_TESS_EVALUATION_TEXTURE = 0x829D; ///
enum GL_TESS_GEN_MODE = 0x8E76; ///
enum GL_TESS_GEN_MODE_EXT = 0x8E76; ///
enum GL_TESS_GEN_MODE_OES = 0x8E76; ///
enum GL_TESS_GEN_POINT_MODE = 0x8E79; ///
enum GL_TESS_GEN_POINT_MODE_EXT = 0x8E79; ///
enum GL_TESS_GEN_POINT_MODE_OES = 0x8E79; ///
enum GL_TESS_GEN_SPACING = 0x8E77; ///
enum GL_TESS_GEN_SPACING_EXT = 0x8E77; ///
enum GL_TESS_GEN_SPACING_OES = 0x8E77; ///
enum GL_TESS_GEN_VERTEX_ORDER = 0x8E78; ///
enum GL_TESS_GEN_VERTEX_ORDER_EXT = 0x8E78; ///
enum GL_TESS_GEN_VERTEX_ORDER_OES = 0x8E78; ///
enum GL_TEXCOORD1_BIT_PGI = 0x10000000; ///
enum GL_TEXCOORD2_BIT_PGI = 0x20000000; ///
enum GL_TEXCOORD3_BIT_PGI = 0x40000000; ///
enum GL_TEXCOORD4_BIT_PGI = 0x80000000; ///
enum GL_TEXTURE = 0x1702; ///
enum GL_TEXTURE0 = 0x84C0; ///
enum GL_TEXTURE0_ARB = 0x84C0; ///
enum GL_TEXTURE1 = 0x84C1; ///
enum GL_TEXTURE10 = 0x84CA; ///
enum GL_TEXTURE10_ARB = 0x84CA; ///
enum GL_TEXTURE11 = 0x84CB; ///
enum GL_TEXTURE11_ARB = 0x84CB; ///
enum GL_TEXTURE12 = 0x84CC; ///
enum GL_TEXTURE12_ARB = 0x84CC; ///
enum GL_TEXTURE13 = 0x84CD; ///
enum GL_TEXTURE13_ARB = 0x84CD; ///
enum GL_TEXTURE14 = 0x84CE; ///
enum GL_TEXTURE14_ARB = 0x84CE; ///
enum GL_TEXTURE15 = 0x84CF; ///
enum GL_TEXTURE15_ARB = 0x84CF; ///
enum GL_TEXTURE16 = 0x84D0; ///
enum GL_TEXTURE16_ARB = 0x84D0; ///
enum GL_TEXTURE17 = 0x84D1; ///
enum GL_TEXTURE17_ARB = 0x84D1; ///
enum GL_TEXTURE18 = 0x84D2; ///
enum GL_TEXTURE18_ARB = 0x84D2; ///
enum GL_TEXTURE19 = 0x84D3; ///
enum GL_TEXTURE19_ARB = 0x84D3; ///
enum GL_TEXTURE1_ARB = 0x84C1; ///
enum GL_TEXTURE2 = 0x84C2; ///
enum GL_TEXTURE20 = 0x84D4; ///
enum GL_TEXTURE20_ARB = 0x84D4; ///
enum GL_TEXTURE21 = 0x84D5; ///
enum GL_TEXTURE21_ARB = 0x84D5; ///
enum GL_TEXTURE22 = 0x84D6; ///
enum GL_TEXTURE22_ARB = 0x84D6; ///
enum GL_TEXTURE23 = 0x84D7; ///
enum GL_TEXTURE23_ARB = 0x84D7; ///
enum GL_TEXTURE24 = 0x84D8; ///
enum GL_TEXTURE24_ARB = 0x84D8; ///
enum GL_TEXTURE25 = 0x84D9; ///
enum GL_TEXTURE25_ARB = 0x84D9; ///
enum GL_TEXTURE26 = 0x84DA; ///
enum GL_TEXTURE26_ARB = 0x84DA; ///
enum GL_TEXTURE27 = 0x84DB; ///
enum GL_TEXTURE27_ARB = 0x84DB; ///
enum GL_TEXTURE28 = 0x84DC; ///
enum GL_TEXTURE28_ARB = 0x84DC; ///
enum GL_TEXTURE29 = 0x84DD; ///
enum GL_TEXTURE29_ARB = 0x84DD; ///
enum GL_TEXTURE2_ARB = 0x84C2; ///
enum GL_TEXTURE3 = 0x84C3; ///
enum GL_TEXTURE30 = 0x84DE; ///
enum GL_TEXTURE30_ARB = 0x84DE; ///
enum GL_TEXTURE31 = 0x84DF; ///
enum GL_TEXTURE31_ARB = 0x84DF; ///
enum GL_TEXTURE3_ARB = 0x84C3; ///
enum GL_TEXTURE4 = 0x84C4; ///
enum GL_TEXTURE4_ARB = 0x84C4; ///
enum GL_TEXTURE5 = 0x84C5; ///
enum GL_TEXTURE5_ARB = 0x84C5; ///
enum GL_TEXTURE6 = 0x84C6; ///
enum GL_TEXTURE6_ARB = 0x84C6; ///
enum GL_TEXTURE7 = 0x84C7; ///
enum GL_TEXTURE7_ARB = 0x84C7; ///
enum GL_TEXTURE8 = 0x84C8; ///
enum GL_TEXTURE8_ARB = 0x84C8; ///
enum GL_TEXTURE9 = 0x84C9; ///
enum GL_TEXTURE9_ARB = 0x84C9; ///
enum GL_TEXTURE_1D = 0x0DE0; ///
enum GL_TEXTURE_1D_ARRAY = 0x8C18; ///
enum GL_TEXTURE_1D_ARRAY_EXT = 0x8C18; ///
enum GL_TEXTURE_1D_BINDING_EXT = 0x8068; ///
enum GL_TEXTURE_1D_STACK_BINDING_MESAX = 0x875D; ///
enum GL_TEXTURE_1D_STACK_MESAX = 0x8759; ///
enum GL_TEXTURE_2D = 0x0DE1; ///
enum GL_TEXTURE_2D_ARRAY = 0x8C1A; ///
enum GL_TEXTURE_2D_ARRAY_EXT = 0x8C1A; ///
enum GL_TEXTURE_2D_BINDING_EXT = 0x8069; ///
enum GL_TEXTURE_2D_MULTISAMPLE = 0x9100; ///
enum GL_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9102; ///
enum GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES = 0x9102; ///
enum GL_TEXTURE_2D_STACK_BINDING_MESAX = 0x875E; ///
enum GL_TEXTURE_2D_STACK_MESAX = 0x875A; ///
enum GL_TEXTURE_3D = 0x806F; ///
enum GL_TEXTURE_3D_BINDING_EXT = 0x806A; ///
enum GL_TEXTURE_3D_BINDING_OES = 0x806A; ///
enum GL_TEXTURE_3D_EXT = 0x806F; ///
enum GL_TEXTURE_3D_OES = 0x806F; ///
enum GL_TEXTURE_4DSIZE_SGIS = 0x8136; ///
enum GL_TEXTURE_4D_BINDING_SGIS = 0x814F; ///
enum GL_TEXTURE_4D_SGIS = 0x8134; ///
enum GL_TEXTURE_ALPHA_MODULATE_IMG = 0x8C06; ///
enum GL_TEXTURE_ALPHA_SIZE = 0x805F; ///
enum GL_TEXTURE_ALPHA_SIZE_EXT = 0x805F; ///
enum GL_TEXTURE_ALPHA_TYPE = 0x8C13; ///
enum GL_TEXTURE_ALPHA_TYPE_ARB = 0x8C13; ///
enum GL_TEXTURE_APPLICATION_MODE_EXT = 0x834F; ///
enum GL_TEXTURE_BASE_LEVEL = 0x813C; ///
enum GL_TEXTURE_BASE_LEVEL_SGIS = 0x813C; ///
enum GL_TEXTURE_BINDING_1D = 0x8068; ///
enum GL_TEXTURE_BINDING_1D_ARRAY = 0x8C1C; ///
enum GL_TEXTURE_BINDING_1D_ARRAY_EXT = 0x8C1C; ///
enum GL_TEXTURE_BINDING_2D = 0x8069; ///
enum GL_TEXTURE_BINDING_2D_ARRAY = 0x8C1D; ///
enum GL_TEXTURE_BINDING_2D_ARRAY_EXT = 0x8C1D; ///
enum GL_TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104; ///
enum GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105; ///
enum GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES = 0x9105; ///
enum GL_TEXTURE_BINDING_3D = 0x806A; ///
enum GL_TEXTURE_BINDING_3D_OES = 0x806A; ///
enum GL_TEXTURE_BINDING_BUFFER = 0x8C2C; ///
enum GL_TEXTURE_BINDING_BUFFER_ARB = 0x8C2C; ///
enum GL_TEXTURE_BINDING_BUFFER_EXT = 0x8C2C; ///
enum GL_TEXTURE_BINDING_BUFFER_OES = 0x8C2C; ///
enum GL_TEXTURE_BINDING_CUBE_MAP = 0x8514; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARB = 0x8514; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_OES = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_EXT = 0x8514; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_OES = 0x8514; ///
enum GL_TEXTURE_BINDING_EXTERNAL_OES = 0x8D67; ///
enum GL_TEXTURE_BINDING_RECTANGLE = 0x84F6; ///
enum GL_TEXTURE_BINDING_RECTANGLE_ARB = 0x84F6; ///
enum GL_TEXTURE_BINDING_RECTANGLE_NV = 0x84F6; ///
enum GL_TEXTURE_BINDING_RENDERBUFFER_NV = 0x8E53; ///
enum GL_TEXTURE_BIT = 0x00040000; ///
enum GL_TEXTURE_BLUE_SIZE = 0x805E; ///
enum GL_TEXTURE_BLUE_SIZE_EXT = 0x805E; ///
enum GL_TEXTURE_BLUE_TYPE = 0x8C12; ///
enum GL_TEXTURE_BLUE_TYPE_ARB = 0x8C12; ///
enum GL_TEXTURE_BORDER = 0x1005; ///
enum GL_TEXTURE_BORDER_COLOR = 0x1004; ///
enum GL_TEXTURE_BORDER_COLOR_EXT = 0x1004; ///
enum GL_TEXTURE_BORDER_COLOR_NV = 0x1004; ///
enum GL_TEXTURE_BORDER_COLOR_OES = 0x1004; ///
enum GL_TEXTURE_BORDER_VALUES_NV = 0x871A; ///
enum GL_TEXTURE_BUFFER = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_ARB = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_BINDING = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_BINDING_EXT = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_BINDING_OES = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING_OES = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_EXT = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_FORMAT_ARB = 0x8C2E; ///
enum GL_TEXTURE_BUFFER_FORMAT_EXT = 0x8C2E; ///
enum GL_TEXTURE_BUFFER_OES = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_OFFSET = 0x919D; ///
enum GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = 0x919F; ///
enum GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT = 0x919F; ///
enum GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES = 0x919F; ///
enum GL_TEXTURE_BUFFER_OFFSET_EXT = 0x919D; ///
enum GL_TEXTURE_BUFFER_OFFSET_OES = 0x919D; ///
enum GL_TEXTURE_BUFFER_SIZE = 0x919E; ///
enum GL_TEXTURE_BUFFER_SIZE_EXT = 0x919E; ///
enum GL_TEXTURE_BUFFER_SIZE_OES = 0x919E; ///
enum GL_TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171; ///
enum GL_TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176; ///
enum GL_TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172; ///
enum GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175; ///
enum GL_TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173; ///
enum GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174; ///
enum GL_TEXTURE_COLOR_SAMPLES_NV = 0x9046; ///
enum GL_TEXTURE_COLOR_TABLE_SGI = 0x80BC; ///
enum GL_TEXTURE_COLOR_WRITEMASK_SGIS = 0x81EF; ///
enum GL_TEXTURE_COMPARE_FAIL_VALUE_ARB = 0x80BF; ///
enum GL_TEXTURE_COMPARE_FUNC = 0x884D; ///
enum GL_TEXTURE_COMPARE_FUNC_ARB = 0x884D; ///
enum GL_TEXTURE_COMPARE_FUNC_EXT = 0x884D; ///
enum GL_TEXTURE_COMPARE_MODE = 0x884C; ///
enum GL_TEXTURE_COMPARE_MODE_ARB = 0x884C; ///
enum GL_TEXTURE_COMPARE_MODE_EXT = 0x884C; ///
enum GL_TEXTURE_COMPARE_OPERATOR_SGIX = 0x819B; ///
enum GL_TEXTURE_COMPARE_SGIX = 0x819A; ///
enum GL_TEXTURE_COMPONENTS = 0x1003; ///
enum GL_TEXTURE_COMPRESSED = 0x86A1; ///
enum GL_TEXTURE_COMPRESSED_ARB = 0x86A1; ///
enum GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = 0x82B2; ///
enum GL_TEXTURE_COMPRESSED_BLOCK_SIZE = 0x82B3; ///
enum GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = 0x82B1; ///
enum GL_TEXTURE_COMPRESSED_IMAGE_SIZE = 0x86A0; ///
enum GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB = 0x86A0; ///
enum GL_TEXTURE_COMPRESSION_HINT = 0x84EF; ///
enum GL_TEXTURE_COMPRESSION_HINT_ARB = 0x84EF; ///
enum GL_TEXTURE_CONSTANT_DATA_SUNX = 0x81D6; ///
enum GL_TEXTURE_COORD_ARRAY = 0x8078; ///
enum GL_TEXTURE_COORD_ARRAY_ADDRESS_NV = 0x8F25; ///
enum GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING = 0x889A; ///
enum GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB = 0x889A; ///
enum GL_TEXTURE_COORD_ARRAY_COUNT_EXT = 0x808B; ///
enum GL_TEXTURE_COORD_ARRAY_EXT = 0x8078; ///
enum GL_TEXTURE_COORD_ARRAY_LENGTH_NV = 0x8F2F; ///
enum GL_TEXTURE_COORD_ARRAY_LIST_IBM = 0x103074; ///
enum GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM = 0x103084; ///
enum GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F8; ///
enum GL_TEXTURE_COORD_ARRAY_POINTER = 0x8092; ///
enum GL_TEXTURE_COORD_ARRAY_POINTER_EXT = 0x8092; ///
enum GL_TEXTURE_COORD_ARRAY_SIZE = 0x8088; ///
enum GL_TEXTURE_COORD_ARRAY_SIZE_EXT = 0x8088; ///
enum GL_TEXTURE_COORD_ARRAY_STRIDE = 0x808A; ///
enum GL_TEXTURE_COORD_ARRAY_STRIDE_EXT = 0x808A; ///
enum GL_TEXTURE_COORD_ARRAY_TYPE = 0x8089; ///
enum GL_TEXTURE_COORD_ARRAY_TYPE_EXT = 0x8089; ///
enum GL_TEXTURE_COORD_NV = 0x8C79; ///
enum GL_TEXTURE_COVERAGE_SAMPLES_NV = 0x9045; ///
enum GL_TEXTURE_CROP_RECT_OES = 0x8B9D; ///
enum GL_TEXTURE_CUBE_MAP = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_ARB = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY_EXT = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY_OES = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_EXT = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_OES = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_SEAMLESS = 0x884F; ///
enum GL_TEXTURE_DEFORMATION_BIT_SGIX = 0x00000001; ///
enum GL_TEXTURE_DEFORMATION_SGIX = 0x8195; ///
enum GL_TEXTURE_DEPTH = 0x8071; ///
enum GL_TEXTURE_DEPTH_EXT = 0x8071; ///
enum GL_TEXTURE_DEPTH_QCOM = 0x8BD4; ///
enum GL_TEXTURE_DEPTH_SIZE = 0x884A; ///
enum GL_TEXTURE_DEPTH_SIZE_ARB = 0x884A; ///
enum GL_TEXTURE_DEPTH_TYPE = 0x8C16; ///
enum GL_TEXTURE_DEPTH_TYPE_ARB = 0x8C16; ///
enum GL_TEXTURE_DS_SIZE_NV = 0x871D; ///
enum GL_TEXTURE_DT_SIZE_NV = 0x871E; ///
enum GL_TEXTURE_ENV = 0x2300; ///
enum GL_TEXTURE_ENV_BIAS_SGIX = 0x80BE; ///
enum GL_TEXTURE_ENV_COLOR = 0x2201; ///
enum GL_TEXTURE_ENV_MODE = 0x2200; ///
enum GL_TEXTURE_EXTERNAL_OES = 0x8D65; ///
enum GL_TEXTURE_FETCH_BARRIER_BIT = 0x00000008; ///
enum GL_TEXTURE_FETCH_BARRIER_BIT_EXT = 0x00000008; ///
enum GL_TEXTURE_FILTER4_SIZE_SGIS = 0x8147; ///
enum GL_TEXTURE_FILTER_CONTROL = 0x8500; ///
enum GL_TEXTURE_FILTER_CONTROL_EXT = 0x8500; ///
enum GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107; ///
enum GL_TEXTURE_FLOAT_COMPONENTS_NV = 0x888C; ///
enum GL_TEXTURE_FORMAT_QCOM = 0x8BD6; ///
enum GL_TEXTURE_FREE_MEMORY_ATI = 0x87FC; ///
enum GL_TEXTURE_GATHER = 0x82A2; ///
enum GL_TEXTURE_GATHER_SHADOW = 0x82A3; ///
enum GL_TEXTURE_GEN_MODE = 0x2500; ///
enum GL_TEXTURE_GEN_MODE_OES = 0x2500; ///
enum GL_TEXTURE_GEN_Q = 0x0C63; ///
enum GL_TEXTURE_GEN_R = 0x0C62; ///
enum GL_TEXTURE_GEN_S = 0x0C60; ///
enum GL_TEXTURE_GEN_STR_OES = 0x8D60; ///
enum GL_TEXTURE_GEN_T = 0x0C61; ///
enum GL_TEXTURE_GEQUAL_R_SGIX = 0x819D; ///
enum GL_TEXTURE_GREEN_SIZE = 0x805D; ///
enum GL_TEXTURE_GREEN_SIZE_EXT = 0x805D; ///
enum GL_TEXTURE_GREEN_TYPE = 0x8C11; ///
enum GL_TEXTURE_GREEN_TYPE_ARB = 0x8C11; ///
enum GL_TEXTURE_HEIGHT = 0x1001; ///
enum GL_TEXTURE_HEIGHT_QCOM = 0x8BD3; ///
enum GL_TEXTURE_HI_SIZE_NV = 0x871B; ///
enum GL_TEXTURE_IMAGE_FORMAT = 0x828F; ///
enum GL_TEXTURE_IMAGE_TYPE = 0x8290; ///
enum GL_TEXTURE_IMAGE_VALID_QCOM = 0x8BD8; ///
enum GL_TEXTURE_IMMUTABLE_FORMAT = 0x912F; ///
enum GL_TEXTURE_IMMUTABLE_FORMAT_EXT = 0x912F; ///
enum GL_TEXTURE_IMMUTABLE_LEVELS = 0x82DF; ///
enum GL_TEXTURE_INDEX_SIZE_EXT = 0x80ED; ///
enum GL_TEXTURE_INTENSITY_SIZE = 0x8061; ///
enum GL_TEXTURE_INTENSITY_SIZE_EXT = 0x8061; ///
enum GL_TEXTURE_INTENSITY_TYPE = 0x8C15; ///
enum GL_TEXTURE_INTENSITY_TYPE_ARB = 0x8C15; ///
enum GL_TEXTURE_INTERNAL_FORMAT = 0x1003; ///
enum GL_TEXTURE_INTERNAL_FORMAT_QCOM = 0x8BD5; ///
enum GL_TEXTURE_LEQUAL_R_SGIX = 0x819C; ///
enum GL_TEXTURE_LIGHTING_MODE_HP = 0x8167; ///
enum GL_TEXTURE_LIGHT_EXT = 0x8350; ///
enum GL_TEXTURE_LOD_BIAS = 0x8501; ///
enum GL_TEXTURE_LOD_BIAS_EXT = 0x8501; ///
enum GL_TEXTURE_LOD_BIAS_R_SGIX = 0x8190; ///
enum GL_TEXTURE_LOD_BIAS_S_SGIX = 0x818E; ///
enum GL_TEXTURE_LOD_BIAS_T_SGIX = 0x818F; ///
enum GL_TEXTURE_LO_SIZE_NV = 0x871C; ///
enum GL_TEXTURE_LUMINANCE_SIZE = 0x8060; ///
enum GL_TEXTURE_LUMINANCE_SIZE_EXT = 0x8060; ///
enum GL_TEXTURE_LUMINANCE_TYPE = 0x8C14; ///
enum GL_TEXTURE_LUMINANCE_TYPE_ARB = 0x8C14; ///
enum GL_TEXTURE_MAG_FILTER = 0x2800; ///
enum GL_TEXTURE_MAG_SIZE_NV = 0x871F; ///
enum GL_TEXTURE_MATERIAL_FACE_EXT = 0x8351; ///
enum GL_TEXTURE_MATERIAL_PARAMETER_EXT = 0x8352; ///
enum GL_TEXTURE_MATRIX = 0x0BA8; ///
enum GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898F; ///
enum GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE; ///
enum GL_TEXTURE_MAX_CLAMP_R_SGIX = 0x836B; ///
enum GL_TEXTURE_MAX_CLAMP_S_SGIX = 0x8369; ///
enum GL_TEXTURE_MAX_CLAMP_T_SGIX = 0x836A; ///
enum GL_TEXTURE_MAX_LEVEL = 0x813D; ///
enum GL_TEXTURE_MAX_LEVEL_APPLE = 0x813D; ///
enum GL_TEXTURE_MAX_LEVEL_SGIS = 0x813D; ///
enum GL_TEXTURE_MAX_LOD = 0x813B; ///
enum GL_TEXTURE_MAX_LOD_SGIS = 0x813B; ///
enum GL_TEXTURE_MEMORY_LAYOUT_INTEL = 0x83FF; ///
enum GL_TEXTURE_MIN_FILTER = 0x2801; ///
enum GL_TEXTURE_MIN_LOD = 0x813A; ///
enum GL_TEXTURE_MIN_LOD_SGIS = 0x813A; ///
enum GL_TEXTURE_MULTI_BUFFER_HINT_SGIX = 0x812E; ///
enum GL_TEXTURE_NORMAL_EXT = 0x85AF; ///
enum GL_TEXTURE_NUM_LEVELS_QCOM = 0x8BD9; ///
enum GL_TEXTURE_OBJECT_VALID_QCOM = 0x8BDB; ///
enum GL_TEXTURE_POST_SPECULAR_HP = 0x8168; ///
enum GL_TEXTURE_PRE_SPECULAR_HP = 0x8169; ///
enum GL_TEXTURE_PRIORITY = 0x8066; ///
enum GL_TEXTURE_PRIORITY_EXT = 0x8066; ///
enum GL_TEXTURE_PROTECTED_EXT = 0x8BFA; ///
enum GL_TEXTURE_RANGE_LENGTH_APPLE = 0x85B7; ///
enum GL_TEXTURE_RANGE_POINTER_APPLE = 0x85B8; ///
enum GL_TEXTURE_RECTANGLE = 0x84F5; ///
enum GL_TEXTURE_RECTANGLE_ARB = 0x84F5; ///
enum GL_TEXTURE_RECTANGLE_NV = 0x84F5; ///
enum GL_TEXTURE_REDUCTION_MODE_ARB = 0x9366; ///
enum GL_TEXTURE_RED_SIZE = 0x805C; ///
enum GL_TEXTURE_RED_SIZE_EXT = 0x805C; ///
enum GL_TEXTURE_RED_TYPE = 0x8C10; ///
enum GL_TEXTURE_RED_TYPE_ARB = 0x8C10; ///
enum GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV = 0x8E54; ///
enum GL_TEXTURE_RENDERBUFFER_NV = 0x8E55; ///
enum GL_TEXTURE_RESIDENT = 0x8067; ///
enum GL_TEXTURE_RESIDENT_EXT = 0x8067; ///
enum GL_TEXTURE_SAMPLES = 0x9106; ///
enum GL_TEXTURE_SAMPLES_IMG = 0x9136; ///
enum GL_TEXTURE_SHADER_NV = 0x86DE; ///
enum GL_TEXTURE_SHADOW = 0x82A1; ///
enum GL_TEXTURE_SHARED_SIZE = 0x8C3F; ///
enum GL_TEXTURE_SHARED_SIZE_EXT = 0x8C3F; ///
enum GL_TEXTURE_SPARSE_ARB = 0x91A6; ///
enum GL_TEXTURE_SPARSE_EXT = 0x91A6; ///
enum GL_TEXTURE_SRGB_DECODE_EXT = 0x8A48; ///
enum GL_TEXTURE_STACK_DEPTH = 0x0BA5; ///
enum GL_TEXTURE_STENCIL_SIZE = 0x88F1; ///
enum GL_TEXTURE_STENCIL_SIZE_EXT = 0x88F1; ///
enum GL_TEXTURE_STORAGE_HINT_APPLE = 0x85BC; ///
enum GL_TEXTURE_STORAGE_SPARSE_BIT_AMD = 0x00000001; ///
enum GL_TEXTURE_SWIZZLE_A = 0x8E45; ///
enum GL_TEXTURE_SWIZZLE_A_EXT = 0x8E45; ///
enum GL_TEXTURE_SWIZZLE_B = 0x8E44; ///
enum GL_TEXTURE_SWIZZLE_B_EXT = 0x8E44; ///
enum GL_TEXTURE_SWIZZLE_G = 0x8E43; ///
enum GL_TEXTURE_SWIZZLE_G_EXT = 0x8E43; ///
enum GL_TEXTURE_SWIZZLE_R = 0x8E42; ///
enum GL_TEXTURE_SWIZZLE_RGBA = 0x8E46; ///
enum GL_TEXTURE_SWIZZLE_RGBA_EXT = 0x8E46; ///
enum GL_TEXTURE_SWIZZLE_R_EXT = 0x8E42; ///
enum GL_TEXTURE_TARGET = 0x1006; ///
enum GL_TEXTURE_TARGET_QCOM = 0x8BDA; ///
enum GL_TEXTURE_TOO_LARGE_EXT = 0x8065; ///
enum GL_TEXTURE_TYPE_QCOM = 0x8BD7; ///
enum GL_TEXTURE_UNSIGNED_REMAP_MODE_NV = 0x888F; ///
enum GL_TEXTURE_UPDATE_BARRIER_BIT = 0x00000100; ///
enum GL_TEXTURE_UPDATE_BARRIER_BIT_EXT = 0x00000100; ///
enum GL_TEXTURE_USAGE_ANGLE = 0x93A2; ///
enum GL_TEXTURE_VIEW = 0x82B5; ///
enum GL_TEXTURE_VIEW_MIN_LAYER = 0x82DD; ///
enum GL_TEXTURE_VIEW_MIN_LAYER_EXT = 0x82DD; ///
enum GL_TEXTURE_VIEW_MIN_LAYER_OES = 0x82DD; ///
enum GL_TEXTURE_VIEW_MIN_LEVEL = 0x82DB; ///
enum GL_TEXTURE_VIEW_MIN_LEVEL_EXT = 0x82DB; ///
enum GL_TEXTURE_VIEW_MIN_LEVEL_OES = 0x82DB; ///
enum GL_TEXTURE_VIEW_NUM_LAYERS = 0x82DE; ///
enum GL_TEXTURE_VIEW_NUM_LAYERS_EXT = 0x82DE; ///
enum GL_TEXTURE_VIEW_NUM_LAYERS_OES = 0x82DE; ///
enum GL_TEXTURE_VIEW_NUM_LEVELS = 0x82DC; ///
enum GL_TEXTURE_VIEW_NUM_LEVELS_EXT = 0x82DC; ///
enum GL_TEXTURE_VIEW_NUM_LEVELS_OES = 0x82DC; ///
enum GL_TEXTURE_WIDTH = 0x1000; ///
enum GL_TEXTURE_WIDTH_QCOM = 0x8BD2; ///
enum GL_TEXTURE_WRAP_Q_SGIS = 0x8137; ///
enum GL_TEXTURE_WRAP_R = 0x8072; ///
enum GL_TEXTURE_WRAP_R_EXT = 0x8072; ///
enum GL_TEXTURE_WRAP_R_OES = 0x8072; ///
enum GL_TEXTURE_WRAP_S = 0x2802; ///
enum GL_TEXTURE_WRAP_T = 0x2803; ///
enum GL_TEXT_FRAGMENT_SHADER_ATI = 0x8200; ///
enum GL_TIMEOUT_EXPIRED = 0x911B; ///
enum GL_TIMEOUT_EXPIRED_APPLE = 0x911B; ///
enum GL_TIMEOUT_IGNORED = 0xFFFFFFFFFFFFFFFF; ///
enum GL_TIMEOUT_IGNORED_APPLE = 0xFFFFFFFFFFFFFFFF; ///
enum GL_TIMESTAMP = 0x8E28; ///
enum GL_TIMESTAMP_EXT = 0x8E28; ///
enum GL_TIME_ELAPSED = 0x88BF; ///
enum GL_TIME_ELAPSED_EXT = 0x88BF; ///
enum GL_TOP_LEVEL_ARRAY_SIZE = 0x930C; ///
enum GL_TOP_LEVEL_ARRAY_STRIDE = 0x930D; ///
enum GL_TRACE_ALL_BITS_MESA = 0xFFFF; ///
enum GL_TRACE_ARRAYS_BIT_MESA = 0x0004; ///
enum GL_TRACE_ERRORS_BIT_MESA = 0x0020; ///
enum GL_TRACE_MASK_MESA = 0x8755; ///
enum GL_TRACE_NAME_MESA = 0x8756; ///
enum GL_TRACE_OPERATIONS_BIT_MESA = 0x0001; ///
enum GL_TRACE_PIXELS_BIT_MESA = 0x0010; ///
enum GL_TRACE_PRIMITIVES_BIT_MESA = 0x0002; ///
enum GL_TRACE_TEXTURES_BIT_MESA = 0x0008; ///
enum GL_TRACK_MATRIX_NV = 0x8648; ///
enum GL_TRACK_MATRIX_TRANSFORM_NV = 0x8649; ///
enum GL_TRANSFORM_BIT = 0x00001000; ///
enum GL_TRANSFORM_FEEDBACK = 0x8E22; ///
enum GL_TRANSFORM_FEEDBACK_ACTIVE = 0x8E24; ///
enum GL_TRANSFORM_FEEDBACK_ATTRIBS_NV = 0x8C7E; ///
enum GL_TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800; ///
enum GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT = 0x00000800; ///
enum GL_TRANSFORM_FEEDBACK_BINDING = 0x8E25; ///
enum GL_TRANSFORM_FEEDBACK_BINDING_NV = 0x8E25; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV = 0x8E24; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT = 0x8C8F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV = 0x8C8F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_EXT = 0x8C8E; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = 0x934B; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT = 0x8C7F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV = 0x8C7F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_NV = 0x8C8E; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV = 0x8E23; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT = 0x8C85; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV = 0x8C85; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT = 0x8C84; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_START_NV = 0x8C84; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = 0x934C; ///
enum GL_TRANSFORM_FEEDBACK_NV = 0x8E22; ///
enum GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB = 0x82EC; ///
enum GL_TRANSFORM_FEEDBACK_PAUSED = 0x8E23; ///
enum GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88; ///
enum GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT = 0x8C88; ///
enum GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV = 0x8C88; ///
enum GL_TRANSFORM_FEEDBACK_RECORD_NV = 0x8C86; ///
enum GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB = 0x82ED; ///
enum GL_TRANSFORM_FEEDBACK_VARYING = 0x92F4; ///
enum GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83; ///
enum GL_TRANSFORM_FEEDBACK_VARYINGS_EXT = 0x8C83; ///
enum GL_TRANSFORM_FEEDBACK_VARYINGS_NV = 0x8C83; ///
enum GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76; ///
enum GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT = 0x8C76; ///
enum GL_TRANSFORM_HINT_APPLE = 0x85B1; ///
enum GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE = 0x93A0; ///
enum GL_TRANSLATE_2D_NV = 0x9090; ///
enum GL_TRANSLATE_3D_NV = 0x9091; ///
enum GL_TRANSLATE_X_NV = 0x908E; ///
enum GL_TRANSLATE_Y_NV = 0x908F; ///
enum GL_TRANSPOSE_AFFINE_2D_NV = 0x9096; ///
enum GL_TRANSPOSE_AFFINE_3D_NV = 0x9098; ///
enum GL_TRANSPOSE_COLOR_MATRIX = 0x84E6; ///
enum GL_TRANSPOSE_COLOR_MATRIX_ARB = 0x84E6; ///
enum GL_TRANSPOSE_CURRENT_MATRIX_ARB = 0x88B7; ///
enum GL_TRANSPOSE_MODELVIEW_MATRIX = 0x84E3; ///
enum GL_TRANSPOSE_MODELVIEW_MATRIX_ARB = 0x84E3; ///
enum GL_TRANSPOSE_NV = 0x862C; ///
enum GL_TRANSPOSE_PROGRAM_MATRIX_EXT = 0x8E2E; ///
enum GL_TRANSPOSE_PROJECTION_MATRIX = 0x84E4; ///
enum GL_TRANSPOSE_PROJECTION_MATRIX_ARB = 0x84E4; ///
enum GL_TRANSPOSE_TEXTURE_MATRIX = 0x84E5; ///
enum GL_TRANSPOSE_TEXTURE_MATRIX_ARB = 0x84E5; ///
enum GL_TRIANGLES = 0x0004; ///
enum GL_TRIANGLES_ADJACENCY = 0x000C; ///
enum GL_TRIANGLES_ADJACENCY_ARB = 0x000C; ///
enum GL_TRIANGLES_ADJACENCY_EXT = 0x000C; ///
enum GL_TRIANGLES_ADJACENCY_OES = 0x000C; ///
enum GL_TRIANGLE_FAN = 0x0006; ///
enum GL_TRIANGLE_LIST_SUN = 0x81D7; ///
enum GL_TRIANGLE_MESH_SUN = 0x8615; ///
enum GL_TRIANGLE_STRIP = 0x0005; ///
enum GL_TRIANGLE_STRIP_ADJACENCY = 0x000D; ///
enum GL_TRIANGLE_STRIP_ADJACENCY_ARB = 0x000D; ///
enum GL_TRIANGLE_STRIP_ADJACENCY_EXT = 0x000D; ///
enum GL_TRIANGLE_STRIP_ADJACENCY_OES = 0x000D; ///
enum GL_TRIANGULAR_NV = 0x90A5; ///
enum GL_TRUE = 1; ///
enum GL_TYPE = 0x92FA; ///
enum GL_UNCORRELATED_NV = 0x9282; ///
enum GL_UNDEFINED_APPLE = 0x8A1C; ///
enum GL_UNDEFINED_VERTEX = 0x8260; ///
enum GL_UNDEFINED_VERTEX_EXT = 0x8260; ///
enum GL_UNDEFINED_VERTEX_OES = 0x8260; ///
enum GL_UNIFORM = 0x92E1; ///
enum GL_UNIFORM_ADDRESS_COMMAND_NV = 0x000A; ///
enum GL_UNIFORM_ARRAY_STRIDE = 0x8A3C; ///
enum GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA; ///
enum GL_UNIFORM_BARRIER_BIT = 0x00000004; ///
enum GL_UNIFORM_BARRIER_BIT_EXT = 0x00000004; ///
enum GL_UNIFORM_BLOCK = 0x92E2; ///
enum GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42; ///
enum GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43; ///
enum GL_UNIFORM_BLOCK_BINDING = 0x8A3F; ///
enum GL_UNIFORM_BLOCK_DATA_SIZE = 0x8A40; ///
enum GL_UNIFORM_BLOCK_INDEX = 0x8A3A; ///
enum GL_UNIFORM_BLOCK_NAME_LENGTH = 0x8A41; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = 0x90EC; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = 0x8A45; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44; ///
enum GL_UNIFORM_BUFFER = 0x8A11; ///
enum GL_UNIFORM_BUFFER_ADDRESS_NV = 0x936F; ///
enum GL_UNIFORM_BUFFER_BINDING = 0x8A28; ///
enum GL_UNIFORM_BUFFER_BINDING_EXT = 0x8DEF; ///
enum GL_UNIFORM_BUFFER_EXT = 0x8DEE; ///
enum GL_UNIFORM_BUFFER_LENGTH_NV = 0x9370; ///
enum GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34; ///
enum GL_UNIFORM_BUFFER_SIZE = 0x8A2A; ///
enum GL_UNIFORM_BUFFER_START = 0x8A29; ///
enum GL_UNIFORM_BUFFER_UNIFIED_NV = 0x936E; ///
enum GL_UNIFORM_IS_ROW_MAJOR = 0x8A3E; ///
enum GL_UNIFORM_MATRIX_STRIDE = 0x8A3D; ///
enum GL_UNIFORM_NAME_LENGTH = 0x8A39; ///
enum GL_UNIFORM_OFFSET = 0x8A3B; ///
enum GL_UNIFORM_SIZE = 0x8A38; ///
enum GL_UNIFORM_TYPE = 0x8A37; ///
enum GL_UNKNOWN_CONTEXT_RESET = 0x8255; ///
enum GL_UNKNOWN_CONTEXT_RESET_ARB = 0x8255; ///
enum GL_UNKNOWN_CONTEXT_RESET_EXT = 0x8255; ///
enum GL_UNKNOWN_CONTEXT_RESET_KHR = 0x8255; ///
enum GL_UNPACK_ALIGNMENT = 0x0CF5; ///
enum GL_UNPACK_CLIENT_STORAGE_APPLE = 0x85B2; ///
enum GL_UNPACK_CMYK_HINT_EXT = 0x800F; ///
enum GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243; ///
enum GL_UNPACK_COMPRESSED_BLOCK_DEPTH = 0x9129; ///
enum GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128; ///
enum GL_UNPACK_COMPRESSED_BLOCK_SIZE = 0x912A; ///
enum GL_UNPACK_COMPRESSED_BLOCK_WIDTH = 0x9127; ///
enum GL_UNPACK_COMPRESSED_SIZE_SGIX = 0x831A; ///
enum GL_UNPACK_CONSTANT_DATA_SUNX = 0x81D5; ///
enum GL_UNPACK_FLIP_Y_WEBGL = 0x9240; ///
enum GL_UNPACK_IMAGE_DEPTH_SGIS = 0x8133; ///
enum GL_UNPACK_IMAGE_HEIGHT = 0x806E; ///
enum GL_UNPACK_IMAGE_HEIGHT_EXT = 0x806E; ///
enum GL_UNPACK_LSB_FIRST = 0x0CF1; ///
enum GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241; ///
enum GL_UNPACK_RESAMPLE_OML = 0x8985; ///
enum GL_UNPACK_RESAMPLE_SGIX = 0x842F; ///
enum GL_UNPACK_ROW_BYTES_APPLE = 0x8A16; ///
enum GL_UNPACK_ROW_LENGTH = 0x0CF2; ///
enum GL_UNPACK_ROW_LENGTH_EXT = 0x0CF2; ///
enum GL_UNPACK_SKIP_IMAGES = 0x806D; ///
enum GL_UNPACK_SKIP_IMAGES_EXT = 0x806D; ///
enum GL_UNPACK_SKIP_PIXELS = 0x0CF4; ///
enum GL_UNPACK_SKIP_PIXELS_EXT = 0x0CF4; ///
enum GL_UNPACK_SKIP_ROWS = 0x0CF3; ///
enum GL_UNPACK_SKIP_ROWS_EXT = 0x0CF3; ///
enum GL_UNPACK_SKIP_VOLUMES_SGIS = 0x8132; ///
enum GL_UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1; ///
enum GL_UNPACK_SWAP_BYTES = 0x0CF0; ///
enum GL_UNSIGNALED = 0x9118; ///
enum GL_UNSIGNALED_APPLE = 0x9118; ///
enum GL_UNSIGNED_BYTE = 0x1401; ///
enum GL_UNSIGNED_BYTE_2_3_3_REV = 0x8362; ///
enum GL_UNSIGNED_BYTE_2_3_3_REV_EXT = 0x8362; ///
enum GL_UNSIGNED_BYTE_3_3_2 = 0x8032; ///
enum GL_UNSIGNED_BYTE_3_3_2_EXT = 0x8032; ///
enum GL_UNSIGNED_IDENTITY_NV = 0x8536; ///
enum GL_UNSIGNED_INT = 0x1405; ///
enum GL_UNSIGNED_INT16_NV = 0x8FF0; ///
enum GL_UNSIGNED_INT16_VEC2_NV = 0x8FF1; ///
enum GL_UNSIGNED_INT16_VEC3_NV = 0x8FF2; ///
enum GL_UNSIGNED_INT16_VEC4_NV = 0x8FF3; ///
enum GL_UNSIGNED_INT64_AMD = 0x8BC2; ///
enum GL_UNSIGNED_INT64_ARB = 0x140F; ///
enum GL_UNSIGNED_INT64_NV = 0x140F; ///
enum GL_UNSIGNED_INT64_VEC2_ARB = 0x8FF5; ///
enum GL_UNSIGNED_INT64_VEC2_NV = 0x8FF5; ///
enum GL_UNSIGNED_INT64_VEC3_ARB = 0x8FF6; ///
enum GL_UNSIGNED_INT64_VEC3_NV = 0x8FF6; ///
enum GL_UNSIGNED_INT64_VEC4_ARB = 0x8FF7; ///
enum GL_UNSIGNED_INT64_VEC4_NV = 0x8FF7; ///
enum GL_UNSIGNED_INT8_NV = 0x8FEC; ///
enum GL_UNSIGNED_INT8_VEC2_NV = 0x8FED; ///
enum GL_UNSIGNED_INT8_VEC3_NV = 0x8FEE; ///
enum GL_UNSIGNED_INT8_VEC4_NV = 0x8FEF; ///
enum GL_UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B; ///
enum GL_UNSIGNED_INT_10F_11F_11F_REV_APPLE = 0x8C3B; ///
enum GL_UNSIGNED_INT_10F_11F_11F_REV_EXT = 0x8C3B; ///
enum GL_UNSIGNED_INT_10_10_10_2 = 0x8036; ///
enum GL_UNSIGNED_INT_10_10_10_2_EXT = 0x8036; ///
enum GL_UNSIGNED_INT_10_10_10_2_OES = 0x8DF6; ///
enum GL_UNSIGNED_INT_24_8 = 0x84FA; ///
enum GL_UNSIGNED_INT_24_8_EXT = 0x84FA; ///
enum GL_UNSIGNED_INT_24_8_MESA = 0x8751; ///
enum GL_UNSIGNED_INT_24_8_NV = 0x84FA; ///
enum GL_UNSIGNED_INT_24_8_OES = 0x84FA; ///
enum GL_UNSIGNED_INT_2_10_10_10_REV = 0x8368; ///
enum GL_UNSIGNED_INT_2_10_10_10_REV_EXT = 0x8368; ///
enum GL_UNSIGNED_INT_5_9_9_9_REV = 0x8C3E; ///
enum GL_UNSIGNED_INT_5_9_9_9_REV_APPLE = 0x8C3E; ///
enum GL_UNSIGNED_INT_5_9_9_9_REV_EXT = 0x8C3E; ///
enum GL_UNSIGNED_INT_8_24_REV_MESA = 0x8752; ///
enum GL_UNSIGNED_INT_8_8_8_8 = 0x8035; ///
enum GL_UNSIGNED_INT_8_8_8_8_EXT = 0x8035; ///
enum GL_UNSIGNED_INT_8_8_8_8_REV = 0x8367; ///
enum GL_UNSIGNED_INT_8_8_8_8_REV_EXT = 0x8367; ///
enum GL_UNSIGNED_INT_8_8_S8_S8_REV_NV = 0x86DB; ///
enum GL_UNSIGNED_INT_ATOMIC_COUNTER = 0x92DB; ///
enum GL_UNSIGNED_INT_IMAGE_1D = 0x9062; ///
enum GL_UNSIGNED_INT_IMAGE_1D_ARRAY = 0x9068; ///
enum GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT = 0x9068; ///
enum GL_UNSIGNED_INT_IMAGE_1D_EXT = 0x9062; ///
enum GL_UNSIGNED_INT_IMAGE_2D = 0x9063; ///
enum GL_UNSIGNED_INT_IMAGE_2D_ARRAY = 0x9069; ///
enum GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT = 0x9069; ///
enum GL_UNSIGNED_INT_IMAGE_2D_EXT = 0x9063; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x906C; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT = 0x906B; ///
enum GL_UNSIGNED_INT_IMAGE_2D_RECT = 0x9065; ///
enum GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT = 0x9065; ///
enum GL_UNSIGNED_INT_IMAGE_3D = 0x9064; ///
enum GL_UNSIGNED_INT_IMAGE_3D_EXT = 0x9064; ///
enum GL_UNSIGNED_INT_IMAGE_BUFFER = 0x9067; ///
enum GL_UNSIGNED_INT_IMAGE_BUFFER_EXT = 0x9067; ///
enum GL_UNSIGNED_INT_IMAGE_BUFFER_OES = 0x9067; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE = 0x9066; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_EXT = 0x9066; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x906A; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x906A; ///
enum GL_UNSIGNED_INT_S8_S8_8_8_NV = 0x86DA; ///
enum GL_UNSIGNED_INT_SAMPLER_1D = 0x8DD1; ///
enum GL_UNSIGNED_INT_SAMPLER_1D_ARRAY = 0x8DD6; ///
enum GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT = 0x8DD6; ///
enum GL_UNSIGNED_INT_SAMPLER_1D_EXT = 0x8DD1; ///
enum GL_UNSIGNED_INT_SAMPLER_2D = 0x8DD2; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT = 0x8DD7; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_EXT = 0x8DD2; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910D; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_RECT = 0x8DD5; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT = 0x8DD5; ///
enum GL_UNSIGNED_INT_SAMPLER_3D = 0x8DD3; ///
enum GL_UNSIGNED_INT_SAMPLER_3D_EXT = 0x8DD3; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER = 0x8DD8; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD = 0x9003; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT = 0x8DD8; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER_OES = 0x8DD8; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_EXT = 0x8DD4; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV = 0x8E58; ///
enum GL_UNSIGNED_INT_VEC2 = 0x8DC6; ///
enum GL_UNSIGNED_INT_VEC2_EXT = 0x8DC6; ///
enum GL_UNSIGNED_INT_VEC3 = 0x8DC7; ///
enum GL_UNSIGNED_INT_VEC3_EXT = 0x8DC7; ///
enum GL_UNSIGNED_INT_VEC4 = 0x8DC8; ///
enum GL_UNSIGNED_INT_VEC4_EXT = 0x8DC8; ///
enum GL_UNSIGNED_INVERT_NV = 0x8537; ///
enum GL_UNSIGNED_NORMALIZED = 0x8C17; ///
enum GL_UNSIGNED_NORMALIZED_ARB = 0x8C17; ///
enum GL_UNSIGNED_NORMALIZED_EXT = 0x8C17; ///
enum GL_UNSIGNED_SHORT = 0x1403; ///
enum GL_UNSIGNED_SHORT_15_1_MESA = 0x8753; ///
enum GL_UNSIGNED_SHORT_1_15_REV_MESA = 0x8754; ///
enum GL_UNSIGNED_SHORT_1_5_5_5_REV = 0x8366; ///
enum GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT = 0x8366; ///
enum GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_EXT = 0x8033; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_REV = 0x8365; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT = 0x8365; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG = 0x8365; ///
enum GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034; ///
enum GL_UNSIGNED_SHORT_5_5_5_1_EXT = 0x8034; ///
enum GL_UNSIGNED_SHORT_5_6_5 = 0x8363; ///
enum GL_UNSIGNED_SHORT_5_6_5_EXT = 0x8363; ///
enum GL_UNSIGNED_SHORT_5_6_5_REV = 0x8364; ///
enum GL_UNSIGNED_SHORT_5_6_5_REV_EXT = 0x8364; ///
enum GL_UNSIGNED_SHORT_8_8_APPLE = 0x85BA; ///
enum GL_UNSIGNED_SHORT_8_8_MESA = 0x85BA; ///
enum GL_UNSIGNED_SHORT_8_8_REV_APPLE = 0x85BB; ///
enum GL_UNSIGNED_SHORT_8_8_REV_MESA = 0x85BB; ///
enum GL_UPPER_LEFT = 0x8CA2; ///
enum GL_USE_MISSING_GLYPH_NV = 0x90AA; ///
enum GL_UTF16_NV = 0x909B; ///
enum GL_UTF8_NV = 0x909A; ///
enum GL_V2F = 0x2A20; ///
enum GL_V3F = 0x2A21; ///
enum GL_VALIDATE_STATUS = 0x8B83; ///
enum GL_VARIABLE_A_NV = 0x8523; ///
enum GL_VARIABLE_B_NV = 0x8524; ///
enum GL_VARIABLE_C_NV = 0x8525; ///
enum GL_VARIABLE_D_NV = 0x8526; ///
enum GL_VARIABLE_E_NV = 0x8527; ///
enum GL_VARIABLE_F_NV = 0x8528; ///
enum GL_VARIABLE_G_NV = 0x8529; ///
enum GL_VARIANT_ARRAY_EXT = 0x87E8; ///
enum GL_VARIANT_ARRAY_POINTER_EXT = 0x87E9; ///
enum GL_VARIANT_ARRAY_STRIDE_EXT = 0x87E6; ///
enum GL_VARIANT_ARRAY_TYPE_EXT = 0x87E7; ///
enum GL_VARIANT_DATATYPE_EXT = 0x87E5; ///
enum GL_VARIANT_EXT = 0x87C1; ///
enum GL_VARIANT_VALUE_EXT = 0x87E4; ///
enum GL_VBO_FREE_MEMORY_ATI = 0x87FB; ///
enum GL_VECTOR_EXT = 0x87BF; ///
enum GL_VENDOR = 0x1F00; ///
enum GL_VERSION = 0x1F02; ///
enum GL_VERSION_ES_CL_1_0 = 1; ///
enum GL_VERSION_ES_CL_1_1 = 1; ///
enum GL_VERSION_ES_CM_1_1 = 1; ///
enum GL_VERTEX23_BIT_PGI = 0x00000004; ///
enum GL_VERTEX4_BIT_PGI = 0x00000008; ///
enum GL_VERTEX_ARRAY = 0x8074; ///
enum GL_VERTEX_ARRAY_ADDRESS_NV = 0x8F21; ///
enum GL_VERTEX_ARRAY_BINDING = 0x85B5; ///
enum GL_VERTEX_ARRAY_BINDING_APPLE = 0x85B5; ///
enum GL_VERTEX_ARRAY_BINDING_OES = 0x85B5; ///
enum GL_VERTEX_ARRAY_BUFFER_BINDING = 0x8896; ///
enum GL_VERTEX_ARRAY_BUFFER_BINDING_ARB = 0x8896; ///
enum GL_VERTEX_ARRAY_COUNT_EXT = 0x807D; ///
enum GL_VERTEX_ARRAY_EXT = 0x8074; ///
enum GL_VERTEX_ARRAY_KHR = 0x8074; ///
enum GL_VERTEX_ARRAY_LENGTH_NV = 0x8F2B; ///
enum GL_VERTEX_ARRAY_LIST_IBM = 0x103070; ///
enum GL_VERTEX_ARRAY_LIST_STRIDE_IBM = 0x103080; ///
enum GL_VERTEX_ARRAY_OBJECT_AMD = 0x9154; ///
enum GL_VERTEX_ARRAY_OBJECT_EXT = 0x9154; ///
enum GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F5; ///
enum GL_VERTEX_ARRAY_POINTER = 0x808E; ///
enum GL_VERTEX_ARRAY_POINTER_EXT = 0x808E; ///
enum GL_VERTEX_ARRAY_RANGE_APPLE = 0x851D; ///
enum GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE = 0x851E; ///
enum GL_VERTEX_ARRAY_RANGE_LENGTH_NV = 0x851E; ///
enum GL_VERTEX_ARRAY_RANGE_NV = 0x851D; ///
enum GL_VERTEX_ARRAY_RANGE_POINTER_APPLE = 0x8521; ///
enum GL_VERTEX_ARRAY_RANGE_POINTER_NV = 0x8521; ///
enum GL_VERTEX_ARRAY_RANGE_VALID_NV = 0x851F; ///
enum GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV = 0x8533; ///
enum GL_VERTEX_ARRAY_SIZE = 0x807A; ///
enum GL_VERTEX_ARRAY_SIZE_EXT = 0x807A; ///
enum GL_VERTEX_ARRAY_STORAGE_HINT_APPLE = 0x851F; ///
enum GL_VERTEX_ARRAY_STRIDE = 0x807C; ///
enum GL_VERTEX_ARRAY_STRIDE_EXT = 0x807C; ///
enum GL_VERTEX_ARRAY_TYPE = 0x807B; ///
enum GL_VERTEX_ARRAY_TYPE_EXT = 0x807B; ///
enum GL_VERTEX_ATTRIB_ARRAY0_NV = 0x8650; ///
enum GL_VERTEX_ATTRIB_ARRAY10_NV = 0x865A; ///
enum GL_VERTEX_ATTRIB_ARRAY11_NV = 0x865B; ///
enum GL_VERTEX_ATTRIB_ARRAY12_NV = 0x865C; ///
enum GL_VERTEX_ATTRIB_ARRAY13_NV = 0x865D; ///
enum GL_VERTEX_ATTRIB_ARRAY14_NV = 0x865E; ///
enum GL_VERTEX_ATTRIB_ARRAY15_NV = 0x865F; ///
enum GL_VERTEX_ATTRIB_ARRAY1_NV = 0x8651; ///
enum GL_VERTEX_ATTRIB_ARRAY2_NV = 0x8652; ///
enum GL_VERTEX_ATTRIB_ARRAY3_NV = 0x8653; ///
enum GL_VERTEX_ATTRIB_ARRAY4_NV = 0x8654; ///
enum GL_VERTEX_ATTRIB_ARRAY5_NV = 0x8655; ///
enum GL_VERTEX_ATTRIB_ARRAY6_NV = 0x8656; ///
enum GL_VERTEX_ATTRIB_ARRAY7_NV = 0x8657; ///
enum GL_VERTEX_ATTRIB_ARRAY8_NV = 0x8658; ///
enum GL_VERTEX_ATTRIB_ARRAY9_NV = 0x8659; ///
enum GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV = 0x8F20; ///
enum GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001; ///
enum GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT = 0x00000001; ///
enum GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F; ///
enum GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB = 0x889F; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622; ///
enum GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB = 0x8622; ///
enum GL_VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD; ///
enum GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT = 0x88FD; ///
enum GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV = 0x88FD; ///
enum GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV = 0x8F2A; ///
enum GL_VERTEX_ATTRIB_ARRAY_LONG = 0x874E; ///
enum GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A; ///
enum GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB = 0x886A; ///
enum GL_VERTEX_ATTRIB_ARRAY_POINTER = 0x8645; ///
enum GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB = 0x8645; ///
enum GL_VERTEX_ATTRIB_ARRAY_SIZE = 0x8623; ///
enum GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB = 0x8623; ///
enum GL_VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624; ///
enum GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB = 0x8624; ///
enum GL_VERTEX_ATTRIB_ARRAY_TYPE = 0x8625; ///
enum GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB = 0x8625; ///
enum GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV = 0x8F1E; ///
enum GL_VERTEX_ATTRIB_BINDING = 0x82D4; ///
enum GL_VERTEX_ATTRIB_MAP1_APPLE = 0x8A00; ///
enum GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE = 0x8A03; ///
enum GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE = 0x8A05; ///
enum GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE = 0x8A04; ///
enum GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE = 0x8A02; ///
enum GL_VERTEX_ATTRIB_MAP2_APPLE = 0x8A01; ///
enum GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE = 0x8A07; ///
enum GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE = 0x8A09; ///
enum GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE = 0x8A08; ///
enum GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE = 0x8A06; ///
enum GL_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D5; ///
enum GL_VERTEX_BINDING_BUFFER = 0x8F4F; ///
enum GL_VERTEX_BINDING_DIVISOR = 0x82D6; ///
enum GL_VERTEX_BINDING_OFFSET = 0x82D7; ///
enum GL_VERTEX_BINDING_STRIDE = 0x82D8; ///
enum GL_VERTEX_BLEND_ARB = 0x86A7; ///
enum GL_VERTEX_CONSISTENT_HINT_PGI = 0x1A22B; ///
enum GL_VERTEX_DATA_HINT_PGI = 0x1A22A; ///
enum GL_VERTEX_ELEMENT_SWIZZLE_AMD = 0x91A4; ///
enum GL_VERTEX_ID_NV = 0x8C7B; ///
enum GL_VERTEX_ID_SWIZZLE_AMD = 0x91A5; ///
enum GL_VERTEX_PRECLIP_HINT_SGIX = 0x83EF; ///
enum GL_VERTEX_PRECLIP_SGIX = 0x83EE; ///
enum GL_VERTEX_PROGRAM_ARB = 0x8620; ///
enum GL_VERTEX_PROGRAM_BINDING_NV = 0x864A; ///
enum GL_VERTEX_PROGRAM_CALLBACK_DATA_MESA = 0x8BB7; ///
enum GL_VERTEX_PROGRAM_CALLBACK_FUNC_MESA = 0x8BB6; ///
enum GL_VERTEX_PROGRAM_CALLBACK_MESA = 0x8BB5; ///
enum GL_VERTEX_PROGRAM_NV = 0x8620; ///
enum GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA2; ///
enum GL_VERTEX_PROGRAM_POINT_SIZE = 0x8642; ///
enum GL_VERTEX_PROGRAM_POINT_SIZE_ARB = 0x8642; ///
enum GL_VERTEX_PROGRAM_POINT_SIZE_NV = 0x8642; ///
enum GL_VERTEX_PROGRAM_POSITION_MESA = 0x8BB4; ///
enum GL_VERTEX_PROGRAM_TWO_SIDE = 0x8643; ///
enum GL_VERTEX_PROGRAM_TWO_SIDE_ARB = 0x8643; ///
enum GL_VERTEX_PROGRAM_TWO_SIDE_NV = 0x8643; ///
enum GL_VERTEX_SHADER = 0x8B31; ///
enum GL_VERTEX_SHADER_ARB = 0x8B31; ///
enum GL_VERTEX_SHADER_BINDING_EXT = 0x8781; ///
enum GL_VERTEX_SHADER_BIT = 0x00000001; ///
enum GL_VERTEX_SHADER_BIT_EXT = 0x00000001; ///
enum GL_VERTEX_SHADER_EXT = 0x8780; ///
enum GL_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87CF; ///
enum GL_VERTEX_SHADER_INVARIANTS_EXT = 0x87D1; ///
enum GL_VERTEX_SHADER_INVOCATIONS_ARB = 0x82F0; ///
enum GL_VERTEX_SHADER_LOCALS_EXT = 0x87D3; ///
enum GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87D2; ///
enum GL_VERTEX_SHADER_OPTIMIZED_EXT = 0x87D4; ///
enum GL_VERTEX_SHADER_VARIANTS_EXT = 0x87D0; ///
enum GL_VERTEX_SOURCE_ATI = 0x8774; ///
enum GL_VERTEX_STATE_PROGRAM_NV = 0x8621; ///
enum GL_VERTEX_STREAM0_ATI = 0x876C; ///
enum GL_VERTEX_STREAM1_ATI = 0x876D; ///
enum GL_VERTEX_STREAM2_ATI = 0x876E; ///
enum GL_VERTEX_STREAM3_ATI = 0x876F; ///
enum GL_VERTEX_STREAM4_ATI = 0x8770; ///
enum GL_VERTEX_STREAM5_ATI = 0x8771; ///
enum GL_VERTEX_STREAM6_ATI = 0x8772; ///
enum GL_VERTEX_STREAM7_ATI = 0x8773; ///
enum GL_VERTEX_SUBROUTINE = 0x92E8; ///
enum GL_VERTEX_SUBROUTINE_UNIFORM = 0x92EE; ///
enum GL_VERTEX_TEXTURE = 0x829B; ///
enum GL_VERTEX_WEIGHTING_EXT = 0x8509; ///
enum GL_VERTEX_WEIGHT_ARRAY_EXT = 0x850C; ///
enum GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT = 0x8510; ///
enum GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT = 0x850D; ///
enum GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT = 0x850F; ///
enum GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT = 0x850E; ///
enum GL_VERTICAL_LINE_TO_NV = 0x08; ///
enum GL_VERTICES_SUBMITTED_ARB = 0x82EE; ///
enum GL_VIBRANCE_BIAS_NV = 0x8719; ///
enum GL_VIBRANCE_SCALE_NV = 0x8713; ///
enum GL_VIDEO_BUFFER_BINDING_NV = 0x9021; ///
enum GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV = 0x902D; ///
enum GL_VIDEO_BUFFER_NV = 0x9020; ///
enum GL_VIDEO_BUFFER_PITCH_NV = 0x9028; ///
enum GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV = 0x903B; ///
enum GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV = 0x903A; ///
enum GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV = 0x9039; ///
enum GL_VIDEO_CAPTURE_FRAME_WIDTH_NV = 0x9038; ///
enum GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV = 0x903C; ///
enum GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV = 0x9026; ///
enum GL_VIDEO_COLOR_CONVERSION_MATRIX_NV = 0x9029; ///
enum GL_VIDEO_COLOR_CONVERSION_MAX_NV = 0x902A; ///
enum GL_VIDEO_COLOR_CONVERSION_MIN_NV = 0x902B; ///
enum GL_VIDEO_COLOR_CONVERSION_OFFSET_NV = 0x902C; ///
enum GL_VIEWPORT = 0x0BA2; ///
enum GL_VIEWPORT_BIT = 0x00000800; ///
enum GL_VIEWPORT_BOUNDS_RANGE = 0x825D; ///
enum GL_VIEWPORT_BOUNDS_RANGE_EXT = 0x825D; ///
enum GL_VIEWPORT_BOUNDS_RANGE_NV = 0x825D; ///
enum GL_VIEWPORT_BOUNDS_RANGE_OES = 0x825D; ///
enum GL_VIEWPORT_COMMAND_NV = 0x0010; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX = 0x825F; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX_EXT = 0x825F; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX_NV = 0x825F; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX_OES = 0x825F; ///
enum GL_VIEWPORT_POSITION_W_SCALE_NV = 0x937C; ///
enum GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV = 0x937D; ///
enum GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV = 0x937E; ///
enum GL_VIEWPORT_SUBPIXEL_BITS = 0x825C; ///
enum GL_VIEWPORT_SUBPIXEL_BITS_EXT = 0x825C; ///
enum GL_VIEWPORT_SUBPIXEL_BITS_NV = 0x825C; ///
enum GL_VIEWPORT_SUBPIXEL_BITS_OES = 0x825C; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV = 0x9357; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV = 0x9351; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV = 0x9353; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV = 0x9355; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV = 0x9356; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV = 0x9350; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV = 0x9352; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV = 0x9354; ///
enum GL_VIEWPORT_SWIZZLE_W_NV = 0x935B; ///
enum GL_VIEWPORT_SWIZZLE_X_NV = 0x9358; ///
enum GL_VIEWPORT_SWIZZLE_Y_NV = 0x9359; ///
enum GL_VIEWPORT_SWIZZLE_Z_NV = 0x935A; ///
enum GL_VIEW_CLASS_128_BITS = 0x82C4; ///
enum GL_VIEW_CLASS_16_BITS = 0x82CA; ///
enum GL_VIEW_CLASS_24_BITS = 0x82C9; ///
enum GL_VIEW_CLASS_32_BITS = 0x82C8; ///
enum GL_VIEW_CLASS_48_BITS = 0x82C7; ///
enum GL_VIEW_CLASS_64_BITS = 0x82C6; ///
enum GL_VIEW_CLASS_8_BITS = 0x82CB; ///
enum GL_VIEW_CLASS_96_BITS = 0x82C5; ///
enum GL_VIEW_CLASS_BPTC_FLOAT = 0x82D3; ///
enum GL_VIEW_CLASS_BPTC_UNORM = 0x82D2; ///
enum GL_VIEW_CLASS_RGTC1_RED = 0x82D0; ///
enum GL_VIEW_CLASS_RGTC2_RG = 0x82D1; ///
enum GL_VIEW_CLASS_S3TC_DXT1_RGB = 0x82CC; ///
enum GL_VIEW_CLASS_S3TC_DXT1_RGBA = 0x82CD; ///
enum GL_VIEW_CLASS_S3TC_DXT3_RGBA = 0x82CE; ///
enum GL_VIEW_CLASS_S3TC_DXT5_RGBA = 0x82CF; ///
enum GL_VIEW_COMPATIBILITY_CLASS = 0x82B6; ///
enum GL_VIRTUAL_PAGE_SIZE_INDEX_ARB = 0x91A7; ///
enum GL_VIRTUAL_PAGE_SIZE_INDEX_EXT = 0x91A7; ///
enum GL_VIRTUAL_PAGE_SIZE_X_AMD = 0x9195; ///
enum GL_VIRTUAL_PAGE_SIZE_X_ARB = 0x9195; ///
enum GL_VIRTUAL_PAGE_SIZE_X_EXT = 0x9195; ///
enum GL_VIRTUAL_PAGE_SIZE_Y_AMD = 0x9196; ///
enum GL_VIRTUAL_PAGE_SIZE_Y_ARB = 0x9196; ///
enum GL_VIRTUAL_PAGE_SIZE_Y_EXT = 0x9196; ///
enum GL_VIRTUAL_PAGE_SIZE_Z_AMD = 0x9197; ///
enum GL_VIRTUAL_PAGE_SIZE_Z_ARB = 0x9197; ///
enum GL_VIRTUAL_PAGE_SIZE_Z_EXT = 0x9197; ///
enum GL_VIVIDLIGHT_NV = 0x92A6; ///
enum GL_VOLATILE_APPLE = 0x8A1A; ///
enum GL_WAIT_FAILED = 0x911D; ///
enum GL_WAIT_FAILED_APPLE = 0x911D; ///
enum GL_WARPS_PER_SM_NV = 0x933A; ///
enum GL_WARP_SIZE_NV = 0x9339; ///
enum GL_WEIGHTED_AVERAGE_ARB = 0x9367; ///
enum GL_WEIGHT_ARRAY_ARB = 0x86AD; ///
enum GL_WEIGHT_ARRAY_BUFFER_BINDING = 0x889E; ///
enum GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB = 0x889E; ///
enum GL_WEIGHT_ARRAY_BUFFER_BINDING_OES = 0x889E; ///
enum GL_WEIGHT_ARRAY_OES = 0x86AD; ///
enum GL_WEIGHT_ARRAY_POINTER_ARB = 0x86AC; ///
enum GL_WEIGHT_ARRAY_POINTER_OES = 0x86AC; ///
enum GL_WEIGHT_ARRAY_SIZE_ARB = 0x86AB; ///
enum GL_WEIGHT_ARRAY_SIZE_OES = 0x86AB; ///
enum GL_WEIGHT_ARRAY_STRIDE_ARB = 0x86AA; ///
enum GL_WEIGHT_ARRAY_STRIDE_OES = 0x86AA; ///
enum GL_WEIGHT_ARRAY_TYPE_ARB = 0x86A9; ///
enum GL_WEIGHT_ARRAY_TYPE_OES = 0x86A9; ///
enum GL_WEIGHT_SUM_UNITY_ARB = 0x86A6; ///
enum GL_WIDE_LINE_HINT_PGI = 0x1A222; ///
enum GL_WINDOW_RECTANGLE_EXT = 0x8F12; ///
enum GL_WINDOW_RECTANGLE_MODE_EXT = 0x8F13; ///
enum GL_WRAP_BORDER_SUN = 0x81D4; ///
enum GL_WRITEONLY_RENDERING_QCOM = 0x8823; ///
enum GL_WRITE_DISCARD_NV = 0x88BE; ///
enum GL_WRITE_ONLY = 0x88B9; ///
enum GL_WRITE_ONLY_ARB = 0x88B9; ///
enum GL_WRITE_ONLY_OES = 0x88B9; ///
enum GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV = 0x887A; ///
enum GL_WRITE_PIXEL_DATA_RANGE_NV = 0x8878; ///
enum GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV = 0x887C; ///
enum GL_W_EXT = 0x87D8; ///
enum GL_XOR = 0x1506; ///
enum GL_XOR_NV = 0x1506; ///
enum GL_X_EXT = 0x87D5; ///
enum GL_YCBAYCR8A_4224_NV = 0x9032; ///
enum GL_YCBCR_422_APPLE = 0x85B9; ///
enum GL_YCBCR_MESA = 0x8757; ///
enum GL_YCBYCR8_422_NV = 0x9031; ///
enum GL_YCRCBA_SGIX = 0x8319; ///
enum GL_YCRCB_422_SGIX = 0x81BB; ///
enum GL_YCRCB_444_SGIX = 0x81BC; ///
enum GL_YCRCB_SGIX = 0x8318; ///
enum GL_Y_EXT = 0x87D6; ///
enum GL_Z400_BINARY_AMD = 0x8740; ///
enum GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV = 0x9036; ///
enum GL_Z4Y12Z4CB12Z4CR12_444_NV = 0x9037; ///
enum GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV = 0x9035; ///
enum GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV = 0x9034; ///
enum GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV = 0x9033; ///
enum GL_ZERO = 0; ///
enum GL_ZERO_EXT = 0x87DD; ///
enum GL_ZERO_TO_ONE = 0x935F; ///
enum GL_ZOOM_X = 0x0D16; ///
enum GL_ZOOM_Y = 0x0D17; ///
enum GL_Z_EXT = 0x87D7; ///

	///
	enum AccumOp {
    	///
	    ACCUM = 0x0100,
    	///
	    LOAD = 0x0101,
    	///
	    RETURN = 0x0102,
    	///
	    MULT = 0x0103,
    	///
	    ADD = 0x0104
	}

	///
	@Bitmaskable
	enum AttribMask {
    	///
	    ACCUM_BUFFER_BIT = 0x00000200,
    	///
	    ALL_ATTRIB_BITS = 0xFFFFFFFF,
    	///
	    COLOR_BUFFER_BIT = 0x00004000,
    	///
	    CURRENT_BIT = 0x00000001,
    	///
	    DEPTH_BUFFER_BIT = 0x00000100,
    	///
	    ENABLE_BIT = 0x00002000,
    	///
	    EVAL_BIT = 0x00010000,
    	///
	    FOG_BIT = 0x00000080,
    	///
	    HINT_BIT = 0x00008000,
    	///
	    LIGHTING_BIT = 0x00000040,
    	///
	    LINE_BIT = 0x00000004,
    	///
	    LIST_BIT = 0x00020000,
    	///
	    MULTISAMPLE_BIT = 0x20000000,
    	///
	    MULTISAMPLE_BIT_3DFX = 0x20000000,
    	///
	    MULTISAMPLE_BIT_ARB = 0x20000000,
    	///
	    MULTISAMPLE_BIT_EXT = 0x20000000,
    	///
	    PIXEL_MODE_BIT = 0x00000020,
    	///
	    POINT_BIT = 0x00000002,
    	///
	    POLYGON_BIT = 0x00000008,
    	///
	    POLYGON_STIPPLE_BIT = 0x00000010,
    	///
	    SCISSOR_BIT = 0x00080000,
    	///
	    STENCIL_BUFFER_BIT = 0x00000400,
    	///
	    TEXTURE_BIT = 0x00040000,
    	///
	    TRANSFORM_BIT = 0x00001000,
    	///
	    VIEWPORT_BIT = 0x00000800
	}

	///
	enum AlphaFunction {
    	///
	    ALWAYS = 0x0207,
    	///
	    EQUAL = 0x0202,
    	///
	    GEQUAL = 0x0206,
    	///
	    GREATER = 0x0204,
    	///
	    LEQUAL = 0x0203,
    	///
	    LESS = 0x0201,
    	///
	    NEVER = 0x0200,
    	///
	    NOTEQUAL = 0x0205
	}

	///
	enum BlendEquationModeEXT {
    	///
	    ALPHA_MAX_SGIX = 0x8321,
    	///
	    ALPHA_MIN_SGIX = 0x8320,
    	///
	    FUNC_ADD_EXT = 0x8006,
    	///
	    FUNC_REVERSE_SUBTRACT_EXT = 0x800B,
    	///
	    FUNC_SUBTRACT_EXT = 0x800A,
    	///
	    LOGIC_OP = 0x0BF1,
    	///
	    MAX_EXT = 0x8008,
    	///
	    MIN_EXT = 0x8007
	}

	///
	enum BlendingFactorDest {
    	///
	    CONSTANT_ALPHA_EXT = 0x8003,
    	///
	    CONSTANT_COLOR_EXT = 0x8001,
    	///
	    DST_ALPHA = 0x0304,
    	///
	    ONE = 1,
    	///
	    ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004,
    	///
	    ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002,
    	///
	    ONE_MINUS_DST_ALPHA = 0x0305,
    	///
	    ONE_MINUS_SRC_ALPHA = 0x0303,
    	///
	    ONE_MINUS_SRC_COLOR = 0x0301,
    	///
	    SRC_ALPHA = 0x0302,
    	///
	    SRC_COLOR = 0x0300,
    	///
	    ZERO = 0
	}

	///
	enum BlendingFactorSrc {
    	///
	    CONSTANT_ALPHA_EXT = 0x8003,
    	///
	    CONSTANT_COLOR_EXT = 0x8001,
    	///
	    DST_ALPHA = 0x0304,
    	///
	    DST_COLOR = 0x0306,
    	///
	    ONE = 1,
    	///
	    ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004,
    	///
	    ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002,
    	///
	    ONE_MINUS_DST_ALPHA = 0x0305,
    	///
	    ONE_MINUS_DST_COLOR = 0x0307,
    	///
	    ONE_MINUS_SRC_ALPHA = 0x0303,
    	///
	    SRC_ALPHA = 0x0302,
    	///
	    SRC_ALPHA_SATURATE = 0x0308,
    	///
	    ZERO = 0
	}

	///
	enum Boolean {
    	///
	    FALSE = 0,
    	///
	    TRUE = 1
	}

	///
	@Bitmaskable
	enum ClearBufferMask {
    	///
	    ACCUM_BUFFER_BIT = 0x00000200,
    	///
	    COLOR_BUFFER_BIT = 0x00004000,
    	///
	    COVERAGE_BUFFER_BIT_NV = 0x00008000,
    	///
	    DEPTH_BUFFER_BIT = 0x00000100,
    	///
	    STENCIL_BUFFER_BIT = 0x00000400
	}

	///
	@Bitmaskable
	enum ClientAttribMask {
    	///
	    CLIENT_ALL_ATTRIB_BITS = 0xFFFFFFFF,
    	///
	    CLIENT_PIXEL_STORE_BIT = 0x00000001,
    	///
	    CLIENT_VERTEX_ARRAY_BIT = 0x00000002
	}

	///
	enum ClipPlaneName {
    	///
	    CLIP_DISTANCE0 = 0x3000,
    	///
	    CLIP_DISTANCE1 = 0x3001,
    	///
	    CLIP_DISTANCE2 = 0x3002,
    	///
	    CLIP_DISTANCE3 = 0x3003,
    	///
	    CLIP_DISTANCE4 = 0x3004,
    	///
	    CLIP_DISTANCE5 = 0x3005,
    	///
	    CLIP_DISTANCE6 = 0x3006,
    	///
	    CLIP_DISTANCE7 = 0x3007,
    	///
	    CLIP_PLANE0 = 0x3000,
    	///
	    CLIP_PLANE1 = 0x3001,
    	///
	    CLIP_PLANE2 = 0x3002,
    	///
	    CLIP_PLANE3 = 0x3003,
    	///
	    CLIP_PLANE4 = 0x3004,
    	///
	    CLIP_PLANE5 = 0x3005
	}

	///
	enum ColorMaterialFace {
    	///
	    BACK = 0x0405,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408
	}

	///
	enum ColorMaterialParameter {
    	///
	    AMBIENT = 0x1200,
    	///
	    AMBIENT_AND_DIFFUSE = 0x1602,
    	///
	    DIFFUSE = 0x1201,
    	///
	    EMISSION = 0x1600,
    	///
	    SPECULAR = 0x1202
	}

	///
	enum ColorPointerType {
    	///
	    BYTE = 0x1400,
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402,
    	///
	    UNSIGNED_BYTE = 0x1401,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_SHORT = 0x1403
	}

	///
	enum ColorTableParameterPNameSGI {
    	///
	    COLOR_TABLE_BIAS = 0x80D7,
    	///
	    COLOR_TABLE_BIAS_SGI = 0x80D7,
    	///
	    COLOR_TABLE_SCALE = 0x80D6,
    	///
	    COLOR_TABLE_SCALE_SGI = 0x80D6
	}

	///
	enum ColorTableTargetSGI {
    	///
	    COLOR_TABLE = 0x80D0,
    	///
	    COLOR_TABLE_SGI = 0x80D0,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE = 0x80D2,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2,
    	///
	    POST_CONVOLUTION_COLOR_TABLE = 0x80D1,
    	///
	    POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1,
    	///
	    PROXY_COLOR_TABLE = 0x80D3,
    	///
	    PROXY_COLOR_TABLE_SGI = 0x80D3,
    	///
	    PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D5,
    	///
	    PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D5,
    	///
	    PROXY_POST_CONVOLUTION_COLOR_TABLE = 0x80D4,
    	///
	    PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D4,
    	///
	    PROXY_TEXTURE_COLOR_TABLE_SGI = 0x80BD,
    	///
	    TEXTURE_COLOR_TABLE_SGI = 0x80BC
	}

	///
	@Bitmaskable
	enum ContextFlagMask {
    	///
	    CONTEXT_FLAG_DEBUG_BIT = 0x00000002,
    	///
	    CONTEXT_FLAG_DEBUG_BIT_KHR = 0x00000002,
    	///
	    CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001,
    	///
	    CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004,
    	///
	    CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT = 0x00000010
	}

	///
	@Bitmaskable
	enum ContextProfileMask {
    	///
	    CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002,
    	///
	    CONTEXT_CORE_PROFILE_BIT = 0x00000001
	}

	///
	enum ConvolutionBorderModeEXT {
    	///
	    REDUCE = 0x8016,
    	///
	    REDUCE_EXT = 0x8016
	}

	///
	enum ConvolutionParameterEXT {
    	///
	    CONVOLUTION_BORDER_MODE = 0x8013,
    	///
	    CONVOLUTION_BORDER_MODE_EXT = 0x8013,
    	///
	    CONVOLUTION_FILTER_BIAS = 0x8015,
    	///
	    CONVOLUTION_FILTER_BIAS_EXT = 0x8015,
    	///
	    CONVOLUTION_FILTER_SCALE = 0x8014,
    	///
	    CONVOLUTION_FILTER_SCALE_EXT = 0x8014
	}

	///
	enum ConvolutionTargetEXT {
    	///
	    CONVOLUTION_1D = 0x8010,
    	///
	    CONVOLUTION_1D_EXT = 0x8010,
    	///
	    CONVOLUTION_2D = 0x8011,
    	///
	    CONVOLUTION_2D_EXT = 0x8011
	}

	///
	enum CullFaceMode {
    	///
	    BACK = 0x0405,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408
	}

	///
	enum DepthFunction {
    	///
	    ALWAYS = 0x0207,
    	///
	    EQUAL = 0x0202,
    	///
	    GEQUAL = 0x0206,
    	///
	    GREATER = 0x0204,
    	///
	    LEQUAL = 0x0203,
    	///
	    LESS = 0x0201,
    	///
	    NEVER = 0x0200,
    	///
	    NOTEQUAL = 0x0205
	}

	///
	enum DrawBufferMode {
    	///
	    AUX0 = 0x0409,
    	///
	    AUX1 = 0x040A,
    	///
	    AUX2 = 0x040B,
    	///
	    AUX3 = 0x040C,
    	///
	    BACK = 0x0405,
    	///
	    BACK_LEFT = 0x0402,
    	///
	    BACK_RIGHT = 0x0403,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408,
    	///
	    FRONT_LEFT = 0x0400,
    	///
	    FRONT_RIGHT = 0x0401,
    	///
	    LEFT = 0x0406,
    	///
	    NONE = 0,
    	///
	    NONE_OES = 0,
    	///
	    RIGHT = 0x0407
	}

	///
	enum EnableCap {
    	///
	    ALPHA_TEST = 0x0BC0,
    	///
	    ASYNC_DRAW_PIXELS_SGIX = 0x835D,
    	///
	    ASYNC_HISTOGRAM_SGIX = 0x832C,
    	///
	    ASYNC_READ_PIXELS_SGIX = 0x835E,
    	///
	    ASYNC_TEX_IMAGE_SGIX = 0x835C,
    	///
	    AUTO_NORMAL = 0x0D80,
    	///
	    BLEND = 0x0BE2,
    	///
	    CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183,
    	///
	    CLIP_PLANE0 = 0x3000,
    	///
	    CLIP_PLANE1 = 0x3001,
    	///
	    CLIP_PLANE2 = 0x3002,
    	///
	    CLIP_PLANE3 = 0x3003,
    	///
	    CLIP_PLANE4 = 0x3004,
    	///
	    CLIP_PLANE5 = 0x3005,
    	///
	    COLOR_ARRAY = 0x8076,
    	///
	    COLOR_LOGIC_OP = 0x0BF2,
    	///
	    COLOR_MATERIAL = 0x0B57,
    	///
	    COLOR_TABLE_SGI = 0x80D0,
    	///
	    CONVOLUTION_1D_EXT = 0x8010,
    	///
	    CONVOLUTION_2D_EXT = 0x8011,
    	///
	    CULL_FACE = 0x0B44,
    	///
	    DEPTH_TEST = 0x0B71,
    	///
	    DITHER = 0x0BD0,
    	///
	    EDGE_FLAG_ARRAY = 0x8079,
    	///
	    FOG = 0x0B60,
    	///
	    FOG_OFFSET_SGIX = 0x8198,
    	///
	    FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401,
    	///
	    FRAGMENT_LIGHT0_SGIX = 0x840C,
    	///
	    FRAGMENT_LIGHT1_SGIX = 0x840D,
    	///
	    FRAGMENT_LIGHT2_SGIX = 0x840E,
    	///
	    FRAGMENT_LIGHT3_SGIX = 0x840F,
    	///
	    FRAGMENT_LIGHT4_SGIX = 0x8410,
    	///
	    FRAGMENT_LIGHT5_SGIX = 0x8411,
    	///
	    FRAGMENT_LIGHT6_SGIX = 0x8412,
    	///
	    FRAGMENT_LIGHT7_SGIX = 0x8413,
    	///
	    FRAGMENT_LIGHTING_SGIX = 0x8400,
    	///
	    FRAMEZOOM_SGIX = 0x818B,
    	///
	    HISTOGRAM_EXT = 0x8024,
    	///
	    INDEX_ARRAY = 0x8077,
    	///
	    INDEX_LOGIC_OP = 0x0BF1,
    	///
	    INTERLACE_SGIX = 0x8094,
    	///
	    IR_INSTRUMENT1_SGIX = 0x817F,
    	///
	    LIGHT0 = 0x4000,
    	///
	    LIGHT1 = 0x4001,
    	///
	    LIGHT2 = 0x4002,
    	///
	    LIGHT3 = 0x4003,
    	///
	    LIGHT4 = 0x4004,
    	///
	    LIGHT5 = 0x4005,
    	///
	    LIGHT6 = 0x4006,
    	///
	    LIGHT7 = 0x4007,
    	///
	    LIGHTING = 0x0B50,
    	///
	    LINE_SMOOTH = 0x0B20,
    	///
	    LINE_STIPPLE = 0x0B24,
    	///
	    MAP1_COLOR_4 = 0x0D90,
    	///
	    MAP1_INDEX = 0x0D91,
    	///
	    MAP1_NORMAL = 0x0D92,
    	///
	    MAP1_TEXTURE_COORD_1 = 0x0D93,
    	///
	    MAP1_TEXTURE_COORD_2 = 0x0D94,
    	///
	    MAP1_TEXTURE_COORD_3 = 0x0D95,
    	///
	    MAP1_TEXTURE_COORD_4 = 0x0D96,
    	///
	    MAP1_VERTEX_3 = 0x0D97,
    	///
	    MAP1_VERTEX_4 = 0x0D98,
    	///
	    MAP2_COLOR_4 = 0x0DB0,
    	///
	    MAP2_INDEX = 0x0DB1,
    	///
	    MAP2_NORMAL = 0x0DB2,
    	///
	    MAP2_TEXTURE_COORD_1 = 0x0DB3,
    	///
	    MAP2_TEXTURE_COORD_2 = 0x0DB4,
    	///
	    MAP2_TEXTURE_COORD_3 = 0x0DB5,
    	///
	    MAP2_TEXTURE_COORD_4 = 0x0DB6,
    	///
	    MAP2_VERTEX_3 = 0x0DB7,
    	///
	    MAP2_VERTEX_4 = 0x0DB8,
    	///
	    MINMAX_EXT = 0x802E,
    	///
	    MULTISAMPLE_SGIS = 0x809D,
    	///
	    NORMALIZE = 0x0BA1,
    	///
	    NORMAL_ARRAY = 0x8075,
    	///
	    PIXEL_TEXTURE_SGIS = 0x8353,
    	///
	    PIXEL_TEX_GEN_SGIX = 0x8139,
    	///
	    POINT_SMOOTH = 0x0B10,
    	///
	    POLYGON_OFFSET_FILL = 0x8037,
    	///
	    POLYGON_OFFSET_LINE = 0x2A02,
    	///
	    POLYGON_OFFSET_POINT = 0x2A01,
    	///
	    POLYGON_SMOOTH = 0x0B41,
    	///
	    POLYGON_STIPPLE = 0x0B42,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2,
    	///
	    POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1,
    	///
	    REFERENCE_PLANE_SGIX = 0x817D,
    	///
	    RESCALE_NORMAL_EXT = 0x803A,
    	///
	    SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E,
    	///
	    SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F,
    	///
	    SAMPLE_MASK_SGIS = 0x80A0,
    	///
	    SCISSOR_TEST = 0x0C11,
    	///
	    SEPARABLE_2D_EXT = 0x8012,
    	///
	    SHARED_TEXTURE_PALETTE_EXT = 0x81FB,
    	///
	    SPRITE_SGIX = 0x8148,
    	///
	    STENCIL_TEST = 0x0B90,
    	///
	    TEXTURE_1D = 0x0DE0,
    	///
	    TEXTURE_2D = 0x0DE1,
    	///
	    TEXTURE_3D_EXT = 0x806F,
    	///
	    TEXTURE_4D_SGIS = 0x8134,
    	///
	    TEXTURE_COLOR_TABLE_SGI = 0x80BC,
    	///
	    TEXTURE_COORD_ARRAY = 0x8078,
    	///
	    TEXTURE_GEN_Q = 0x0C63,
    	///
	    TEXTURE_GEN_R = 0x0C62,
    	///
	    TEXTURE_GEN_S = 0x0C60,
    	///
	    TEXTURE_GEN_T = 0x0C61,
    	///
	    VERTEX_ARRAY = 0x8074
	}

	///
	enum ErrorCode {
    	///
	    INVALID_ENUM = 0x0500,
    	///
	    INVALID_FRAMEBUFFER_OPERATION = 0x0506,
    	///
	    INVALID_FRAMEBUFFER_OPERATION_EXT = 0x0506,
    	///
	    INVALID_FRAMEBUFFER_OPERATION_OES = 0x0506,
    	///
	    INVALID_OPERATION = 0x0502,
    	///
	    INVALID_VALUE = 0x0501,
    	///
	    NO_ERROR = 0,
    	///
	    OUT_OF_MEMORY = 0x0505,
    	///
	    STACK_OVERFLOW = 0x0503,
    	///
	    STACK_UNDERFLOW = 0x0504,
    	///
	    TABLE_TOO_LARGE = 0x8031,
    	///
	    TABLE_TOO_LARGE_EXT = 0x8031,
    	///
	    TEXTURE_TOO_LARGE_EXT = 0x8065
	}

	///
	enum FeedbackType {
    	///
	    _2D = 0x0600,
    	///
	    _3D = 0x0601,
    	///
	    COLOR_3D = 0x0602,
    	///
	    COLOR_TEXTURE_3D = 0x0603,
    	///
	    COLOR_TEXTURE_4D = 0x0604
	}

	///
	enum FeedBackToken {
    	///
	    BITMAP_TOKEN = 0x0704,
    	///
	    COPY_PIXEL_TOKEN = 0x0706,
    	///
	    DRAW_PIXEL_TOKEN = 0x0705,
    	///
	    LINE_RESET_TOKEN = 0x0707,
    	///
	    LINE_TOKEN = 0x0702,
    	///
	    PASS_THROUGH_TOKEN = 0x0700,
    	///
	    POINT_TOKEN = 0x0701,
    	///
	    POLYGON_TOKEN = 0x0703
	}

	///
	enum FfdTargetSGIX {
    	///
	    GEOMETRY_DEFORMATION_SGIX = 0x8194,
    	///
	    TEXTURE_DEFORMATION_SGIX = 0x8195
	}

	///
	enum FogCoordinatePointerType {
    	///
	    FLOAT = 0x1406,
    	///
	    DOUBLE = 0x140A
	}

	///
	enum FogMode {
    	///
	    EXP = 0x0800,
    	///
	    EXP2 = 0x0801,
    	///
	    FOG_FUNC_SGIS = 0x812A,
    	///
	    LINEAR = 0x2601
	}

	///
	enum FogParameter {
    	///
	    FOG_COLOR = 0x0B66,
    	///
	    FOG_DENSITY = 0x0B62,
    	///
	    FOG_END = 0x0B64,
    	///
	    FOG_INDEX = 0x0B61,
    	///
	    FOG_MODE = 0x0B65,
    	///
	    FOG_OFFSET_VALUE_SGIX = 0x8199,
    	///
	    FOG_START = 0x0B63
	}

	///
	enum FogPointerTypeEXT {
    	///
	    FLOAT = 0x1406,
    	///
	    DOUBLE = 0x140A
	}

	///
	enum FogPointerTypeIBM {
    	///
	    FLOAT = 0x1406,
    	///
	    DOUBLE = 0x140A
	}

	///
	enum FragmentLightModelParameterSGIX {
    	///
	    FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A,
    	///
	    FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408,
    	///
	    FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B,
    	///
	    FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409
	}

	///
	enum FrontFaceDirection {
    	///
	    CCW = 0x0901,
    	///
	    CW = 0x0900
	}

	///
	enum GetColorTableParameterPNameSGI {
    	///
	    COLOR_TABLE_ALPHA_SIZE_SGI = 0x80DD,
    	///
	    COLOR_TABLE_BIAS_SGI = 0x80D7,
    	///
	    COLOR_TABLE_BLUE_SIZE_SGI = 0x80DC,
    	///
	    COLOR_TABLE_FORMAT_SGI = 0x80D8,
    	///
	    COLOR_TABLE_GREEN_SIZE_SGI = 0x80DB,
    	///
	    COLOR_TABLE_INTENSITY_SIZE_SGI = 0x80DF,
    	///
	    COLOR_TABLE_LUMINANCE_SIZE_SGI = 0x80DE,
    	///
	    COLOR_TABLE_RED_SIZE_SGI = 0x80DA,
    	///
	    COLOR_TABLE_SCALE_SGI = 0x80D6,
    	///
	    COLOR_TABLE_WIDTH_SGI = 0x80D9
	}

	///
	enum GetConvolutionParameter {
    	///
	    CONVOLUTION_BORDER_MODE_EXT = 0x8013,
    	///
	    CONVOLUTION_FILTER_BIAS_EXT = 0x8015,
    	///
	    CONVOLUTION_FILTER_SCALE_EXT = 0x8014,
    	///
	    CONVOLUTION_FORMAT_EXT = 0x8017,
    	///
	    CONVOLUTION_HEIGHT_EXT = 0x8019,
    	///
	    CONVOLUTION_WIDTH_EXT = 0x8018,
    	///
	    MAX_CONVOLUTION_HEIGHT_EXT = 0x801B,
    	///
	    MAX_CONVOLUTION_WIDTH_EXT = 0x801A
	}

	///
	enum GetHistogramParameterPNameEXT {
    	///
	    HISTOGRAM_ALPHA_SIZE_EXT = 0x802B,
    	///
	    HISTOGRAM_BLUE_SIZE_EXT = 0x802A,
    	///
	    HISTOGRAM_FORMAT_EXT = 0x8027,
    	///
	    HISTOGRAM_GREEN_SIZE_EXT = 0x8029,
    	///
	    HISTOGRAM_LUMINANCE_SIZE_EXT = 0x802C,
    	///
	    HISTOGRAM_RED_SIZE_EXT = 0x8028,
    	///
	    HISTOGRAM_SINK_EXT = 0x802D,
    	///
	    HISTOGRAM_WIDTH_EXT = 0x8026
	}

	///
	enum GetMapQuery {
    	///
	    COEFF = 0x0A00,
    	///
	    DOMAIN = 0x0A02,
    	///
	    ORDER = 0x0A01
	}

	///
	enum GetMinmaxParameterPNameEXT {
    	///
	    MINMAX_FORMAT = 0x802F,
    	///
	    MINMAX_FORMAT_EXT = 0x802F,
    	///
	    MINMAX_SINK = 0x8030,
    	///
	    MINMAX_SINK_EXT = 0x8030
	}

	///
	enum GetPixelMap {
    	///
	    PIXEL_MAP_A_TO_A = 0x0C79,
    	///
	    PIXEL_MAP_B_TO_B = 0x0C78,
    	///
	    PIXEL_MAP_G_TO_G = 0x0C77,
    	///
	    PIXEL_MAP_I_TO_A = 0x0C75,
    	///
	    PIXEL_MAP_I_TO_B = 0x0C74,
    	///
	    PIXEL_MAP_I_TO_G = 0x0C73,
    	///
	    PIXEL_MAP_I_TO_I = 0x0C70,
    	///
	    PIXEL_MAP_I_TO_R = 0x0C72,
    	///
	    PIXEL_MAP_R_TO_R = 0x0C76,
    	///
	    PIXEL_MAP_S_TO_S = 0x0C71
	}

	///
	enum GetPName {
    	///
	    ACCUM_ALPHA_BITS = 0x0D5B,
    	///
	    ACCUM_BLUE_BITS = 0x0D5A,
    	///
	    ACCUM_CLEAR_VALUE = 0x0B80,
    	///
	    ACCUM_GREEN_BITS = 0x0D59,
    	///
	    ACCUM_RED_BITS = 0x0D58,
    	///
	    ALIASED_LINE_WIDTH_RANGE = 0x846E,
    	///
	    ALIASED_POINT_SIZE_RANGE = 0x846D,
    	///
	    ALPHA_BIAS = 0x0D1D,
    	///
	    ALPHA_BITS = 0x0D55,
    	///
	    ALPHA_SCALE = 0x0D1C,
    	///
	    ALPHA_TEST = 0x0BC0,
    	///
	    ALPHA_TEST_FUNC = 0x0BC1,
    	///
	    ALPHA_TEST_FUNC_QCOM = 0x0BC1,
    	///
	    ALPHA_TEST_QCOM = 0x0BC0,
    	///
	    ALPHA_TEST_REF = 0x0BC2,
    	///
	    ALPHA_TEST_REF_QCOM = 0x0BC2,
    	///
	    ASYNC_DRAW_PIXELS_SGIX = 0x835D,
    	///
	    ASYNC_HISTOGRAM_SGIX = 0x832C,
    	///
	    ASYNC_MARKER_SGIX = 0x8329,
    	///
	    ASYNC_READ_PIXELS_SGIX = 0x835E,
    	///
	    ASYNC_TEX_IMAGE_SGIX = 0x835C,
    	///
	    ATTRIB_STACK_DEPTH = 0x0BB0,
    	///
	    AUTO_NORMAL = 0x0D80,
    	///
	    AUX_BUFFERS = 0x0C00,
    	///
	    BLEND = 0x0BE2,
    	///
	    BLEND_COLOR_EXT = 0x8005,
    	///
	    BLEND_DST = 0x0BE0,
    	///
	    BLEND_EQUATION_EXT = 0x8009,
    	///
	    BLEND_SRC = 0x0BE1,
    	///
	    BLUE_BIAS = 0x0D1B,
    	///
	    BLUE_BITS = 0x0D54,
    	///
	    BLUE_SCALE = 0x0D1A,
    	///
	    CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183,
    	///
	    CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1,
    	///
	    CLIP_PLANE0 = 0x3000,
    	///
	    CLIP_PLANE1 = 0x3001,
    	///
	    CLIP_PLANE2 = 0x3002,
    	///
	    CLIP_PLANE3 = 0x3003,
    	///
	    CLIP_PLANE4 = 0x3004,
    	///
	    CLIP_PLANE5 = 0x3005,
    	///
	    COLOR_ARRAY = 0x8076,
    	///
	    COLOR_ARRAY_COUNT_EXT = 0x8084,
    	///
	    COLOR_ARRAY_SIZE = 0x8081,
    	///
	    COLOR_ARRAY_STRIDE = 0x8083,
    	///
	    COLOR_ARRAY_TYPE = 0x8082,
    	///
	    COLOR_CLEAR_VALUE = 0x0C22,
    	///
	    COLOR_LOGIC_OP = 0x0BF2,
    	///
	    COLOR_MATERIAL = 0x0B57,
    	///
	    COLOR_MATERIAL_FACE = 0x0B55,
    	///
	    COLOR_MATERIAL_PARAMETER = 0x0B56,
    	///
	    COLOR_MATRIX_SGI = 0x80B1,
    	///
	    COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B2,
    	///
	    COLOR_TABLE_SGI = 0x80D0,
    	///
	    COLOR_WRITEMASK = 0x0C23,
    	///
	    CONVOLUTION_1D_EXT = 0x8010,
    	///
	    CONVOLUTION_2D_EXT = 0x8011,
    	///
	    CONVOLUTION_HINT_SGIX = 0x8316,
    	///
	    CULL_FACE = 0x0B44,
    	///
	    CULL_FACE_MODE = 0x0B45,
    	///
	    CURRENT_COLOR = 0x0B00,
    	///
	    CURRENT_INDEX = 0x0B01,
    	///
	    CURRENT_NORMAL = 0x0B02,
    	///
	    CURRENT_RASTER_COLOR = 0x0B04,
    	///
	    CURRENT_RASTER_DISTANCE = 0x0B09,
    	///
	    CURRENT_RASTER_INDEX = 0x0B05,
    	///
	    CURRENT_RASTER_POSITION = 0x0B07,
    	///
	    CURRENT_RASTER_POSITION_VALID = 0x0B08,
    	///
	    CURRENT_RASTER_TEXTURE_COORDS = 0x0B06,
    	///
	    CURRENT_TEXTURE_COORDS = 0x0B03,
    	///
	    DEFORMATIONS_MASK_SGIX = 0x8196,
    	///
	    DEPTH_BIAS = 0x0D1F,
    	///
	    DEPTH_BITS = 0x0D56,
    	///
	    DEPTH_CLEAR_VALUE = 0x0B73,
    	///
	    DEPTH_FUNC = 0x0B74,
    	///
	    DEPTH_RANGE = 0x0B70,
    	///
	    DEPTH_SCALE = 0x0D1E,
    	///
	    DEPTH_TEST = 0x0B71,
    	///
	    DEPTH_WRITEMASK = 0x0B72,
    	///
	    DETAIL_TEXTURE_2D_BINDING_SGIS = 0x8096,
    	///
	    DISTANCE_ATTENUATION_SGIS = 0x8129,
    	///
	    DITHER = 0x0BD0,
    	///
	    DOUBLEBUFFER = 0x0C32,
    	///
	    DRAW_BUFFER = 0x0C01,
    	///
	    DRAW_BUFFER_EXT = 0x0C01,
    	///
	    EDGE_FLAG = 0x0B43,
    	///
	    EDGE_FLAG_ARRAY = 0x8079,
    	///
	    EDGE_FLAG_ARRAY_COUNT_EXT = 0x808D,
    	///
	    EDGE_FLAG_ARRAY_STRIDE = 0x808C,
    	///
	    FEEDBACK_BUFFER_SIZE = 0x0DF1,
    	///
	    FEEDBACK_BUFFER_TYPE = 0x0DF2,
    	///
	    FOG = 0x0B60,
    	///
	    FOG_COLOR = 0x0B66,
    	///
	    FOG_DENSITY = 0x0B62,
    	///
	    FOG_END = 0x0B64,
    	///
	    FOG_FUNC_POINTS_SGIS = 0x812B,
    	///
	    FOG_HINT = 0x0C54,
    	///
	    FOG_INDEX = 0x0B61,
    	///
	    FOG_MODE = 0x0B65,
    	///
	    FOG_OFFSET_SGIX = 0x8198,
    	///
	    FOG_OFFSET_VALUE_SGIX = 0x8199,
    	///
	    FOG_START = 0x0B63,
    	///
	    FRAGMENT_COLOR_MATERIAL_FACE_SGIX = 0x8402,
    	///
	    FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = 0x8403,
    	///
	    FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401,
    	///
	    FRAGMENT_LIGHT0_SGIX = 0x840C,
    	///
	    FRAGMENT_LIGHTING_SGIX = 0x8400,
    	///
	    FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A,
    	///
	    FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408,
    	///
	    FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B,
    	///
	    FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409,
    	///
	    FRAMEZOOM_FACTOR_SGIX = 0x818C,
    	///
	    FRAMEZOOM_SGIX = 0x818B,
    	///
	    FRONT_FACE = 0x0B46,
    	///
	    GENERATE_MIPMAP_HINT_SGIS = 0x8192,
    	///
	    GREEN_BIAS = 0x0D19,
    	///
	    GREEN_BITS = 0x0D53,
    	///
	    GREEN_SCALE = 0x0D18,
    	///
	    HISTOGRAM_EXT = 0x8024,
    	///
	    INDEX_ARRAY = 0x8077,
    	///
	    INDEX_ARRAY_COUNT_EXT = 0x8087,
    	///
	    INDEX_ARRAY_STRIDE = 0x8086,
    	///
	    INDEX_ARRAY_TYPE = 0x8085,
    	///
	    INDEX_BITS = 0x0D51,
    	///
	    INDEX_CLEAR_VALUE = 0x0C20,
    	///
	    INDEX_LOGIC_OP = 0x0BF1,
    	///
	    INDEX_MODE = 0x0C30,
    	///
	    INDEX_OFFSET = 0x0D13,
    	///
	    INDEX_SHIFT = 0x0D12,
    	///
	    INDEX_WRITEMASK = 0x0C21,
    	///
	    INSTRUMENT_MEASUREMENTS_SGIX = 0x8181,
    	///
	    INTERLACE_SGIX = 0x8094,
    	///
	    IR_INSTRUMENT1_SGIX = 0x817F,
    	///
	    LIGHT0 = 0x4000,
    	///
	    LIGHT1 = 0x4001,
    	///
	    LIGHT2 = 0x4002,
    	///
	    LIGHT3 = 0x4003,
    	///
	    LIGHT4 = 0x4004,
    	///
	    LIGHT5 = 0x4005,
    	///
	    LIGHT6 = 0x4006,
    	///
	    LIGHT7 = 0x4007,
    	///
	    LIGHTING = 0x0B50,
    	///
	    LIGHT_ENV_MODE_SGIX = 0x8407,
    	///
	    LIGHT_MODEL_AMBIENT = 0x0B53,
    	///
	    LIGHT_MODEL_COLOR_CONTROL = 0x81F8,
    	///
	    LIGHT_MODEL_LOCAL_VIEWER = 0x0B51,
    	///
	    LIGHT_MODEL_TWO_SIDE = 0x0B52,
    	///
	    LINE_SMOOTH = 0x0B20,
    	///
	    LINE_SMOOTH_HINT = 0x0C52,
    	///
	    LINE_STIPPLE = 0x0B24,
    	///
	    LINE_STIPPLE_PATTERN = 0x0B25,
    	///
	    LINE_STIPPLE_REPEAT = 0x0B26,
    	///
	    LINE_WIDTH = 0x0B21,
    	///
	    LINE_WIDTH_GRANULARITY = 0x0B23,
    	///
	    LINE_WIDTH_RANGE = 0x0B22,
    	///
	    LIST_BASE = 0x0B32,
    	///
	    LIST_INDEX = 0x0B33,
    	///
	    LIST_MODE = 0x0B30,
    	///
	    LOGIC_OP = 0x0BF1,
    	///
	    LOGIC_OP_MODE = 0x0BF0,
    	///
	    MAP1_COLOR_4 = 0x0D90,
    	///
	    MAP1_GRID_DOMAIN = 0x0DD0,
    	///
	    MAP1_GRID_SEGMENTS = 0x0DD1,
    	///
	    MAP1_INDEX = 0x0D91,
    	///
	    MAP1_NORMAL = 0x0D92,
    	///
	    MAP1_TEXTURE_COORD_1 = 0x0D93,
    	///
	    MAP1_TEXTURE_COORD_2 = 0x0D94,
    	///
	    MAP1_TEXTURE_COORD_3 = 0x0D95,
    	///
	    MAP1_TEXTURE_COORD_4 = 0x0D96,
    	///
	    MAP1_VERTEX_3 = 0x0D97,
    	///
	    MAP1_VERTEX_4 = 0x0D98,
    	///
	    MAP2_COLOR_4 = 0x0DB0,
    	///
	    MAP2_GRID_DOMAIN = 0x0DD2,
    	///
	    MAP2_GRID_SEGMENTS = 0x0DD3,
    	///
	    MAP2_INDEX = 0x0DB1,
    	///
	    MAP2_NORMAL = 0x0DB2,
    	///
	    MAP2_TEXTURE_COORD_1 = 0x0DB3,
    	///
	    MAP2_TEXTURE_COORD_2 = 0x0DB4,
    	///
	    MAP2_TEXTURE_COORD_3 = 0x0DB5,
    	///
	    MAP2_TEXTURE_COORD_4 = 0x0DB6,
    	///
	    MAP2_VERTEX_3 = 0x0DB7,
    	///
	    MAP2_VERTEX_4 = 0x0DB8,
    	///
	    MAP_COLOR = 0x0D10,
    	///
	    MAP_STENCIL = 0x0D11,
    	///
	    MATRIX_MODE = 0x0BA0,
    	///
	    MAX_3D_TEXTURE_SIZE_EXT = 0x8073,
    	///
	    MAX_4D_TEXTURE_SIZE_SGIS = 0x8138,
    	///
	    MAX_ACTIVE_LIGHTS_SGIX = 0x8405,
    	///
	    MAX_ASYNC_DRAW_PIXELS_SGIX = 0x8360,
    	///
	    MAX_ASYNC_HISTOGRAM_SGIX = 0x832D,
    	///
	    MAX_ASYNC_READ_PIXELS_SGIX = 0x8361,
    	///
	    MAX_ASYNC_TEX_IMAGE_SGIX = 0x835F,
    	///
	    MAX_ATTRIB_STACK_DEPTH = 0x0D35,
    	///
	    MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B,
    	///
	    MAX_CLIPMAP_DEPTH_SGIX = 0x8177,
    	///
	    MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8178,
    	///
	    MAX_CLIP_DISTANCES = 0x0D32,
    	///
	    MAX_CLIP_PLANES = 0x0D32,
    	///
	    MAX_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B3,
    	///
	    MAX_EVAL_ORDER = 0x0D30,
    	///
	    MAX_FOG_FUNC_POINTS_SGIS = 0x812C,
    	///
	    MAX_FRAGMENT_LIGHTS_SGIX = 0x8404,
    	///
	    MAX_FRAMEZOOM_FACTOR_SGIX = 0x818D,
    	///
	    MAX_LIGHTS = 0x0D31,
    	///
	    MAX_LIST_NESTING = 0x0B31,
    	///
	    MAX_MODELVIEW_STACK_DEPTH = 0x0D36,
    	///
	    MAX_NAME_STACK_DEPTH = 0x0D37,
    	///
	    MAX_PIXEL_MAP_TABLE = 0x0D34,
    	///
	    MAX_PROJECTION_STACK_DEPTH = 0x0D38,
    	///
	    MAX_TEXTURE_SIZE = 0x0D33,
    	///
	    MAX_TEXTURE_STACK_DEPTH = 0x0D39,
    	///
	    MAX_VIEWPORT_DIMS = 0x0D3A,
    	///
	    MINMAX_EXT = 0x802E,
    	///
	    MODELVIEW0_MATRIX_EXT = 0x0BA6,
    	///
	    MODELVIEW0_STACK_DEPTH_EXT = 0x0BA3,
    	///
	    MODELVIEW_MATRIX = 0x0BA6,
    	///
	    MODELVIEW_STACK_DEPTH = 0x0BA3,
    	///
	    MULTISAMPLE_SGIS = 0x809D,
    	///
	    NAME_STACK_DEPTH = 0x0D70,
    	///
	    NORMALIZE = 0x0BA1,
    	///
	    NORMAL_ARRAY = 0x8075,
    	///
	    NORMAL_ARRAY_COUNT_EXT = 0x8080,
    	///
	    NORMAL_ARRAY_STRIDE = 0x807F,
    	///
	    NORMAL_ARRAY_TYPE = 0x807E,
    	///
	    PACK_ALIGNMENT = 0x0D05,
    	///
	    PACK_CMYK_HINT_EXT = 0x800E,
    	///
	    PACK_IMAGE_DEPTH_SGIS = 0x8131,
    	///
	    PACK_IMAGE_HEIGHT_EXT = 0x806C,
    	///
	    PACK_LSB_FIRST = 0x0D01,
    	///
	    PACK_RESAMPLE_SGIX = 0x842E,
    	///
	    PACK_ROW_LENGTH = 0x0D02,
    	///
	    PACK_SKIP_IMAGES_EXT = 0x806B,
    	///
	    PACK_SKIP_PIXELS = 0x0D04,
    	///
	    PACK_SKIP_ROWS = 0x0D03,
    	///
	    PACK_SKIP_VOLUMES_SGIS = 0x8130,
    	///
	    PACK_SUBSAMPLE_RATE_SGIX = 0x85A0,
    	///
	    PACK_SWAP_BYTES = 0x0D00,
    	///
	    PERSPECTIVE_CORRECTION_HINT = 0x0C50,
    	///
	    PIXEL_MAP_A_TO_A_SIZE = 0x0CB9,
    	///
	    PIXEL_MAP_B_TO_B_SIZE = 0x0CB8,
    	///
	    PIXEL_MAP_G_TO_G_SIZE = 0x0CB7,
    	///
	    PIXEL_MAP_I_TO_A_SIZE = 0x0CB5,
    	///
	    PIXEL_MAP_I_TO_B_SIZE = 0x0CB4,
    	///
	    PIXEL_MAP_I_TO_G_SIZE = 0x0CB3,
    	///
	    PIXEL_MAP_I_TO_I_SIZE = 0x0CB0,
    	///
	    PIXEL_MAP_I_TO_R_SIZE = 0x0CB2,
    	///
	    PIXEL_MAP_R_TO_R_SIZE = 0x0CB6,
    	///
	    PIXEL_MAP_S_TO_S_SIZE = 0x0CB1,
    	///
	    PIXEL_TEXTURE_SGIS = 0x8353,
    	///
	    PIXEL_TEX_GEN_MODE_SGIX = 0x832B,
    	///
	    PIXEL_TEX_GEN_SGIX = 0x8139,
    	///
	    PIXEL_TILE_BEST_ALIGNMENT_SGIX = 0x813E,
    	///
	    PIXEL_TILE_CACHE_INCREMENT_SGIX = 0x813F,
    	///
	    PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145,
    	///
	    PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144,
    	///
	    PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143,
    	///
	    PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142,
    	///
	    PIXEL_TILE_HEIGHT_SGIX = 0x8141,
    	///
	    PIXEL_TILE_WIDTH_SGIX = 0x8140,
    	///
	    POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128,
    	///
	    POINT_SIZE = 0x0B11,
    	///
	    POINT_SIZE_GRANULARITY = 0x0B13,
    	///
	    POINT_SIZE_MAX_SGIS = 0x8127,
    	///
	    POINT_SIZE_MIN_SGIS = 0x8126,
    	///
	    POINT_SIZE_RANGE = 0x0B12,
    	///
	    POINT_SMOOTH = 0x0B10,
    	///
	    POINT_SMOOTH_HINT = 0x0C51,
    	///
	    POLYGON_MODE = 0x0B40,
    	///
	    POLYGON_OFFSET_BIAS_EXT = 0x8039,
    	///
	    POLYGON_OFFSET_FACTOR = 0x8038,
    	///
	    POLYGON_OFFSET_FILL = 0x8037,
    	///
	    POLYGON_OFFSET_LINE = 0x2A02,
    	///
	    POLYGON_OFFSET_POINT = 0x2A01,
    	///
	    POLYGON_OFFSET_UNITS = 0x2A00,
    	///
	    POLYGON_SMOOTH = 0x0B41,
    	///
	    POLYGON_SMOOTH_HINT = 0x0C53,
    	///
	    POLYGON_STIPPLE = 0x0B42,
    	///
	    POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB,
    	///
	    POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7,
    	///
	    POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA,
    	///
	    POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2,
    	///
	    POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9,
    	///
	    POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5,
    	///
	    POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8,
    	///
	    POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4,
    	///
	    POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023,
    	///
	    POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F,
    	///
	    POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022,
    	///
	    POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E,
    	///
	    POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1,
    	///
	    POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021,
    	///
	    POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D,
    	///
	    POST_CONVOLUTION_RED_BIAS_EXT = 0x8020,
    	///
	    POST_CONVOLUTION_RED_SCALE_EXT = 0x801C,
    	///
	    POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = 0x817B,
    	///
	    POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = 0x817C,
    	///
	    PROJECTION_MATRIX = 0x0BA7,
    	///
	    PROJECTION_STACK_DEPTH = 0x0BA4,
    	///
	    READ_BUFFER = 0x0C02,
    	///
	    READ_BUFFER_EXT = 0x0C02,
    	///
	    READ_BUFFER_NV = 0x0C02,
    	///
	    RED_BIAS = 0x0D15,
    	///
	    RED_BITS = 0x0D52,
    	///
	    RED_SCALE = 0x0D14,
    	///
	    REFERENCE_PLANE_EQUATION_SGIX = 0x817E,
    	///
	    REFERENCE_PLANE_SGIX = 0x817D,
    	///
	    RENDER_MODE = 0x0C40,
    	///
	    RESCALE_NORMAL_EXT = 0x803A,
    	///
	    RGBA_MODE = 0x0C31,
    	///
	    SAMPLES_SGIS = 0x80A9,
    	///
	    SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E,
    	///
	    SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F,
    	///
	    SAMPLE_BUFFERS_SGIS = 0x80A8,
    	///
	    SAMPLE_MASK_INVERT_SGIS = 0x80AB,
    	///
	    SAMPLE_MASK_SGIS = 0x80A0,
    	///
	    SAMPLE_MASK_VALUE_SGIS = 0x80AA,
    	///
	    SAMPLE_PATTERN_SGIS = 0x80AC,
    	///
	    SCISSOR_BOX = 0x0C10,
    	///
	    SCISSOR_TEST = 0x0C11,
    	///
	    SELECTION_BUFFER_SIZE = 0x0DF4,
    	///
	    SEPARABLE_2D_EXT = 0x8012,
    	///
	    SHADE_MODEL = 0x0B54,
    	///
	    SHARED_TEXTURE_PALETTE_EXT = 0x81FB,
    	///
	    SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23,
    	///
	    SMOOTH_LINE_WIDTH_RANGE = 0x0B22,
    	///
	    SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13,
    	///
	    SMOOTH_POINT_SIZE_RANGE = 0x0B12,
    	///
	    SPRITE_AXIS_SGIX = 0x814A,
    	///
	    SPRITE_MODE_SGIX = 0x8149,
    	///
	    SPRITE_SGIX = 0x8148,
    	///
	    SPRITE_TRANSLATION_SGIX = 0x814B,
    	///
	    STENCIL_BITS = 0x0D57,
    	///
	    STENCIL_CLEAR_VALUE = 0x0B91,
    	///
	    STENCIL_FAIL = 0x0B94,
    	///
	    STENCIL_FUNC = 0x0B92,
    	///
	    STENCIL_PASS_DEPTH_FAIL = 0x0B95,
    	///
	    STENCIL_PASS_DEPTH_PASS = 0x0B96,
    	///
	    STENCIL_REF = 0x0B97,
    	///
	    STENCIL_TEST = 0x0B90,
    	///
	    STENCIL_VALUE_MASK = 0x0B93,
    	///
	    STENCIL_WRITEMASK = 0x0B98,
    	///
	    STEREO = 0x0C33,
    	///
	    SUBPIXEL_BITS = 0x0D50,
    	///
	    TEXTURE_1D = 0x0DE0,
    	///
	    TEXTURE_2D = 0x0DE1,
    	///
	    TEXTURE_3D_BINDING_EXT = 0x806A,
    	///
	    TEXTURE_3D_EXT = 0x806F,
    	///
	    TEXTURE_4D_BINDING_SGIS = 0x814F,
    	///
	    TEXTURE_4D_SGIS = 0x8134,
    	///
	    TEXTURE_BINDING_1D = 0x8068,
    	///
	    TEXTURE_BINDING_2D = 0x8069,
    	///
	    TEXTURE_BINDING_3D = 0x806A,
    	///
	    TEXTURE_COLOR_TABLE_SGI = 0x80BC,
    	///
	    TEXTURE_COORD_ARRAY = 0x8078,
    	///
	    TEXTURE_COORD_ARRAY_COUNT_EXT = 0x808B,
    	///
	    TEXTURE_COORD_ARRAY_SIZE = 0x8088,
    	///
	    TEXTURE_COORD_ARRAY_STRIDE = 0x808A,
    	///
	    TEXTURE_COORD_ARRAY_TYPE = 0x8089,
    	///
	    TEXTURE_GEN_Q = 0x0C63,
    	///
	    TEXTURE_GEN_R = 0x0C62,
    	///
	    TEXTURE_GEN_S = 0x0C60,
    	///
	    TEXTURE_GEN_T = 0x0C61,
    	///
	    TEXTURE_MATRIX = 0x0BA8,
    	///
	    TEXTURE_STACK_DEPTH = 0x0BA5,
    	///
	    UNPACK_ALIGNMENT = 0x0CF5,
    	///
	    UNPACK_CMYK_HINT_EXT = 0x800F,
    	///
	    UNPACK_IMAGE_DEPTH_SGIS = 0x8133,
    	///
	    UNPACK_IMAGE_HEIGHT_EXT = 0x806E,
    	///
	    UNPACK_LSB_FIRST = 0x0CF1,
    	///
	    UNPACK_RESAMPLE_SGIX = 0x842F,
    	///
	    UNPACK_ROW_LENGTH = 0x0CF2,
    	///
	    UNPACK_SKIP_IMAGES_EXT = 0x806D,
    	///
	    UNPACK_SKIP_PIXELS = 0x0CF4,
    	///
	    UNPACK_SKIP_ROWS = 0x0CF3,
    	///
	    UNPACK_SKIP_VOLUMES_SGIS = 0x8132,
    	///
	    UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1,
    	///
	    UNPACK_SWAP_BYTES = 0x0CF0,
    	///
	    VERTEX_ARRAY = 0x8074,
    	///
	    VERTEX_ARRAY_COUNT_EXT = 0x807D,
    	///
	    VERTEX_ARRAY_SIZE = 0x807A,
    	///
	    VERTEX_ARRAY_STRIDE = 0x807C,
    	///
	    VERTEX_ARRAY_TYPE = 0x807B,
    	///
	    VERTEX_PRECLIP_HINT_SGIX = 0x83EF,
    	///
	    VERTEX_PRECLIP_SGIX = 0x83EE,
    	///
	    VIEWPORT = 0x0BA2,
    	///
	    ZOOM_X = 0x0D16,
    	///
	    ZOOM_Y = 0x0D17
	}

	///
	enum GetPointervPName {
    	///
	    COLOR_ARRAY_POINTER = 0x8090,
    	///
	    COLOR_ARRAY_POINTER_EXT = 0x8090,
    	///
	    EDGE_FLAG_ARRAY_POINTER = 0x8093,
    	///
	    EDGE_FLAG_ARRAY_POINTER_EXT = 0x8093,
    	///
	    FEEDBACK_BUFFER_POINTER = 0x0DF0,
    	///
	    INDEX_ARRAY_POINTER = 0x8091,
    	///
	    INDEX_ARRAY_POINTER_EXT = 0x8091,
    	///
	    INSTRUMENT_BUFFER_POINTER_SGIX = 0x8180,
    	///
	    NORMAL_ARRAY_POINTER = 0x808F,
    	///
	    NORMAL_ARRAY_POINTER_EXT = 0x808F,
    	///
	    SELECTION_BUFFER_POINTER = 0x0DF3,
    	///
	    TEXTURE_COORD_ARRAY_POINTER = 0x8092,
    	///
	    TEXTURE_COORD_ARRAY_POINTER_EXT = 0x8092,
    	///
	    VERTEX_ARRAY_POINTER = 0x808E,
    	///
	    VERTEX_ARRAY_POINTER_EXT = 0x808E
	}

	///
	enum GetTextureParameter {
    	///
	    DETAIL_TEXTURE_FUNC_POINTS_SGIS = 0x809C,
    	///
	    DETAIL_TEXTURE_LEVEL_SGIS = 0x809A,
    	///
	    DETAIL_TEXTURE_MODE_SGIS = 0x809B,
    	///
	    DUAL_TEXTURE_SELECT_SGIS = 0x8124,
    	///
	    GENERATE_MIPMAP_SGIS = 0x8191,
    	///
	    POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179,
    	///
	    POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A,
    	///
	    QUAD_TEXTURE_SELECT_SGIS = 0x8125,
    	///
	    SHADOW_AMBIENT_SGIX = 0x80BF,
    	///
	    SHARPEN_TEXTURE_FUNC_POINTS_SGIS = 0x80B0,
    	///
	    TEXTURE_4DSIZE_SGIS = 0x8136,
    	///
	    TEXTURE_ALPHA_SIZE = 0x805F,
    	///
	    TEXTURE_BASE_LEVEL_SGIS = 0x813C,
    	///
	    TEXTURE_BLUE_SIZE = 0x805E,
    	///
	    TEXTURE_BORDER = 0x1005,
    	///
	    TEXTURE_BORDER_COLOR = 0x1004,
    	///
	    TEXTURE_BORDER_COLOR_NV = 0x1004,
    	///
	    TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171,
    	///
	    TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176,
    	///
	    TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172,
    	///
	    TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175,
    	///
	    TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173,
    	///
	    TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174,
    	///
	    TEXTURE_COMPARE_OPERATOR_SGIX = 0x819B,
    	///
	    TEXTURE_COMPARE_SGIX = 0x819A,
    	///
	    TEXTURE_COMPONENTS = 0x1003,
    	///
	    TEXTURE_DEPTH_EXT = 0x8071,
    	///
	    TEXTURE_FILTER4_SIZE_SGIS = 0x8147,
    	///
	    TEXTURE_GEQUAL_R_SGIX = 0x819D,
    	///
	    TEXTURE_GREEN_SIZE = 0x805D,
    	///
	    TEXTURE_HEIGHT = 0x1001,
    	///
	    TEXTURE_INTENSITY_SIZE = 0x8061,
    	///
	    TEXTURE_INTERNAL_FORMAT = 0x1003,
    	///
	    TEXTURE_LEQUAL_R_SGIX = 0x819C,
    	///
	    TEXTURE_LOD_BIAS_R_SGIX = 0x8190,
    	///
	    TEXTURE_LOD_BIAS_S_SGIX = 0x818E,
    	///
	    TEXTURE_LOD_BIAS_T_SGIX = 0x818F,
    	///
	    TEXTURE_LUMINANCE_SIZE = 0x8060,
    	///
	    TEXTURE_MAG_FILTER = 0x2800,
    	///
	    TEXTURE_MAX_CLAMP_R_SGIX = 0x836B,
    	///
	    TEXTURE_MAX_CLAMP_S_SGIX = 0x8369,
    	///
	    TEXTURE_MAX_CLAMP_T_SGIX = 0x836A,
    	///
	    TEXTURE_MAX_LEVEL_SGIS = 0x813D,
    	///
	    TEXTURE_MAX_LOD_SGIS = 0x813B,
    	///
	    TEXTURE_MIN_FILTER = 0x2801,
    	///
	    TEXTURE_MIN_LOD_SGIS = 0x813A,
    	///
	    TEXTURE_PRIORITY = 0x8066,
    	///
	    TEXTURE_RED_SIZE = 0x805C,
    	///
	    TEXTURE_RESIDENT = 0x8067,
    	///
	    TEXTURE_WIDTH = 0x1000,
    	///
	    TEXTURE_WRAP_Q_SGIS = 0x8137,
    	///
	    TEXTURE_WRAP_R_EXT = 0x8072,
    	///
	    TEXTURE_WRAP_S = 0x2802,
    	///
	    TEXTURE_WRAP_T = 0x2803
	}

	///
	enum HintMode {
    	///
	    DONT_CARE = 0x1100,
    	///
	    FASTEST = 0x1101,
    	///
	    NICEST = 0x1102
	}

	///
	enum HintTarget {
    	///
	    ALLOW_DRAW_FRG_HINT_PGI = 0x1A210,
    	///
	    ALLOW_DRAW_MEM_HINT_PGI = 0x1A211,
    	///
	    ALLOW_DRAW_OBJ_HINT_PGI = 0x1A20E,
    	///
	    ALLOW_DRAW_WIN_HINT_PGI = 0x1A20F,
    	///
	    ALWAYS_FAST_HINT_PGI = 0x1A20C,
    	///
	    ALWAYS_SOFT_HINT_PGI = 0x1A20D,
    	///
	    BACK_NORMALS_HINT_PGI = 0x1A223,
    	///
	    BINNING_CONTROL_HINT_QCOM = 0x8FB0,
    	///
	    CLIP_FAR_HINT_PGI = 0x1A221,
    	///
	    CLIP_NEAR_HINT_PGI = 0x1A220,
    	///
	    CLIP_VOLUME_CLIPPING_HINT_EXT = 0x80F0,
    	///
	    CONSERVE_MEMORY_HINT_PGI = 0x1A1FD,
    	///
	    CONVOLUTION_HINT_SGIX = 0x8316,
    	///
	    FOG_HINT = 0x0C54,
    	///
	    FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B,
    	///
	    FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = 0x8B8B,
    	///
	    FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B,
    	///
	    FULL_STIPPLE_HINT_PGI = 0x1A219,
    	///
	    GENERATE_MIPMAP_HINT = 0x8192,
    	///
	    GENERATE_MIPMAP_HINT_SGIS = 0x8192,
    	///
	    LINE_QUALITY_HINT_SGIX = 0x835B,
    	///
	    LINE_SMOOTH_HINT = 0x0C52,
    	///
	    MATERIAL_SIDE_HINT_PGI = 0x1A22C,
    	///
	    MAX_VERTEX_HINT_PGI = 0x1A22D,
    	///
	    MULTISAMPLE_FILTER_HINT_NV = 0x8534,
    	///
	    NATIVE_GRAPHICS_BEGIN_HINT_PGI = 0x1A203,
    	///
	    NATIVE_GRAPHICS_END_HINT_PGI = 0x1A204,
    	///
	    PACK_CMYK_HINT_EXT = 0x800E,
    	///
	    PERSPECTIVE_CORRECTION_HINT = 0x0C50,
    	///
	    PHONG_HINT_WIN = 0x80EB,
    	///
	    POINT_SMOOTH_HINT = 0x0C51,
    	///
	    POLYGON_SMOOTH_HINT = 0x0C53,
    	///
	    PREFER_DOUBLEBUFFER_HINT_PGI = 0x1A1F8,
    	///
	    PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257,
    	///
	    RECLAIM_MEMORY_HINT_PGI = 0x1A1FE,
    	///
	    SCALEBIAS_HINT_SGIX = 0x8322,
    	///
	    STRICT_DEPTHFUNC_HINT_PGI = 0x1A216,
    	///
	    STRICT_LIGHTING_HINT_PGI = 0x1A217,
    	///
	    STRICT_SCISSOR_HINT_PGI = 0x1A218,
    	///
	    TEXTURE_COMPRESSION_HINT = 0x84EF,
    	///
	    TEXTURE_COMPRESSION_HINT_ARB = 0x84EF,
    	///
	    TEXTURE_MULTI_BUFFER_HINT_SGIX = 0x812E,
    	///
	    TEXTURE_STORAGE_HINT_APPLE = 0x85BC,
    	///
	    TRANSFORM_HINT_APPLE = 0x85B1,
    	///
	    UNPACK_CMYK_HINT_EXT = 0x800F,
    	///
	    VERTEX_ARRAY_STORAGE_HINT_APPLE = 0x851F,
    	///
	    VERTEX_CONSISTENT_HINT_PGI = 0x1A22B,
    	///
	    VERTEX_DATA_HINT_PGI = 0x1A22A,
    	///
	    VERTEX_PRECLIP_HINT_SGIX = 0x83EF,
    	///
	    VERTEX_PRECLIP_SGIX = 0x83EE,
    	///
	    WIDE_LINE_HINT_PGI = 0x1A222
	}

	///
	enum HistogramTargetEXT {
    	///
	    HISTOGRAM = 0x8024,
    	///
	    HISTOGRAM_EXT = 0x8024,
    	///
	    PROXY_HISTOGRAM = 0x8025,
    	///
	    PROXY_HISTOGRAM_EXT = 0x8025
	}

	///
	enum IndexPointerType {
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

	///
	enum InterleavedArrayFormat {
    	///
	    C3F_V3F = 0x2A24,
    	///
	    C4F_N3F_V3F = 0x2A26,
    	///
	    C4UB_V2F = 0x2A22,
    	///
	    C4UB_V3F = 0x2A23,
    	///
	    N3F_V3F = 0x2A25,
    	///
	    T2F_C3F_V3F = 0x2A2A,
    	///
	    T2F_C4F_N3F_V3F = 0x2A2C,
    	///
	    T2F_C4UB_V3F = 0x2A29,
    	///
	    T2F_N3F_V3F = 0x2A2B,
    	///
	    T2F_V3F = 0x2A27,
    	///
	    T4F_C4F_N3F_V4F = 0x2A2D,
    	///
	    T4F_V4F = 0x2A28,
    	///
	    V2F = 0x2A20,
    	///
	    V3F = 0x2A21
	}

	///
	enum LightEnvModeSGIX {
    	///
	    ADD = 0x0104,
    	///
	    MODULATE = 0x2100,
    	///
	    REPLACE = 0x1E01
	}

	///
	enum LightEnvParameterSGIX {
    	///
	    LIGHT_ENV_MODE_SGIX = 0x8407
	}

	///
	enum LightModelColorControl {
    	///
	    SEPARATE_SPECULAR_COLOR = 0x81FA,
    	///
	    SEPARATE_SPECULAR_COLOR_EXT = 0x81FA,
    	///
	    SINGLE_COLOR = 0x81F9,
    	///
	    SINGLE_COLOR_EXT = 0x81F9
	}

	///
	enum LightModelParameter {
    	///
	    LIGHT_MODEL_AMBIENT = 0x0B53,
    	///
	    LIGHT_MODEL_COLOR_CONTROL = 0x81F8,
    	///
	    LIGHT_MODEL_COLOR_CONTROL_EXT = 0x81F8,
    	///
	    LIGHT_MODEL_LOCAL_VIEWER = 0x0B51,
    	///
	    LIGHT_MODEL_TWO_SIDE = 0x0B52
	}

	///
	enum LightName {
    	///
	    FRAGMENT_LIGHT0_SGIX = 0x840C,
    	///
	    FRAGMENT_LIGHT1_SGIX = 0x840D,
    	///
	    FRAGMENT_LIGHT2_SGIX = 0x840E,
    	///
	    FRAGMENT_LIGHT3_SGIX = 0x840F,
    	///
	    FRAGMENT_LIGHT4_SGIX = 0x8410,
    	///
	    FRAGMENT_LIGHT5_SGIX = 0x8411,
    	///
	    FRAGMENT_LIGHT6_SGIX = 0x8412,
    	///
	    FRAGMENT_LIGHT7_SGIX = 0x8413,
    	///
	    LIGHT0 = 0x4000,
    	///
	    LIGHT1 = 0x4001,
    	///
	    LIGHT2 = 0x4002,
    	///
	    LIGHT3 = 0x4003,
    	///
	    LIGHT4 = 0x4004,
    	///
	    LIGHT5 = 0x4005,
    	///
	    LIGHT6 = 0x4006,
    	///
	    LIGHT7 = 0x4007
	}

	///
	enum LightParameter {
    	///
	    AMBIENT = 0x1200,
    	///
	    CONSTANT_ATTENUATION = 0x1207,
    	///
	    DIFFUSE = 0x1201,
    	///
	    LINEAR_ATTENUATION = 0x1208,
    	///
	    POSITION = 0x1203,
    	///
	    QUADRATIC_ATTENUATION = 0x1209,
    	///
	    SPECULAR = 0x1202,
    	///
	    SPOT_CUTOFF = 0x1206,
    	///
	    SPOT_DIRECTION = 0x1204,
    	///
	    SPOT_EXPONENT = 0x1205
	}

	///
	enum ListMode {
    	///
	    COMPILE = 0x1300,
    	///
	    COMPILE_AND_EXECUTE = 0x1301
	}

	///
	enum ListNameType {
    	///
	    BYTES_2 = 0x1407,
    	///
	    BYTES_3 = 0x1408,
    	///
	    BYTES_4 = 0x1409,
    	///
	    BYTE = 0x1400,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402,
    	///
	    UNSIGNED_BYTE = 0x1401,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_SHORT = 0x1403
	}

	///
	enum ListParameterName {
    	///
	    LIST_PRIORITY_SGIX = 0x8182
	}

	///
	enum LogicOp {
    	///
	    AND = 0x1501,
    	///
	    AND_INVERTED = 0x1504,
    	///
	    AND_REVERSE = 0x1502,
    	///
	    CLEAR = 0x1500,
    	///
	    COPY = 0x1503,
    	///
	    COPY_INVERTED = 0x150C,
    	///
	    EQUIV = 0x1509,
    	///
	    INVERT = 0x150A,
    	///
	    NAND = 0x150E,
    	///
	    NOOP = 0x1505,
    	///
	    NOR = 0x1508,
    	///
	    OR = 0x1507,
    	///
	    OR_INVERTED = 0x150D,
    	///
	    OR_REVERSE = 0x150B,
    	///
	    SET = 0x150F,
    	///
	    XOR = 0x1506
	}

	///
	@Bitmaskable
	enum MapBufferUsageMask {
    	///
	    CLIENT_STORAGE_BIT = 0x0200,
    	///
	    DYNAMIC_STORAGE_BIT = 0x0100,
    	///
	    MAP_COHERENT_BIT = 0x0080,
    	///
	    MAP_FLUSH_EXPLICIT_BIT = 0x0010,
    	///
	    MAP_FLUSH_EXPLICIT_BIT_EXT = 0x0010,
    	///
	    MAP_INVALIDATE_BUFFER_BIT = 0x0008,
    	///
	    MAP_INVALIDATE_BUFFER_BIT_EXT = 0x0008,
    	///
	    MAP_INVALIDATE_RANGE_BIT = 0x0004,
    	///
	    MAP_INVALIDATE_RANGE_BIT_EXT = 0x0004,
    	///
	    MAP_PERSISTENT_BIT = 0x0040,
    	///
	    MAP_READ_BIT = 0x0001,
    	///
	    MAP_READ_BIT_EXT = 0x0001,
    	///
	    MAP_UNSYNCHRONIZED_BIT = 0x0020,
    	///
	    MAP_UNSYNCHRONIZED_BIT_EXT = 0x0020,
    	///
	    MAP_WRITE_BIT = 0x0002,
    	///
	    MAP_WRITE_BIT_EXT = 0x0002
	}

	///
	enum MapTarget {
    	///
	    GEOMETRY_DEFORMATION_SGIX = 0x8194,
    	///
	    MAP1_COLOR_4 = 0x0D90,
    	///
	    MAP1_INDEX = 0x0D91,
    	///
	    MAP1_NORMAL = 0x0D92,
    	///
	    MAP1_TEXTURE_COORD_1 = 0x0D93,
    	///
	    MAP1_TEXTURE_COORD_2 = 0x0D94,
    	///
	    MAP1_TEXTURE_COORD_3 = 0x0D95,
    	///
	    MAP1_TEXTURE_COORD_4 = 0x0D96,
    	///
	    MAP1_VERTEX_3 = 0x0D97,
    	///
	    MAP1_VERTEX_4 = 0x0D98,
    	///
	    MAP2_COLOR_4 = 0x0DB0,
    	///
	    MAP2_INDEX = 0x0DB1,
    	///
	    MAP2_NORMAL = 0x0DB2,
    	///
	    MAP2_TEXTURE_COORD_1 = 0x0DB3,
    	///
	    MAP2_TEXTURE_COORD_2 = 0x0DB4,
    	///
	    MAP2_TEXTURE_COORD_3 = 0x0DB5,
    	///
	    MAP2_TEXTURE_COORD_4 = 0x0DB6,
    	///
	    MAP2_VERTEX_3 = 0x0DB7,
    	///
	    MAP2_VERTEX_4 = 0x0DB8,
    	///
	    TEXTURE_DEFORMATION_SGIX = 0x8195
	}

	///
	enum MapTextureFormatINTEL {
    	///
	    LAYOUT_DEFAULT_INTEL = 0,
    	///
	    LAYOUT_LINEAR_CPU_CACHED_INTEL = 2,
    	///
	    LAYOUT_LINEAR_INTEL = 1
	}

	///
	enum MaterialFace {
    	///
	    BACK = 0x0405,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408
	}

	///
	enum MaterialParameter {
    	///
	    AMBIENT = 0x1200,
    	///
	    AMBIENT_AND_DIFFUSE = 0x1602,
    	///
	    COLOR_INDEXES = 0x1603,
    	///
	    DIFFUSE = 0x1201,
    	///
	    EMISSION = 0x1600,
    	///
	    SHININESS = 0x1601,
    	///
	    SPECULAR = 0x1202
	}

	///
	enum MatrixMode {
    	///
	    MODELVIEW = 0x1700,
    	///
	    MODELVIEW0_EXT = 0x1700,
    	///
	    PROJECTION = 0x1701,
    	///
	    TEXTURE = 0x1702
	}

	///
	@Bitmaskable
	enum MemoryBarrierMask {
    	///
	    ALL_BARRIER_BITS = 0xFFFFFFFF,
    	///
	    ALL_BARRIER_BITS_EXT = 0xFFFFFFFF,
    	///
	    ATOMIC_COUNTER_BARRIER_BIT = 0x00001000,
    	///
	    ATOMIC_COUNTER_BARRIER_BIT_EXT = 0x00001000,
    	///
	    BUFFER_UPDATE_BARRIER_BIT = 0x00000200,
    	///
	    BUFFER_UPDATE_BARRIER_BIT_EXT = 0x00000200,
    	///
	    CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000,
    	///
	    COMMAND_BARRIER_BIT = 0x00000040,
    	///
	    COMMAND_BARRIER_BIT_EXT = 0x00000040,
    	///
	    ELEMENT_ARRAY_BARRIER_BIT = 0x00000002,
    	///
	    ELEMENT_ARRAY_BARRIER_BIT_EXT = 0x00000002,
    	///
	    FRAMEBUFFER_BARRIER_BIT = 0x00000400,
    	///
	    FRAMEBUFFER_BARRIER_BIT_EXT = 0x00000400,
    	///
	    PIXEL_BUFFER_BARRIER_BIT = 0x00000080,
    	///
	    PIXEL_BUFFER_BARRIER_BIT_EXT = 0x00000080,
    	///
	    QUERY_BUFFER_BARRIER_BIT = 0x00008000,
    	///
	    SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV = 0x00000010,
    	///
	    SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020,
    	///
	    SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT = 0x00000020,
    	///
	    SHADER_STORAGE_BARRIER_BIT = 0x00002000,
    	///
	    TEXTURE_FETCH_BARRIER_BIT = 0x00000008,
    	///
	    TEXTURE_FETCH_BARRIER_BIT_EXT = 0x00000008,
    	///
	    TEXTURE_UPDATE_BARRIER_BIT = 0x00000100,
    	///
	    TEXTURE_UPDATE_BARRIER_BIT_EXT = 0x00000100,
    	///
	    TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800,
    	///
	    TRANSFORM_FEEDBACK_BARRIER_BIT_EXT = 0x00000800,
    	///
	    UNIFORM_BARRIER_BIT = 0x00000004,
    	///
	    UNIFORM_BARRIER_BIT_EXT = 0x00000004,
    	///
	    VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001,
    	///
	    VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT = 0x00000001
	}

	///
	enum MeshMode1 {
    	///
	    LINE = 0x1B01,
    	///
	    POINT = 0x1B00
	}

	///
	enum MeshMode2 {
    	///
	    FILL = 0x1B02,
    	///
	    LINE = 0x1B01,
    	///
	    POINT = 0x1B00
	}

	///
	enum MinmaxTargetEXT {
    	///
	    MINMAX = 0x802E,
    	///
	    MINMAX_EXT = 0x802E
	}

	///
	enum NormalPointerType {
    	///
	    BYTE = 0x1400,
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

	///
	enum PixelCopyType {
    	///
	    COLOR = 0x1800,
    	///
	    COLOR_EXT = 0x1800,
    	///
	    DEPTH = 0x1801,
    	///
	    DEPTH_EXT = 0x1801,
    	///
	    STENCIL = 0x1802,
    	///
	    STENCIL_EXT = 0x1802
	}

	///
	enum PixelFormat {
    	///
	    ABGR_EXT = 0x8000,
    	///
	    ALPHA = 0x1906,
    	///
	    BLUE = 0x1905,
    	///
	    CMYKA_EXT = 0x800D,
    	///
	    CMYK_EXT = 0x800C,
    	///
	    COLOR_INDEX = 0x1900,
    	///
	    DEPTH_COMPONENT = 0x1902,
    	///
	    GREEN = 0x1904,
    	///
	    LUMINANCE = 0x1909,
    	///
	    LUMINANCE_ALPHA = 0x190A,
    	///
	    RED = 0x1903,
    	///
	    RED_EXT = 0x1903,
    	///
	    RGB = 0x1907,
    	///
	    RGBA = 0x1908,
    	///
	    STENCIL_INDEX = 0x1901,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_SHORT = 0x1403,
    	///
	    YCRCB_422_SGIX = 0x81BB,
    	///
	    YCRCB_444_SGIX = 0x81BC
	}

	///
	enum InternalFormat {
    	///
	    ALPHA12 = 0x803D,
    	///
	    ALPHA16 = 0x803E,
    	///
	    ALPHA4 = 0x803B,
    	///
	    ALPHA8 = 0x803C,
    	///
	    DEPTH_COMPONENT16_SGIX = 0x81A5,
    	///
	    DEPTH_COMPONENT24_SGIX = 0x81A6,
    	///
	    DEPTH_COMPONENT32_SGIX = 0x81A7,
    	///
	    DUAL_ALPHA12_SGIS = 0x8112,
    	///
	    DUAL_ALPHA16_SGIS = 0x8113,
    	///
	    DUAL_ALPHA4_SGIS = 0x8110,
    	///
	    DUAL_ALPHA8_SGIS = 0x8111,
    	///
	    DUAL_INTENSITY12_SGIS = 0x811A,
    	///
	    DUAL_INTENSITY16_SGIS = 0x811B,
    	///
	    DUAL_INTENSITY4_SGIS = 0x8118,
    	///
	    DUAL_INTENSITY8_SGIS = 0x8119,
    	///
	    DUAL_LUMINANCE12_SGIS = 0x8116,
    	///
	    DUAL_LUMINANCE16_SGIS = 0x8117,
    	///
	    DUAL_LUMINANCE4_SGIS = 0x8114,
    	///
	    DUAL_LUMINANCE8_SGIS = 0x8115,
    	///
	    DUAL_LUMINANCE_ALPHA4_SGIS = 0x811C,
    	///
	    DUAL_LUMINANCE_ALPHA8_SGIS = 0x811D,
    	///
	    INTENSITY = 0x8049,
    	///
	    INTENSITY12 = 0x804C,
    	///
	    INTENSITY16 = 0x804D,
    	///
	    INTENSITY4 = 0x804A,
    	///
	    INTENSITY8 = 0x804B,
    	///
	    LUMINANCE12 = 0x8041,
    	///
	    LUMINANCE12_ALPHA12 = 0x8047,
    	///
	    LUMINANCE12_ALPHA4 = 0x8046,
    	///
	    LUMINANCE16 = 0x8042,
    	///
	    LUMINANCE16_ALPHA16 = 0x8048,
    	///
	    LUMINANCE4 = 0x803F,
    	///
	    LUMINANCE4_ALPHA4 = 0x8043,
    	///
	    LUMINANCE6_ALPHA2 = 0x8044,
    	///
	    LUMINANCE8 = 0x8040,
    	///
	    LUMINANCE8_ALPHA8 = 0x8045,
    	///
	    QUAD_ALPHA4_SGIS = 0x811E,
    	///
	    QUAD_ALPHA8_SGIS = 0x811F,
    	///
	    QUAD_INTENSITY4_SGIS = 0x8122,
    	///
	    QUAD_INTENSITY8_SGIS = 0x8123,
    	///
	    QUAD_LUMINANCE4_SGIS = 0x8120,
    	///
	    QUAD_LUMINANCE8_SGIS = 0x8121,
    	///
	    R3_G3_B2 = 0x2A10,
    	///
	    RGB10 = 0x8052,
    	///
	    RGB10_A2 = 0x8059,
    	///
	    RGB12 = 0x8053,
    	///
	    RGB16 = 0x8054,
    	///
	    RGB2_EXT = 0x804E,
    	///
	    RGB4 = 0x804F,
    	///
	    RGB5 = 0x8050,
    	///
	    RGB5_A1 = 0x8057,
    	///
	    RGB8 = 0x8051,
    	///
	    RGBA12 = 0x805A,
    	///
	    RGBA16 = 0x805B,
    	///
	    RGBA2 = 0x8055,
    	///
	    RGBA4 = 0x8056,
    	///
	    RGBA8 = 0x8058
	}

	///
	enum PixelMap {
    	///
	    PIXEL_MAP_A_TO_A = 0x0C79,
    	///
	    PIXEL_MAP_B_TO_B = 0x0C78,
    	///
	    PIXEL_MAP_G_TO_G = 0x0C77,
    	///
	    PIXEL_MAP_I_TO_A = 0x0C75,
    	///
	    PIXEL_MAP_I_TO_B = 0x0C74,
    	///
	    PIXEL_MAP_I_TO_G = 0x0C73,
    	///
	    PIXEL_MAP_I_TO_I = 0x0C70,
    	///
	    PIXEL_MAP_I_TO_R = 0x0C72,
    	///
	    PIXEL_MAP_R_TO_R = 0x0C76,
    	///
	    PIXEL_MAP_S_TO_S = 0x0C71
	}

	///
	enum PixelStoreParameter {
    	///
	    PACK_ALIGNMENT = 0x0D05,
    	///
	    PACK_IMAGE_DEPTH_SGIS = 0x8131,
    	///
	    PACK_IMAGE_HEIGHT = 0x806C,
    	///
	    PACK_IMAGE_HEIGHT_EXT = 0x806C,
    	///
	    PACK_LSB_FIRST = 0x0D01,
    	///
	    PACK_RESAMPLE_OML = 0x8984,
    	///
	    PACK_RESAMPLE_SGIX = 0x842E,
    	///
	    PACK_ROW_LENGTH = 0x0D02,
    	///
	    PACK_SKIP_IMAGES = 0x806B,
    	///
	    PACK_SKIP_IMAGES_EXT = 0x806B,
    	///
	    PACK_SKIP_PIXELS = 0x0D04,
    	///
	    PACK_SKIP_ROWS = 0x0D03,
    	///
	    PACK_SKIP_VOLUMES_SGIS = 0x8130,
    	///
	    PACK_SUBSAMPLE_RATE_SGIX = 0x85A0,
    	///
	    PACK_SWAP_BYTES = 0x0D00,
    	///
	    PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145,
    	///
	    PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144,
    	///
	    PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143,
    	///
	    PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142,
    	///
	    PIXEL_TILE_HEIGHT_SGIX = 0x8141,
    	///
	    PIXEL_TILE_WIDTH_SGIX = 0x8140,
    	///
	    UNPACK_ALIGNMENT = 0x0CF5,
    	///
	    UNPACK_IMAGE_DEPTH_SGIS = 0x8133,
    	///
	    UNPACK_IMAGE_HEIGHT = 0x806E,
    	///
	    UNPACK_IMAGE_HEIGHT_EXT = 0x806E,
    	///
	    UNPACK_LSB_FIRST = 0x0CF1,
    	///
	    UNPACK_RESAMPLE_OML = 0x8985,
    	///
	    UNPACK_RESAMPLE_SGIX = 0x842F,
    	///
	    UNPACK_ROW_LENGTH = 0x0CF2,
    	///
	    UNPACK_ROW_LENGTH_EXT = 0x0CF2,
    	///
	    UNPACK_SKIP_IMAGES = 0x806D,
    	///
	    UNPACK_SKIP_IMAGES_EXT = 0x806D,
    	///
	    UNPACK_SKIP_PIXELS = 0x0CF4,
    	///
	    UNPACK_SKIP_PIXELS_EXT = 0x0CF4,
    	///
	    UNPACK_SKIP_ROWS = 0x0CF3,
    	///
	    UNPACK_SKIP_ROWS_EXT = 0x0CF3,
    	///
	    UNPACK_SKIP_VOLUMES_SGIS = 0x8132,
    	///
	    UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1,
    	///
	    UNPACK_SWAP_BYTES = 0x0CF0
	}

	///
	enum PixelStoreResampleMode {
    	///
	    RESAMPLE_DECIMATE_SGIX = 0x8430,
    	///
	    RESAMPLE_REPLICATE_SGIX = 0x8433,
    	///
	    RESAMPLE_ZERO_FILL_SGIX = 0x8434
	}

	///
	enum PixelStoreSubsampleRate {
    	///
	    PIXEL_SUBSAMPLE_2424_SGIX = 0x85A3,
    	///
	    PIXEL_SUBSAMPLE_4242_SGIX = 0x85A4,
    	///
	    PIXEL_SUBSAMPLE_4444_SGIX = 0x85A2
	}

	///
	enum PixelTexGenMode {
    	///
	    LUMINANCE = 0x1909,
    	///
	    LUMINANCE_ALPHA = 0x190A,
    	///
	    NONE = 0,
    	///
	    PIXEL_TEX_GEN_ALPHA_LS_SGIX = 0x8189,
    	///
	    PIXEL_TEX_GEN_ALPHA_MS_SGIX = 0x818A,
    	///
	    PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX = 0x8188,
    	///
	    PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX = 0x8187,
    	///
	    RGB = 0x1907,
    	///
	    RGBA = 0x1908
	}

	///
	enum PixelTexGenParameterNameSGIS {
    	///
	    PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = 0x8355,
    	///
	    PIXEL_FRAGMENT_RGB_SOURCE_SGIS = 0x8354
	}

	///
	enum PixelTransferParameter {
    	///
	    ALPHA_BIAS = 0x0D1D,
    	///
	    ALPHA_SCALE = 0x0D1C,
    	///
	    BLUE_BIAS = 0x0D1B,
    	///
	    BLUE_SCALE = 0x0D1A,
    	///
	    DEPTH_BIAS = 0x0D1F,
    	///
	    DEPTH_SCALE = 0x0D1E,
    	///
	    GREEN_BIAS = 0x0D19,
    	///
	    GREEN_SCALE = 0x0D18,
    	///
	    INDEX_OFFSET = 0x0D13,
    	///
	    INDEX_SHIFT = 0x0D12,
    	///
	    MAP_COLOR = 0x0D10,
    	///
	    MAP_STENCIL = 0x0D11,
    	///
	    POST_COLOR_MATRIX_ALPHA_BIAS = 0x80BB,
    	///
	    POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB,
    	///
	    POST_COLOR_MATRIX_ALPHA_SCALE = 0x80B7,
    	///
	    POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7,
    	///
	    POST_COLOR_MATRIX_BLUE_BIAS = 0x80BA,
    	///
	    POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA,
    	///
	    POST_COLOR_MATRIX_BLUE_SCALE = 0x80B6,
    	///
	    POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6,
    	///
	    POST_COLOR_MATRIX_GREEN_BIAS = 0x80B9,
    	///
	    POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9,
    	///
	    POST_COLOR_MATRIX_GREEN_SCALE = 0x80B5,
    	///
	    POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5,
    	///
	    POST_COLOR_MATRIX_RED_BIAS = 0x80B8,
    	///
	    POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8,
    	///
	    POST_COLOR_MATRIX_RED_SCALE = 0x80B4,
    	///
	    POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4,
    	///
	    POST_CONVOLUTION_ALPHA_BIAS = 0x8023,
    	///
	    POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023,
    	///
	    POST_CONVOLUTION_ALPHA_SCALE = 0x801F,
    	///
	    POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F,
    	///
	    POST_CONVOLUTION_BLUE_BIAS = 0x8022,
    	///
	    POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022,
    	///
	    POST_CONVOLUTION_BLUE_SCALE = 0x801E,
    	///
	    POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E,
    	///
	    POST_CONVOLUTION_GREEN_BIAS = 0x8021,
    	///
	    POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021,
    	///
	    POST_CONVOLUTION_GREEN_SCALE = 0x801D,
    	///
	    POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D,
    	///
	    POST_CONVOLUTION_RED_BIAS = 0x8020,
    	///
	    POST_CONVOLUTION_RED_BIAS_EXT = 0x8020,
    	///
	    POST_CONVOLUTION_RED_SCALE = 0x801C,
    	///
	    POST_CONVOLUTION_RED_SCALE_EXT = 0x801C,
    	///
	    RED_BIAS = 0x0D15,
    	///
	    RED_SCALE = 0x0D14
	}

	///
	enum PixelType {
    	///
	    BITMAP = 0x1A00,
    	///
	    BYTE = 0x1400,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402,
    	///
	    UNSIGNED_BYTE = 0x1401,
    	///
	    UNSIGNED_BYTE_3_3_2 = 0x8032,
    	///
	    UNSIGNED_BYTE_3_3_2_EXT = 0x8032,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_INT_10_10_10_2 = 0x8036,
    	///
	    UNSIGNED_INT_10_10_10_2_EXT = 0x8036,
    	///
	    UNSIGNED_INT_8_8_8_8 = 0x8035,
    	///
	    UNSIGNED_INT_8_8_8_8_EXT = 0x8035,
    	///
	    UNSIGNED_SHORT = 0x1403,
    	///
	    UNSIGNED_SHORT_4_4_4_4 = 0x8033,
    	///
	    UNSIGNED_SHORT_4_4_4_4_EXT = 0x8033,
    	///
	    UNSIGNED_SHORT_5_5_5_1 = 0x8034,
    	///
	    UNSIGNED_SHORT_5_5_5_1_EXT = 0x8034
	}

	///
	enum PointParameterNameSGIS {
    	///
	    DISTANCE_ATTENUATION_EXT = 0x8129,
    	///
	    DISTANCE_ATTENUATION_SGIS = 0x8129,
    	///
	    POINT_DISTANCE_ATTENUATION = 0x8129,
    	///
	    POINT_DISTANCE_ATTENUATION_ARB = 0x8129,
    	///
	    POINT_FADE_THRESHOLD_SIZE = 0x8128,
    	///
	    POINT_FADE_THRESHOLD_SIZE_ARB = 0x8128,
    	///
	    POINT_FADE_THRESHOLD_SIZE_EXT = 0x8128,
    	///
	    POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128,
    	///
	    POINT_SIZE_MAX = 0x8127,
    	///
	    POINT_SIZE_MAX_ARB = 0x8127,
    	///
	    POINT_SIZE_MAX_EXT = 0x8127,
    	///
	    POINT_SIZE_MAX_SGIS = 0x8127,
    	///
	    POINT_SIZE_MIN = 0x8126,
    	///
	    POINT_SIZE_MIN_ARB = 0x8126,
    	///
	    POINT_SIZE_MIN_EXT = 0x8126,
    	///
	    POINT_SIZE_MIN_SGIS = 0x8126
	}

	///
	enum PolygonMode {
    	///
	    FILL = 0x1B02,
    	///
	    LINE = 0x1B01,
    	///
	    POINT = 0x1B00
	}

	///
	enum PrimitiveType {
    	///
	    LINES = 0x0001,
    	///
	    LINES_ADJACENCY = 0x000A,
    	///
	    LINES_ADJACENCY_ARB = 0x000A,
    	///
	    LINES_ADJACENCY_EXT = 0x000A,
    	///
	    LINE_LOOP = 0x0002,
    	///
	    LINE_STRIP = 0x0003,
    	///
	    LINE_STRIP_ADJACENCY = 0x000B,
    	///
	    LINE_STRIP_ADJACENCY_ARB = 0x000B,
    	///
	    LINE_STRIP_ADJACENCY_EXT = 0x000B,
    	///
	    PATCHES = 0x000E,
    	///
	    PATCHES_EXT = 0x000E,
    	///
	    POINTS = 0x0000,
    	///
	    POLYGON = 0x0009,
    	///
	    QUADS = 0x0007,
    	///
	    QUADS_EXT = 0x0007,
    	///
	    QUAD_STRIP = 0x0008,
    	///
	    TRIANGLES = 0x0004,
    	///
	    TRIANGLES_ADJACENCY = 0x000C,
    	///
	    TRIANGLES_ADJACENCY_ARB = 0x000C,
    	///
	    TRIANGLES_ADJACENCY_EXT = 0x000C,
    	///
	    TRIANGLE_FAN = 0x0006,
    	///
	    TRIANGLE_STRIP = 0x0005,
    	///
	    TRIANGLE_STRIP_ADJACENCY = 0x000D,
    	///
	    TRIANGLE_STRIP_ADJACENCY_ARB = 0x000D,
    	///
	    TRIANGLE_STRIP_ADJACENCY_EXT = 0x000D
	}

	///
	@Bitmaskable
	enum OcclusionQueryEventMaskAMD {
    	///
	    QUERY_DEPTH_PASS_EVENT_BIT_AMD = 0x00000001,
    	///
	    QUERY_DEPTH_FAIL_EVENT_BIT_AMD = 0x00000002,
    	///
	    QUERY_STENCIL_FAIL_EVENT_BIT_AMD = 0x00000004,
    	///
	    QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD = 0x00000008,
    	///
	    QUERY_ALL_EVENT_BITS_AMD = 0xFFFFFFFF
	}

	///
	enum ReadBufferMode {
    	///
	    AUX0 = 0x0409,
    	///
	    AUX1 = 0x040A,
    	///
	    AUX2 = 0x040B,
    	///
	    AUX3 = 0x040C,
    	///
	    BACK = 0x0405,
    	///
	    BACK_LEFT = 0x0402,
    	///
	    BACK_RIGHT = 0x0403,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_LEFT = 0x0400,
    	///
	    FRONT_RIGHT = 0x0401,
    	///
	    LEFT = 0x0406,
    	///
	    RIGHT = 0x0407
	}

	///
	enum RenderingMode {
    	///
	    FEEDBACK = 0x1C01,
    	///
	    RENDER = 0x1C00,
    	///
	    SELECT = 0x1C02
	}

	///
	enum SamplePatternSGIS {
    	///
	    EXT_1PASS = 0x80A1,
    	///
	    SGIS_1PASS = 0x80A1,
    	///
	    EXT_2PASS_0 = 0x80A2,
    	///
	    SGIS_2PASS_0 = 0x80A2,
    	///
	    EXT_2PASS_1 = 0x80A3,
    	///
	    SGIS_2PASS_1 = 0x80A3,
    	///
	    EXT_4PASS_0 = 0x80A4,
    	///
	    SGIS_4PASS_0 = 0x80A4,
    	///
	    EXT_4PASS_1 = 0x80A5,
    	///
	    SGIS_4PASS_1 = 0x80A5,
    	///
	    EXT_4PASS_2 = 0x80A6,
    	///
	    SGIS_4PASS_2 = 0x80A6,
    	///
	    EXT_4PASS_3 = 0x80A7,
    	///
	    SGIS_4PASS_3 = 0x80A7
	}

	///
	enum SeparableTargetEXT {
    	///
	    SEPARABLE_2D = 0x8012,
    	///
	    SEPARABLE_2D_EXT = 0x8012
	}

	///
	enum ShadingModel {
    	///
	    FLAT = 0x1D00,
    	///
	    SMOOTH = 0x1D01
	}

	///
	enum StencilFunction {
    	///
	    ALWAYS = 0x0207,
    	///
	    EQUAL = 0x0202,
    	///
	    GEQUAL = 0x0206,
    	///
	    GREATER = 0x0204,
    	///
	    LEQUAL = 0x0203,
    	///
	    LESS = 0x0201,
    	///
	    NEVER = 0x0200,
    	///
	    NOTEQUAL = 0x0205
	}

	///
	enum StencilOp {
    	///
	    DECR = 0x1E03,
    	///
	    INCR = 0x1E02,
    	///
	    INVERT = 0x150A,
    	///
	    KEEP = 0x1E00,
    	///
	    REPLACE = 0x1E01,
    	///
	    ZERO = 0
	}

	///
	enum StringName {
    	///
	    EXTENSIONS = 0x1F03,
    	///
	    RENDERER = 0x1F01,
    	///
	    VENDOR = 0x1F00,
    	///
	    VERSION = 0x1F02
	}

	///
	enum TexCoordPointerType {
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

	///
	enum TextureCoordName {
    	///
	    S = 0x2000,
    	///
	    T = 0x2001,
    	///
	    R = 0x2002,
    	///
	    Q = 0x2003
	}

	///
	enum TextureEnvMode {
    	///
	    ADD = 0x0104,
    	///
	    BLEND = 0x0BE2,
    	///
	    DECAL = 0x2101,
    	///
	    MODULATE = 0x2100,
    	///
	    REPLACE_EXT = 0x8062,
    	///
	    TEXTURE_ENV_BIAS_SGIX = 0x80BE
	}

	///
	enum TextureEnvParameter {
    	///
	    TEXTURE_ENV_COLOR = 0x2201,
    	///
	    TEXTURE_ENV_MODE = 0x2200
	}

	///
	enum TextureEnvTarget {
    	///
	    TEXTURE_ENV = 0x2300
	}

	///
	enum TextureFilterFuncSGIS {
    	///
	    FILTER4_SGIS = 0x8146
	}

	///
	enum TextureGenMode {
    	///
	    EYE_DISTANCE_TO_LINE_SGIS = 0x81F2,
    	///
	    EYE_DISTANCE_TO_POINT_SGIS = 0x81F0,
    	///
	    EYE_LINEAR = 0x2400,
    	///
	    OBJECT_DISTANCE_TO_LINE_SGIS = 0x81F3,
    	///
	    OBJECT_DISTANCE_TO_POINT_SGIS = 0x81F1,
    	///
	    OBJECT_LINEAR = 0x2401,
    	///
	    SPHERE_MAP = 0x2402
	}

	///
	enum TextureGenParameter {
    	///
	    EYE_LINE_SGIS = 0x81F6,
    	///
	    EYE_PLANE = 0x2502,
    	///
	    EYE_POINT_SGIS = 0x81F4,
    	///
	    OBJECT_LINE_SGIS = 0x81F7,
    	///
	    OBJECT_PLANE = 0x2501,
    	///
	    OBJECT_POINT_SGIS = 0x81F5,
    	///
	    TEXTURE_GEN_MODE = 0x2500
	}

	///
	enum TextureMagFilter {
    	///
	    FILTER4_SGIS = 0x8146,
    	///
	    LINEAR = 0x2601,
    	///
	    LINEAR_DETAIL_ALPHA_SGIS = 0x8098,
    	///
	    LINEAR_DETAIL_COLOR_SGIS = 0x8099,
    	///
	    LINEAR_DETAIL_SGIS = 0x8097,
    	///
	    LINEAR_SHARPEN_ALPHA_SGIS = 0x80AE,
    	///
	    LINEAR_SHARPEN_COLOR_SGIS = 0x80AF,
    	///
	    LINEAR_SHARPEN_SGIS = 0x80AD,
    	///
	    NEAREST = 0x2600,
    	///
	    PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184,
    	///
	    PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186,
    	///
	    PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185
	}

	///
	enum TextureMinFilter {
    	///
	    FILTER4_SGIS = 0x8146,
    	///
	    LINEAR = 0x2601,
    	///
	    LINEAR_CLIPMAP_LINEAR_SGIX = 0x8170,
    	///
	    LINEAR_CLIPMAP_NEAREST_SGIX = 0x844F,
    	///
	    LINEAR_MIPMAP_LINEAR = 0x2703,
    	///
	    LINEAR_MIPMAP_NEAREST = 0x2701,
    	///
	    NEAREST = 0x2600,
    	///
	    NEAREST_CLIPMAP_LINEAR_SGIX = 0x844E,
    	///
	    NEAREST_CLIPMAP_NEAREST_SGIX = 0x844D,
    	///
	    NEAREST_MIPMAP_LINEAR = 0x2702,
    	///
	    NEAREST_MIPMAP_NEAREST = 0x2700,
    	///
	    PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184,
    	///
	    PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186,
    	///
	    PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185
	}

	///
	enum TextureParameterName {
    	///
	    DETAIL_TEXTURE_LEVEL_SGIS = 0x809A,
    	///
	    DETAIL_TEXTURE_MODE_SGIS = 0x809B,
    	///
	    DUAL_TEXTURE_SELECT_SGIS = 0x8124,
    	///
	    GENERATE_MIPMAP = 0x8191,
    	///
	    GENERATE_MIPMAP_SGIS = 0x8191,
    	///
	    POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179,
    	///
	    POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A,
    	///
	    QUAD_TEXTURE_SELECT_SGIS = 0x8125,
    	///
	    SHADOW_AMBIENT_SGIX = 0x80BF,
    	///
	    TEXTURE_BORDER_COLOR = 0x1004,
    	///
	    TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171,
    	///
	    TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176,
    	///
	    TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172,
    	///
	    TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175,
    	///
	    TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173,
    	///
	    TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174,
    	///
	    TEXTURE_COMPARE_SGIX = 0x819A,
    	///
	    TEXTURE_LOD_BIAS_R_SGIX = 0x8190,
    	///
	    TEXTURE_LOD_BIAS_S_SGIX = 0x818E,
    	///
	    TEXTURE_LOD_BIAS_T_SGIX = 0x818F,
    	///
	    TEXTURE_MAG_FILTER = 0x2800,
    	///
	    TEXTURE_MAX_CLAMP_R_SGIX = 0x836B,
    	///
	    TEXTURE_MAX_CLAMP_S_SGIX = 0x8369,
    	///
	    TEXTURE_MAX_CLAMP_T_SGIX = 0x836A,
    	///
	    TEXTURE_MIN_FILTER = 0x2801,
    	///
	    TEXTURE_PRIORITY = 0x8066,
    	///
	    TEXTURE_PRIORITY_EXT = 0x8066,
    	///
	    TEXTURE_WRAP_Q_SGIS = 0x8137,
    	///
	    TEXTURE_WRAP_R = 0x8072,
    	///
	    TEXTURE_WRAP_R_EXT = 0x8072,
    	///
	    TEXTURE_WRAP_R_OES = 0x8072,
    	///
	    TEXTURE_WRAP_S = 0x2802,
    	///
	    TEXTURE_WRAP_T = 0x2803
	}

	///
	enum TextureTarget {
    	///
	    DETAIL_TEXTURE_2D_SGIS = 0x8095,
    	///
	    PROXY_TEXTURE_1D = 0x8063,
    	///
	    PROXY_TEXTURE_1D_EXT = 0x8063,
    	///
	    PROXY_TEXTURE_2D = 0x8064,
    	///
	    PROXY_TEXTURE_2D_EXT = 0x8064,
    	///
	    PROXY_TEXTURE_3D = 0x8070,
    	///
	    PROXY_TEXTURE_3D_EXT = 0x8070,
    	///
	    PROXY_TEXTURE_4D_SGIS = 0x8135,
    	///
	    TEXTURE_1D = 0x0DE0,
    	///
	    TEXTURE_2D = 0x0DE1,
    	///
	    TEXTURE_3D = 0x806F,
    	///
	    TEXTURE_3D_EXT = 0x806F,
    	///
	    TEXTURE_3D_OES = 0x806F,
    	///
	    TEXTURE_4D_SGIS = 0x8134,
    	///
	    TEXTURE_BASE_LEVEL = 0x813C,
    	///
	    TEXTURE_BASE_LEVEL_SGIS = 0x813C,
    	///
	    TEXTURE_MAX_LEVEL = 0x813D,
    	///
	    TEXTURE_MAX_LEVEL_SGIS = 0x813D,
    	///
	    TEXTURE_MAX_LOD = 0x813B,
    	///
	    TEXTURE_MAX_LOD_SGIS = 0x813B,
    	///
	    TEXTURE_MIN_LOD = 0x813A,
    	///
	    TEXTURE_MIN_LOD_SGIS = 0x813A
	}

	///
	enum TextureWrapMode {
    	///
	    CLAMP = 0x2900,
    	///
	    CLAMP_TO_BORDER = 0x812D,
    	///
	    CLAMP_TO_BORDER_ARB = 0x812D,
    	///
	    CLAMP_TO_BORDER_NV = 0x812D,
    	///
	    CLAMP_TO_BORDER_SGIS = 0x812D,
    	///
	    CLAMP_TO_EDGE = 0x812F,
    	///
	    CLAMP_TO_EDGE_SGIS = 0x812F,
    	///
	    REPEAT = 0x2901
	}

	///
	@Bitmaskable
	enum UseProgramStageMask {
    	///
	    VERTEX_SHADER_BIT = 0x00000001,
    	///
	    VERTEX_SHADER_BIT_EXT = 0x00000001,
    	///
	    FRAGMENT_SHADER_BIT = 0x00000002,
    	///
	    FRAGMENT_SHADER_BIT_EXT = 0x00000002,
    	///
	    GEOMETRY_SHADER_BIT = 0x00000004,
    	///
	    GEOMETRY_SHADER_BIT_EXT = 0x00000004,
    	///
	    TESS_CONTROL_SHADER_BIT = 0x00000008,
    	///
	    TESS_CONTROL_SHADER_BIT_EXT = 0x00000008,
    	///
	    TESS_EVALUATION_SHADER_BIT = 0x00000010,
    	///
	    TESS_EVALUATION_SHADER_BIT_EXT = 0x00000010,
    	///
	    COMPUTE_SHADER_BIT = 0x00000020,
    	///
	    ALL_SHADER_BITS = 0xFFFFFFFF,
    	///
	    ALL_SHADER_BITS_EXT = 0xFFFFFFFF
	}

	///
	enum VertexPointerType {
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

extern(C) {

    /++
     + glTexGen: man2/glTexGen.xml
     + 
     + $(D_INLINECODE glTexGen) selects a texture-coordinate generation function or supplies coefficients for one of the functions. $(D_INLINECODE coord) names one of the (,,, ) texture coordinates; it must be one of the symbols $(D_INLINECODE GL_S), $(D_INLINECODE GL_T), $(D_INLINECODE GL_R), or $(D_INLINECODE GL_Q). $(D_INLINECODE pname) must be one of three symbolic constants: $(D_INLINECODE GL_TEXTURE_GEN_MODE), $(D_INLINECODE GL_OBJECT_PLANE), or $(D_INLINECODE GL_EYE_PLANE). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_GEN_MODE), then $(D_INLINECODE params) chooses a mode, one of $(D_INLINECODE GL_OBJECT_LINEAR), $(D_INLINECODE GL_EYE_LINEAR), $(D_INLINECODE GL_SPHERE_MAP), $(D_INLINECODE GL_NORMAL_MAP), or $(D_INLINECODE GL_REFLECTION_MAP). If $(D_INLINECODE pname) is either $(D_INLINECODE GL_OBJECT_PLANE) or $(D_INLINECODE GL_EYE_PLANE), $(D_INLINECODE params) contains coefficients for the corresponding texture generation function. If the texture generation function is $(D_INLINECODE GL_OBJECT_LINEAR), the function g = p 1 &times; x o + p 2 &times; y o + p 3 &times; z o + p 4 &times; w o is used, where g is the value computed for the coordinate named in $(D_INLINECODE coord), p 1, p 2, p 3, and p 4 are the four values supplied in $(D_INLINECODE params), and x o, y o, z o, and w o are the object coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a reference plane (defined by p 1, p 2, p 3, and p 4 ). The altitude of a terrain vertex is computed by the $(D_INLINECODE GL_OBJECT_LINEAR) coordinate generation function as its distance from sea level; that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto foothills. If the texture generation function is $(D_INLINECODE GL_EYE_LINEAR), the function g = p 1 &Prime; &times; x e + p 2 &Prime; &times; y e + p 3 &Prime; &times; z e + p 4 &Prime; &times; w e is used, where p 1 &Prime; &it; p 2 &Prime; &it; p 3 &Prime; &it; p 4 &Prime; = p 1 &it; p 2 &it; p 3 &it; p 4 &it; M -1 and x e, y e, z e, and w e are the eye coordinates of the vertex, p 1, p 2, p 3, and p 4 are the values supplied in $(D_INLINECODE params), and M is the modelview matrix when $(D_INLINECODE glTexGen) is invoked. If M is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined. Note that the values in $(D_INLINECODE params) define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects. If the texture generation function is $(D_INLINECODE GL_SPHERE_MAP) and $(D_INLINECODE coord) is either $(D_INLINECODE GL_S) or $(D_INLINECODE GL_T), s and t texture coordinates are generated as follows. Let be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let sup prime be the current normal, after transformation to eye coordinates. Let f = f x &it; f y &it; f z T be the reflection vector such that f = u - 2 &it; n &Prime; &it; n &Prime; T &it; u Finally, let m = 2 &it; f x 2 + f y 2 + f z + 1 2. Then the values assigned to the s and t texture coordinates are s = f x m + 1 2 t = f y m + 1 2 To enable or disable a texture-coordinate generation function, call $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable) with one of the symbolic texture-coordinate names ( $(D_INLINECODE GL_TEXTURE_GEN_S), $(D_INLINECODE GL_TEXTURE_GEN_T), $(D_INLINECODE GL_TEXTURE_GEN_R), or $(D_INLINECODE GL_TEXTURE_GEN_Q) ) as the argument. When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to $(D_INLINECODE GL_EYE_LINEAR) and are disabled. Both s plane equations are (1, 0, 0, 0), both t plane equations are (0, 1, 0, 0), and all r and q plane equations are (0, 0, 0, 0). When the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexGen) sets the texture generation parameters for the currently active texture unit, selected with $(D_INLINECODE glActiveTexture).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGeni(GLenum coord, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGenf(GLenum coord, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGend(GLenum coord, GLenum pname, GLdouble param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGeniv(GLenum coord, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGenfv(GLenum coord, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexGendv(GLenum coord, GLenum pname, const GLdouble* params) @system @nogc nothrow;

    /++
     + glGetUniformLocation: man2/glGetUniformLocation.xml
     + 
     + $(D_INLINECODE glGetUniformLocation) returns an integer that represents the location of a specific uniform variable within a program object. $(D_INLINECODE name) must be a null terminated string that contains no white space. $(D_INLINECODE name) must be an active uniform variable name in $(D_INLINECODE program) that is not a structure, an array of structures, or a subcomponent of a vector or a matrix. This function returns -1 if $(D_INLINECODE name) does not correspond to an active uniform variable in $(D_INLINECODE program) or if $(D_INLINECODE name) starts with the reserved prefix &quot;gl_&quot;. Uniform variables that are structures or arrays of structures may be queried by calling $(D_INLINECODE glGetUniformLocation) for each field within the structure. The array element operator &quot;[]&quot; and the structure field operator &quot;.&quot; may be used in $(D_INLINECODE name) in order to select elements within an array or fields within a structure. The result of using these operators is not allowed to be another structure, an array of structures, or a subcomponent of a vector or a matrix. Except if the last part of $(D_INLINECODE name) indicates a uniform variable array, the location of the first element of an array can be retrieved by using the name of the array, or by using the name appended by &quot;[0]&quot;. The actual locations assigned to uniform variables are not known until the program object is linked successfully. After linking has occurred, the command $(D_INLINECODE glGetUniformLocation) can be used to obtain the location of a uniform variable. This location value can then be passed to $(D_INLINECODE glUniform) to set the value of the uniform variable or to $(D_INLINECODE glGetUniform) in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. Uniform variable locations and values can only be queried after a link if the link was successful.
     + 
     + $(D_INLINECODE glGetUniformLocation) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLint glGetUniformLocation(GLuint program, const GLchar* name) @system @nogc nothrow;

    /++
     + glTexSubImage1D: man2/glTexSubImage1D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable or disable one-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_1D). $(D_INLINECODE glTexSubImage1D) redefines a contiguous subregion of an existing one-dimensional texture image. The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glTexSubImage1D) is available only if the GL version is 1.1 or greater. Texturing has no effect in color index mode. $(D_INLINECODE glPixelStore) and $(D_INLINECODE glPixelTransfer) modes affect texture images in exactly the way they affect $(D_INLINECODE glDrawPixels). Formats $(D_INLINECODE GL_BGR), and $(D_INLINECODE GL_BGRA) and types $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) are available only if the GL version is 1.2 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexSubImage1D) specifies a one-dimensional subtexture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). When the $(D_INLINECODE ARB_imaging) extension is supported, the RGBA components specified in $(D_INLINECODE data) may be processed by the imaging pipeline.  See $(D_INLINECODE glTexImage1D) for specific details.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + gluOrtho2D: man2/gluOrtho2D.xml
     + 
     + $(D_INLINECODE gluOrtho2D) sets up a two-dimensional orthographic viewing region. This is equivalent to calling $(D_INLINECODE glOrtho) with near = -1 and far = 1.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glOrtho), $(D_INLINECODE gluPerspective)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top) @system @nogc nothrow;

    /++
     + glSecondaryColorPointer: man2/glSecondaryColorPointer.xml
     + 
     + $(D_INLINECODE glSecondaryColorPointer) specifies the location and data format of an array of color components to use when rendering. $(D_INLINECODE size) specifies the number of components per color, and must be 3. $(D_INLINECODE type) specifies the data type of each color component, and $(D_INLINECODE stride) specifies the byte stride from one color to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a secondary color array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as secondary color vertex array client-side state ( $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING) ). When a secondary color array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the secondary color array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY). If enabled, the secondary color array is used when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glDrawRangeElements) is called.
     + 
     + $(D_INLINECODE glSecondaryColorPointer) is available only if the GL version is 1.4 or greater. Secondary colors are not supported for interleaved vertex array formats (see $(D_INLINECODE glInterleavedArrays) ). The secondary color array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glSecondaryColorPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glSecondaryColorPointer) is typically implemented on the client side. Secondary color array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib).  Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColor), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + gluSphere: man2/gluSphere.xml
     + 
     + $(D_INLINECODE gluSphere) draws a sphere of the given radius centered around the origin. The sphere is subdivided around the axis into slices and along the axis into stacks (similar to lines of longitude and latitude). If the orientation is set to $(D_INLINECODE GLU_OUTSIDE) (with $(D_INLINECODE gluQuadricOrientation) ), then any normals generated point away from the center of the sphere. Otherwise, they point toward the center of the sphere. If texturing is turned on (with $(D_INLINECODE gluQuadricTexture) ), then texture coordinates are generated so that ranges from 0.0 at z = - radius to 1.0 at z = radius ( increases linearly along longitudinal lines), and ranges from 0.0 at the + axis, to 0.25 at the + axis, to 0.5 at the \- axis, to 0.75 at the \- axis, and back to 1.0 at the + axis.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluCylinder), $(D_INLINECODE gluDisk), $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluPartialDisk), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluSphere(GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks) @system @nogc nothrow;

    /++
     + gluDeleteQuadric: man2/gluDeleteQuadric.xml
     + 
     + $(D_INLINECODE gluDeleteQuadric) destroys the quadrics object (created with $(D_INLINECODE gluNewQuadric) ) and frees any memory it uses. Once $(D_INLINECODE gluDeleteQuadric) has been called, $(D_INLINECODE quad) cannot be used again.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluDeleteQuadric(GLUquadric* quad) @system @nogc nothrow;

    /++
     + glTexSubImage3D: man2/glTexSubImage3D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable three-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_3D). $(D_INLINECODE glTexSubImage3D) redefines a contiguous subregion of an existing three-dimensional texture image. The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive, y indices $(D_INLINECODE yoffset) and yoffset + height - 1, inclusive, and z indices $(D_INLINECODE zoffset) and zoffset + depth - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width, height, or depth but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glTexSubImage3D) is available only if the GL version is 1.2 or greater. Texturing has no effect in color index mode. $(D_INLINECODE glPixelStore) and $(D_INLINECODE glPixelTransfer) modes affect texture images in exactly the way they affect $(D_INLINECODE glDrawPixels). Formats $(D_INLINECODE GL_BGR), and $(D_INLINECODE GL_BGRA) and types $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) are available only if the GL version is 1.2 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexSubImage3D) specifies a three-dimensional subtexture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). When the $(D_INLINECODE ARB_imaging) extension is supported, the RGBA components specified in $(D_INLINECODE data) may be processed by the imaging pipeline.  See $(D_INLINECODE glTexImage3D) for specific details.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glStencilFuncSeparate: man2/glStencilFuncSeparate.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST). To specify actions based on the outcome of the stencil test, call $(D_INLINECODE glStencilOp) or $(D_INLINECODE glStencilOpSeparate). There can be two separate sets of $(D_INLINECODE func), $(D_INLINECODE ref), and $(D_INLINECODE mask) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilFunc) sets both front and back stencil state to the same values, as if $(D_INLINECODE glStencilFuncSeparate) were called with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK). $(D_INLINECODE func) is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. $(D_INLINECODE ref) is an integer reference value that is used in the stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. $(D_INLINECODE mask) is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison. If represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by $(D_INLINECODE func). Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see $(D_INLINECODE glStencilOp) ). All tests treat values as unsigned integers in the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The following values are accepted by $(D_INLINECODE func) :
     + 
     + $(D_INLINECODE glStencilFuncSeparate) is available only if the GL version is 2.0 or greater. Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref_, GLuint mask) @system @nogc nothrow;

    /++
     + glMapGrid: man2/glMapGrid.xml
     + 
     + $(D_INLINECODE glMapGrid) and $(D_INLINECODE glEvalMesh) are used together to efficiently generate and evaluate a series of evenly-spaced map domain values. $(D_INLINECODE glEvalMesh) steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2). $(D_INLINECODE glMapGrid1) and $(D_INLINECODE glMapGrid2) specify the linear grid mappings between the i (or i and j ) integer grid coordinates, to the u (or u and v ) floating-point evaluation map coordinates. See $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2) for details of how u and v coordinates are evaluated. $(D_INLINECODE glMapGrid1) specifies a single linear mapping such that integer grid coordinate 0 maps exactly to $(D_INLINECODE u1), and integer grid coordinate $(D_INLINECODE un) maps exactly to $(D_INLINECODE u2). All other integer grid coordinates i are mapped so that u = i &af; u2 - u1 un + u1 $(D_INLINECODE glMapGrid2) specifies two such linear mappings. One maps integer grid coordinate i = 0 exactly to $(D_INLINECODE u1), and integer grid coordinate i = un exactly to $(D_INLINECODE u2). The other maps integer grid coordinate j = 0 exactly to $(D_INLINECODE v1), and integer grid coordinate j = vn exactly to $(D_INLINECODE v2). Other integer grid coordinates i and j are mapped such that u = i &af; u2 - u1 un + u1 v = j &af; v2 - v1 vn + v1 The mappings specified by $(D_INLINECODE glMapGrid) are used identically by $(D_INLINECODE glEvalMesh) and $(D_INLINECODE glEvalPoint).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) @system @nogc nothrow;

    /++
     + glGetColorTable: man2/glGetColorTable.xml
     + 
     + $(D_INLINECODE glGetColorTable) returns in $(D_INLINECODE table) the contents of the color table specified by $(D_INLINECODE target). No pixel transfer operations are performed, but pixel storage modes that are applicable to $(D_INLINECODE glReadPixels) are performed. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a histogram table is requested, $(D_INLINECODE table) is treated as a byte offset into the buffer object's data store. Color components that are requested in the specified $(D_INLINECODE format), but which are not included in the internal format of the color lookup table, are returned as zero.  The assignments of internal color components to the components requested by $(D_INLINECODE format) are $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red Intensity Red
     + 
     + $(D_INLINECODE glGetColorTable) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glColorTableParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid* table) @system @nogc nothrow;

    /++
     + gluUnProject: man2/gluUnProject.xml
     + 
     + $(D_INLINECODE gluUnProject) maps the specified window coordinates into object coordinates using $(D_INLINECODE model), $(D_INLINECODE proj), and $(D_INLINECODE view). The result is stored in $(D_INLINECODE objX), $(D_INLINECODE objY), and $(D_INLINECODE objZ). A return value of $(D_INLINECODE GLU_TRUE) indicates success; a return value of $(D_INLINECODE GLU_FALSE) indicates failure. To compute the coordinates objX objY objZ, $(D_INLINECODE gluUnProject) multiplies the normalized device coordinates by the inverse of $(D_INLINECODE model) * $(D_INLINECODE proj) as follows: objX objY objZ W = INV &af; P &it; M &it; 2 &af; winX - view &af; 0 view &af; 2 - 1 2 &af; winY - view &af; 1 view &af; 3 - 1 2 &af; winZ - 1 1 INV denotes matrix inversion. W is an unused variable, included for consistent matrix notation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluProject), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble* model, const GLdouble* proj, const GLint* view, GLdouble* objX, GLdouble* objY, GLdouble* objZ) @system @nogc nothrow;

    /++
     + gluNurbsCallbackDataEXT: man2/gluNurbsCallbackDataEXT.xml
     + 
     + $(D_INLINECODE gluNurbsCallbackDataEXT) is used to pass a pointer to the application's data to NURBS tessellator. A copy of this pointer will be passed by the tessellator in the NURBS callback functions (set by $(D_INLINECODE gluNurbsCallback) ).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNurbsCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluNurbsCallbackDataEXT(GLUnurbs* nurb, GLvoid* userData) @system @nogc nothrow;

    /++
     + gluTessBeginContour: man2/gluTessBeginContour.xml
     + 
     + $(D_INLINECODE gluTessBeginContour) and $(D_INLINECODE gluTessEndContour) delimit the definition of a polygon contour. Within each $(D_INLINECODE gluTessBeginContour) / $(D_INLINECODE gluTessEndContour) pair, there can be zero or more calls to $(D_INLINECODE gluTessVertex). The vertices specify a closed contour (the last vertex of each contour is automatically linked to the first).  See the $(D_INLINECODE gluTessVertex) reference page for more details. $(D_INLINECODE gluTessBeginContour) can only be called between $(D_INLINECODE gluTessBeginPolygon) and $(D_INLINECODE gluTessEndPolygon).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessEndPolygon), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluTessBeginContour(GLUtesselator* tess) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluTessEndContour(GLUtesselator* tess) @system @nogc nothrow;

    /++
     + glInterleavedArrays: man2/glInterleavedArrays.xml
     + 
     + $(D_INLINECODE glInterleavedArrays) lets you specify and enable individual color, normal, texture and vertex arrays whose elements are part of a larger aggregate array element. For some implementations, this is more efficient than specifying the arrays separately. If $(D_INLINECODE stride) is 0, the aggregate elements are stored consecutively. Otherwise, $(D_INLINECODE stride) bytes occur between the beginning of one aggregate array element and the beginning of the next aggregate array element. $(D_INLINECODE format) serves as a ``key'' describing the extraction of individual arrays from the aggregate array. If $(D_INLINECODE format) contains a T, then texture coordinates are extracted from the interleaved array.  If C is present, color values are extracted. If N is present, normal coordinates are extracted. Vertex coordinates are always extracted. The digits 2, 3, and 4 denote how many values are extracted. F indicates that values are extracted as floating-point values. Colors may also be extracted as 4 unsigned bytes if 4UB follows the C.  If a color is extracted as 4 unsigned bytes, the vertex array element which follows is located at the first possible floating-point aligned address.
     + 
     + $(D_INLINECODE glInterleavedArrays) is available only if the GL version is 1.1 or greater. If $(D_INLINECODE glInterleavedArrays) is called while compiling a display list, it is not compiled into the list, and it is executed immediately. Execution of $(D_INLINECODE glInterleavedArrays) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glInterleavedArrays) is typically implemented on the client side. Vertex array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glInterleavedArrays) only updates the texture coordinate array for the client active texture unit. The texture coordinate state for other client texture units is not updated, regardless of whether the client texture unit is enabled or not. Secondary color values are not supported in interleaved vertex array formats.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + glShaderSource: man2/glShaderSource.xml
     + 
     + $(D_INLINECODE glShaderSource) sets the source code in $(D_INLINECODE shader) to the source code in the array of strings specified by $(D_INLINECODE string). Any source code previously stored in the shader object is completely replaced. The number of strings in the array is specified by $(D_INLINECODE count). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), each string is assumed to be null terminated. If $(D_INLINECODE length) is a value other than $(D_INLINECODE null
     + ), it points to an array containing a string length for each of the corresponding elements of $(D_INLINECODE string). Each element in the $(D_INLINECODE length) array may contain the length of the corresponding string (the null character is not counted as part of the string length) or a value less than 0 to indicate that the string is null terminated. The source code strings are not scanned or parsed at this time; they are simply copied into the specified shader object.
     + 
     + $(D_INLINECODE glShaderSource) is available only if the GL version is 2.0 or greater. OpenGL copies the shader source code strings when $(D_INLINECODE glShaderSource) is called, so an application may free its copy of the source code strings immediately after the function returns.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glShaderSource(GLuint shader, GLsizei count, const GLchar** string, const GLint* length) @system @nogc nothrow;

    /++
     + gluTessNormal: man2/gluTessNormal.xml
     + 
     + $(D_INLINECODE gluTessNormal) describes a normal for a polygon that the program is defining. All input data will be projected onto a plane perpendicular to one of the three coordinate axes before tessellation and all output triangles will be oriented CCW with respect to the normal (CW orientation can be obtained by reversing the sign of the supplied normal). For example, if you know that all polygons lie in the x-y plane, call $(D_INLINECODE gluTessNormal) (tess, 0.0, 0.0, 1.0) before rendering any polygons. If the supplied normal is (0.0, 0.0, 0.0) (the initial value), the normal is determined as follows. The direction of the normal, up to its sign, is found by fitting a plane to the vertices, without regard to how the vertices are connected. It is expected that the input data lies approximately in the plane; otherwise, projection perpendicular to one of the three coordinate axes may substantially change the geometry. The sign of the normal is chosen so that the sum of the signed areas of all input contours is nonnegative (where a CCW contour has positive area). The supplied normal persists until it is changed by another call to $(D_INLINECODE gluTessNormal).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessEndPolygon)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluTessNormal(GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ) @system @nogc nothrow;

    /++
     + glCreateShader: man2/glCreateShader.xml
     + 
     + $(D_INLINECODE glCreateShader) creates an empty shader object and returns a non-zero value by which it can be referenced. A shader object is used to maintain the source code strings that define a shader. $(D_INLINECODE shaderType) indicates the type of shader to be created. Two types of shaders are supported. A shader of type $(D_INLINECODE GL_VERTEX_SHADER) is a shader that is intended to run on the programmable vertex processor and replace the fixed functionality vertex processing in OpenGL. A shader of type $(D_INLINECODE GL_FRAGMENT_SHADER) is a shader that is intended to run on the programmable fragment processor and replace the fixed functionality fragment processing in OpenGL. When created, a shader object's $(D_INLINECODE GL_SHADER_TYPE) parameter is set to either $(D_INLINECODE GL_VERTEX_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER), depending on the value of $(D_INLINECODE shaderType).
     + 
     + $(D_INLINECODE glCreateShader) is available only if the GL version is 2.0 or greater. Like display lists and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well. Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glCompileShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLuint glCreateShader(GLenum shaderType) @system @nogc nothrow;

    /++
     + glRect: man2/glRect.xml
     + 
     + $(D_INLINECODE glRect) supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of x y coordinates or as two pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0 plane. $(D_INLINECODE glRect) ( $(D_INLINECODE x1), $(D_INLINECODE y1), $(D_INLINECODE x2), $(D_INLINECODE y2) ) is exactly equivalent to the following sequence:
     + 
     + ---
     + glBegin( $(D_INLINECODE GL_POLYGON));
     + glVertex2( $(D_INLINECODE x1),  $(D_INLINECODE y1));
     + glVertex2( $(D_INLINECODE x2),  $(D_INLINECODE y1));
     + glVertex2( $(D_INLINECODE x2),  $(D_INLINECODE y2));
     + glVertex2( $(D_INLINECODE x1),  $(D_INLINECODE y2));
     + glEnd();
     +         
     + ---
     +  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRecti(GLint x1, GLint y1, GLint x2, GLint y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectdv(const GLdouble* v1, const GLdouble* v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectfv(const GLfloat* v1, const GLfloat* v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectiv(const GLint* v1, const GLint* v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRectsv(const GLshort* v1, const GLshort* v2) @system @nogc nothrow;

    /++
     + glCopyColorSubTable: man2/glCopyColorSubTable.xml
     + 
     + $(D_INLINECODE glCopyColorSubTable) is used to respecify a contiguous portion of a color table previously defined using $(D_INLINECODE glColorTable).  The pixels copied from the framebuffer replace the portion of the existing table from indices $(D_INLINECODE start) to start + x - 1, inclusive.  This region may not include any entries outside the range of the color table, as was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.
     + 
     + $(D_INLINECODE glCopyColorSubTable) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorSubTable), $(D_INLINECODE glColorTableParameter), $(D_INLINECODE glCopyColorTable), $(D_INLINECODE glCopyColorSubTable), $(D_INLINECODE glGetColorTable)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) @system @nogc nothrow;

    /++
     + gluBeginTrim: man2/gluBeginTrim.xml
     + 
     + Use $(D_INLINECODE gluBeginTrim) to mark the beginning of a trimming loop and $(D_INLINECODE gluEndTrim) to mark the end of a trimming loop. A trimming loop is a set of oriented curve segments (forming a closed curve) that define boundaries of a NURBS surface. You include these trimming loops in the definition of a NURBS surface, between calls to $(D_INLINECODE gluBeginSurface) and $(D_INLINECODE gluEndSurface). The definition for a NURBS surface can contain many trimming loops. For example, if you wrote a definition for a NURBS surface that resembled a rectangle with a hole punched out, the definition would contain two trimming loops. One loop would define the outer edge of the rectangle; the other would define the hole punched out of the rectangle. The definitions of each of these trimming loops would be bracketed by a $(D_INLINECODE gluBeginTrim) / $(D_INLINECODE gluEndTrim) pair. The definition of a single closed trimming loop can consist of multiple curve segments, each described as a piecewise linear curve (see $(D_INLINECODE gluPwlCurve) ) or as a single NURBS curve (see $(D_INLINECODE gluNurbsCurve) ), or as a combination of both in any order. The only library calls that can appear in a trimming loop definition (between the calls to $(D_INLINECODE gluBeginTrim) and $(D_INLINECODE gluEndTrim) ) are $(D_INLINECODE gluPwlCurve) and $(D_INLINECODE gluNurbsCurve). The area of the NURBS surface that is displayed is the region in the domain to the left of the trimming curve as the curve parameter increases. Thus, the retained region of the NURBS surface is inside a counterclockwise trimming loop and outside a clockwise trimming loop. For the rectangle mentioned earlier, the trimming loop for the outer edge of the rectangle runs counterclockwise, while the trimming loop for the punched-out hole runs clockwise. If you use more than one curve to define a single trimming loop, the curve segments must form a closed loop (that is, the endpoint of each curve must be the starting point of the next curve, and the endpoint of the final curve must be the starting point of the first curve). If the endpoints of the curve are sufficiently close together but not exactly coincident, they will be coerced to match. If the endpoints are not sufficiently close, an error results (see $(D_INLINECODE gluNurbsCallback) ). If a trimming loop definition contains multiple curves, the direction of the curves must be consistent (that is, the inside must be to the left of all of the curves). Nested trimming loops are legal as long as the curve orientations alternate correctly. If trimming curves are self-intersecting, or intersect one another, an error results. If no trimming information is given for a NURBS surface, the entire surface is drawn.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginSurface), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCallback), $(D_INLINECODE gluNurbsCurve), $(D_INLINECODE gluPwlCurve)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluBeginTrim(GLUnurbs* nurb) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluEndTrim(GLUnurbs* nurb) @system @nogc nothrow;

    /++
     + glMapBuffer: man2/glMapBuffer.xml
     + 
     + $(D_INLINECODE glMapBuffer) maps to the client's address space the entire data store of the buffer object currently bound to $(D_INLINECODE target). The data can then be directly read and/or written relative to the returned pointer, depending on the specified $(D_INLINECODE access) policy. If the GL is unable to map the buffer object's data store, $(D_INLINECODE glMapBuffer) generates an error and returns $(D_INLINECODE null
     + ). This may occur for system-specific reasons, such as low virtual memory availability. If a mapped data store is accessed in a way inconsistent with the specified $(D_INLINECODE access) policy, no error is generated, but performance may be negatively impacted and system errors, including program termination, may result. Unlike the $(D_INLINECODE usage) parameter of $(D_INLINECODE glBufferData), $(D_INLINECODE access) is not a hint, and does in fact constrain the usage of the mapped data store on some GL implementations. In order to achieve the highest performance available, a buffer object's data store should be used in ways consistent with both its specified $(D_INLINECODE usage) and $(D_INLINECODE access) parameters. A mapped data store must be unmapped with $(D_INLINECODE glUnmapBuffer) before its buffer object is used. Otherwise an error will be generated by any GL command that attempts to dereference the buffer object's data store. When a data store is unmapped, the pointer to its data store becomes invalid. $(D_INLINECODE glUnmapBuffer) returns $(D_INLINECODE GL_TRUE) unless the data store contents have become corrupt during the time the data store was mapped. This can occur for system-specific reasons that affect the availability of graphics memory, such as screen mode changes. In such situations, $(D_INLINECODE GL_FALSE) is returned and the data store contents are undefined. An application must detect this rare condition and reinitialize the data store. A buffer object's mapped data store is automatically unmapped when the buffer object is deleted or its data store is recreated with $(D_INLINECODE glBufferData).
     + 
     + If an error is generated, $(D_INLINECODE glMapBuffer) returns $(D_INLINECODE null
     + ), and $(D_INLINECODE glUnmapBuffer) returns $(D_INLINECODE GL_FALSE). $(D_INLINECODE glMapBuffer) and $(D_INLINECODE glUnmapBuffer) are available only if the GL version is 1.5 or greater. $(D_INLINECODE GL_PIXEL_PACK_BUFFER) and $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) are available only if the GL version is 2.1 or greater. Parameter values passed to GL commands may not be sourced from the returned pointer. No error will be generated, but results will be undefined and will likely vary across GL implementations.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glDeleteBuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void* glMapBuffer(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    GLboolean glUnmapBuffer(GLenum target) @system @nogc nothrow;

    /++
     + glPushAttrib: man2/glPushAttrib.xml
     + 
     + $(D_INLINECODE glPushAttrib) takes one argument, a mask that indicates which groups of state variables to save on the attribute stack. Symbolic constants are used to set bits in the mask. $(D_INLINECODE mask) is typically constructed by specifying the bitwise-or of several of these constants together. The special mask $(D_INLINECODE GL_ALL_ATTRIB_BITS) can be used to save all stackable states. The symbolic mask constants and their associated GL state are as follows (the second column lists which attributes are saved): $(D_INLINECODE GL_ACCUM_BUFFER_BIT) Accumulation buffer clear value $(D_INLINECODE GL_COLOR_BUFFER_BIT) $(D_INLINECODE GL_ALPHA_TEST) enable bit Alpha test function and reference value $(D_INLINECODE GL_BLEND) enable bit Blending source and destination functions Constant blend color Blending equation $(D_INLINECODE GL_DITHER) enable bit $(D_INLINECODE GL_DRAW_BUFFER) setting $(D_INLINECODE GL_COLOR_LOGIC_OP) enable bit $(D_INLINECODE GL_INDEX_LOGIC_OP) enable bit Logic op function Color mode and index mode clear values Color mode and index mode writemasks $(D_INLINECODE GL_CURRENT_BIT) Current RGBA color Current color index Current normal vector Current texture coordinates Current raster position $(D_INLINECODE GL_CURRENT_RASTER_POSITION_VALID) flag RGBA color associated with current raster position Color index associated with current raster position Texture coordinates associated with current raster position $(D_INLINECODE GL_EDGE_FLAG) flag $(D_INLINECODE GL_DEPTH_BUFFER_BIT) $(D_INLINECODE GL_DEPTH_TEST) enable bit Depth buffer test function Depth buffer clear value $(D_INLINECODE GL_DEPTH_WRITEMASK) enable bit $(D_INLINECODE GL_ENABLE_BIT) $(D_INLINECODE GL_ALPHA_TEST) flag $(D_INLINECODE GL_AUTO_NORMAL) flag $(D_INLINECODE GL_BLEND) flag Enable bits for the user-definable clipping planes $(D_INLINECODE GL_COLOR_MATERIAL) $(D_INLINECODE GL_CULL_FACE) flag $(D_INLINECODE GL_DEPTH_TEST) flag $(D_INLINECODE GL_DITHER) flag $(D_INLINECODE GL_FOG) flag $(D_INLINECODE GL_LIGHT) where $(D_INLINECODE 0) &lt;&#61; &lt; $(D_INLINECODE GL_MAX_LIGHTS) $(D_INLINECODE GL_LIGHTING) flag $(D_INLINECODE GL_LINE_SMOOTH) flag $(D_INLINECODE GL_LINE_STIPPLE) flag $(D_INLINECODE GL_COLOR_LOGIC_OP) flag $(D_INLINECODE GL_INDEX_LOGIC_OP) flag $(D_INLINECODE GL_MAP1_) where is a map type $(D_INLINECODE GL_MAP2_) where is a map type $(D_INLINECODE GL_MULTISAMPLE) flag $(D_INLINECODE GL_NORMALIZE) flag $(D_INLINECODE GL_POINT_SMOOTH) flag $(D_INLINECODE GL_POLYGON_OFFSET_LINE) flag $(D_INLINECODE GL_POLYGON_OFFSET_FILL) flag $(D_INLINECODE GL_POLYGON_OFFSET_POINT) flag $(D_INLINECODE GL_POLYGON_SMOOTH) flag $(D_INLINECODE GL_POLYGON_STIPPLE) flag $(D_INLINECODE GL_SAMPLE_ALPHA_TO_COVERAGE) flag $(D_INLINECODE GL_SAMPLE_ALPHA_TO_ONE) flag $(D_INLINECODE GL_SAMPLE_COVERAGE) flag $(D_INLINECODE GL_SCISSOR_TEST) flag $(D_INLINECODE GL_STENCIL_TEST) flag $(D_INLINECODE GL_TEXTURE_1D) flag $(D_INLINECODE GL_TEXTURE_2D) flag $(D_INLINECODE GL_TEXTURE_3D) flag Flags $(D_INLINECODE GL_TEXTURE_GEN_) where is S, T, R, or Q $(D_INLINECODE GL_EVAL_BIT) $(D_INLINECODE GL_MAP1_) enable bits, where is a map type $(D_INLINECODE GL_MAP2_) enable bits, where is a map type 1D grid endpoints and divisions 2D grid endpoints and divisions $(D_INLINECODE GL_AUTO_NORMAL) enable bit $(D_INLINECODE GL_FOG_BIT) $(D_INLINECODE GL_FOG) enable bit Fog color Fog density Linear fog start Linear fog end Fog index $(D_INLINECODE GL_FOG_MODE) value $(D_INLINECODE GL_HINT_BIT) $(D_INLINECODE GL_PERSPECTIVE_CORRECTION_HINT) setting $(D_INLINECODE GL_POINT_SMOOTH_HINT) setting $(D_INLINECODE GL_LINE_SMOOTH_HINT) setting $(D_INLINECODE GL_POLYGON_SMOOTH_HINT) setting $(D_INLINECODE GL_FOG_HINT) setting $(D_INLINECODE GL_GENERATE_MIPMAP_HINT) setting $(D_INLINECODE GL_TEXTURE_COMPRESSION_HINT) setting $(D_INLINECODE GL_LIGHTING_BIT) $(D_INLINECODE GL_COLOR_MATERIAL) enable bit $(D_INLINECODE GL_COLOR_MATERIAL_FACE) value Color material parameters that are tracking the current color Ambient scene color $(D_INLINECODE GL_LIGHT_MODEL_LOCAL_VIEWER) value $(D_INLINECODE GL_LIGHT_MODEL_TWO_SIDE) setting $(D_INLINECODE GL_LIGHTING) enable bit Enable bit for each light Ambient, diffuse, and specular intensity for each light Direction, position, exponent, and cutoff angle for each light Constant, linear, and quadratic attenuation factors for each light Ambient, diffuse, specular, and emissive color for each material Ambient, diffuse, and specular color indices for each material Specular exponent for each material $(D_INLINECODE GL_SHADE_MODEL) setting $(D_INLINECODE GL_LINE_BIT) $(D_INLINECODE GL_LINE_SMOOTH) flag $(D_INLINECODE GL_LINE_STIPPLE) enable bit Line stipple pattern and repeat counter Line width $(D_INLINECODE GL_LIST_BIT) $(D_INLINECODE GL_LIST_BASE) setting $(D_INLINECODE GL_MULTISAMPLE_BIT) $(D_INLINECODE GL_MULTISAMPLE) flag $(D_INLINECODE GL_SAMPLE_ALPHA_TO_COVERAGE) flag $(D_INLINECODE GL_SAMPLE_ALPHA_TO_ONE) flag $(D_INLINECODE GL_SAMPLE_COVERAGE) flag $(D_INLINECODE GL_SAMPLE_COVERAGE_VALUE) value $(D_INLINECODE GL_SAMPLE_COVERAGE_INVERT) value $(D_INLINECODE GL_PIXEL_MODE_BIT) $(D_INLINECODE GL_RED_BIAS) and $(D_INLINECODE GL_RED_SCALE) settings $(D_INLINECODE GL_GREEN_BIAS) and $(D_INLINECODE GL_GREEN_SCALE) values $(D_INLINECODE GL_BLUE_BIAS) and $(D_INLINECODE GL_BLUE_SCALE) $(D_INLINECODE GL_ALPHA_BIAS) and $(D_INLINECODE GL_ALPHA_SCALE) $(D_INLINECODE GL_DEPTH_BIAS) and $(D_INLINECODE GL_DEPTH_SCALE) $(D_INLINECODE GL_INDEX_OFFSET) and $(D_INLINECODE GL_INDEX_SHIFT) values $(D_INLINECODE GL_MAP_COLOR) and $(D_INLINECODE GL_MAP_STENCIL) flags $(D_INLINECODE GL_ZOOM_X) and $(D_INLINECODE GL_ZOOM_Y) factors $(D_INLINECODE GL_READ_BUFFER) setting $(D_INLINECODE GL_POINT_BIT) $(D_INLINECODE GL_POINT_SMOOTH) flag Point size $(D_INLINECODE GL_POLYGON_BIT) $(D_INLINECODE GL_CULL_FACE) enable bit $(D_INLINECODE GL_CULL_FACE_MODE) value $(D_INLINECODE GL_FRONT_FACE) indicator $(D_INLINECODE GL_POLYGON_MODE) setting $(D_INLINECODE GL_POLYGON_SMOOTH) flag $(D_INLINECODE GL_POLYGON_STIPPLE) enable bit $(D_INLINECODE GL_POLYGON_OFFSET_FILL) flag $(D_INLINECODE GL_POLYGON_OFFSET_LINE) flag $(D_INLINECODE GL_POLYGON_OFFSET_POINT) flag $(D_INLINECODE GL_POLYGON_OFFSET_FACTOR) $(D_INLINECODE GL_POLYGON_OFFSET_UNITS) $(D_INLINECODE GL_POLYGON_STIPPLE_BIT) Polygon stipple image $(D_INLINECODE GL_SCISSOR_BIT) $(D_INLINECODE GL_SCISSOR_TEST) flag Scissor box $(D_INLINECODE GL_STENCIL_BUFFER_BIT) $(D_INLINECODE GL_STENCIL_TEST) enable bit Stencil function and reference value Stencil value mask Stencil fail, pass, and depth buffer pass actions Stencil buffer clear value Stencil buffer writemask $(D_INLINECODE GL_TEXTURE_BIT) Enable bits for the four texture coordinates Border color for each texture image Minification function for each texture image Magnification function for each texture image Texture coordinates and wrap mode for each texture image Color and mode for each texture environment Enable bits $(D_INLINECODE GL_TEXTURE_GEN_), is S, T, R, and Q $(D_INLINECODE GL_TEXTURE_GEN_MODE) setting for S, T, R, and Q $(D_INLINECODE glTexGen) plane equations for S, T, R, and Q Current texture bindings (for example, $(D_INLINECODE GL_TEXTURE_BINDING_2D) ) $(D_INLINECODE GL_TRANSFORM_BIT) Coefficients of the six clipping planes Enable bits for the user-definable clipping planes $(D_INLINECODE GL_MATRIX_MODE) value $(D_INLINECODE GL_NORMALIZE) flag $(D_INLINECODE GL_RESCALE_NORMAL) flag $(D_INLINECODE GL_VIEWPORT_BIT) Depth range (near and far) Viewport origin and extent $(D_INLINECODE glPopAttrib) restores the values of the state variables saved with the last $(D_INLINECODE glPushAttrib) command. Those not saved are left unchanged. It is an error to push attributes onto a full stack or to pop attributes off an empty stack. In either case, the error flag is set and no other change is made to GL state. Initially, the attribute stack is empty.
     + 
     + Not all values for GL state can be saved on the attribute stack. For example, render mode state, and select and feedback state cannot be saved. Client state must be saved with $(D_INLINECODE glPushClientAttrib). The depth of the attribute stack depends on the implementation, but it must be at least 16. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, pushing and popping texture state applies to all supported texture units.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGet), $(D_INLINECODE glGetClipPlane), $(D_INLINECODE glGetError), $(D_INLINECODE glGetLight), $(D_INLINECODE glGetMap), $(D_INLINECODE glGetMaterial), $(D_INLINECODE glGetPixelMap), $(D_INLINECODE glGetPolygonStipple), $(D_INLINECODE glGetString), $(D_INLINECODE glGetTexEnv), $(D_INLINECODE glGetTexGen), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glPushClientAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPushAttrib(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPopAttrib() @system @nogc nothrow;

    /++
     + glTexCoordPointer: man2/glTexCoordPointer.xml
     + 
     + $(D_INLINECODE glTexCoordPointer) specifies the location and data format of an array of texture coordinates to use when rendering. $(D_INLINECODE size) specifies the number of coordinates per texture coordinate set, and must be 1, 2, 3, or 4. $(D_INLINECODE type) specifies the data type of each texture coordinate, and $(D_INLINECODE stride) specifies the byte stride from one texture coordinate set to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see $(D_INLINECODE glInterleavedArrays).) If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture coordinate array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as texture coordinate vertex array client-side state ( $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING) ). When a texture coordinate array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable a texture coordinate array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_TEXTURE_COORD_ARRAY). If enabled, the texture coordinate array is used when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glDrawRangeElements) is called.
     + 
     + $(D_INLINECODE glTexCoordPointer) is available only if the GL version is 1.1 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexCoordPointer) updates the texture coordinate array state of the active client texture unit, specified with $(D_INLINECODE glClientActiveTexture). Each texture coordinate array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glTexCoordPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glTexCoordPointer) is typically implemented on the client side. Texture coordinate array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + glPolygonOffset: man2/glPolygonOffset.xml
     + 
     + When $(D_INLINECODE GL_POLYGON_OFFSET_FILL), $(D_INLINECODE GL_POLYGON_OFFSET_LINE), or $(D_INLINECODE GL_POLYGON_OFFSET_POINT) is enabled, each fragment's value will be offset after it is interpolated from the values of the appropriate vertices. The value of the offset is factor &times; DZ + r &times; units, where DZ is a measurement of the change in depth relative to the screen area of the polygon, and r is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added before the depth test is performed and before the value is written into the depth buffer. $(D_INLINECODE glPolygonOffset) is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges.
     + 
     + $(D_INLINECODE glPolygonOffset) is available only if the GL version is 1.1 or greater. $(D_INLINECODE glPolygonOffset) has no effect on depth coordinates placed in the feedback buffer. $(D_INLINECODE glPolygonOffset) has no effect on selection.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glGet), $(D_INLINECODE glIsEnabled)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glPolygonOffset(GLfloat factor, GLfloat units) @system @nogc nothrow;

    /++
     + gluBeginCurve: man2/gluBeginCurve.xml
     + 
     + Use $(D_INLINECODE gluBeginCurve) to mark the beginning of a NURBS curve definition. After calling $(D_INLINECODE gluBeginCurve), make one or more calls to $(D_INLINECODE gluNurbsCurve) to define the attributes of the curve. Exactly one of the calls to $(D_INLINECODE gluNurbsCurve) must have a curve type of $(D_INLINECODE GLU_MAP1_VERTEX_3) or $(D_INLINECODE GLU_MAP1_VERTEX_4). To mark the end of the NURBS curve definition, call $(D_INLINECODE gluEndCurve). GL evaluators are used to render the NURBS curve as a series of line segments. Evaluator state is preserved during rendering with $(D_INLINECODE glPushAttrib) ( $(D_INLINECODE GLU_EVAL_BIT) ) and $(D_INLINECODE glPopAttrib) (). See the $(D_INLINECODE glPushAttrib) reference page for details on exactly what state these calls preserve.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginSurface), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCurve), $(D_INLINECODE glPopAttrib), $(D_INLINECODE glPushAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluBeginCurve(GLUnurbs* nurb) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluEndCurve(GLUnurbs* nurb) @system @nogc nothrow;

    /++
     + glLight: man2/glLight.xml
     + 
     + $(D_INLINECODE glLight) sets the values of individual light source parameters. $(D_INLINECODE light) names the light and is a symbolic name of the form $(D_INLINECODE GL_LIGHT) i, where i ranges from 0 to the value of $(D_INLINECODE GL_MAX_LIGHTS) - 1. $(D_INLINECODE pname) specifies one of ten light source parameters, again by symbolic name. $(D_INLINECODE params) is either a single value or a pointer to an array that contains the new values. To enable and disable lighting calculation, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_LIGHTING). Lighting is initially disabled. When it is enabled, light sources that are enabled contribute to the lighting calculation. Light source i is enabled and disabled using $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_LIGHT) i. The ten light parameters are as follows:
     + 
     + It is always the case that $(D_INLINECODE GL_LIGHT) i = $(D_INLINECODE GL_LIGHT0) + i.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMaterial), $(D_INLINECODE glLightModel), $(D_INLINECODE glMaterial)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightf(GLenum light, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLighti(GLenum light, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightfv(GLenum light, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightiv(GLenum light, GLenum pname, const GLint* params) @system @nogc nothrow;

    /++
     + glReadPixels: man2/glReadPixels.xml
     + 
     + $(D_INLINECODE glReadPixels) returns pixel data from the frame buffer, starting with the pixel whose lower left corner is at location ( $(D_INLINECODE x), $(D_INLINECODE y) ), into client memory starting at location $(D_INLINECODE data). Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with three commands: $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), and $(D_INLINECODE glPixelMap). This reference page describes the effects on $(D_INLINECODE glReadPixels) of most, but not all of the parameters specified by these three commands. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a block of pixels is requested, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store rather than a pointer to client memory. When the $(D_INLINECODE ARB_imaging) extension is supported, the pixel data may be processed by additional operations including color table lookup, color matrix transformations, convolutions, histograms, and minimum and maximum pixel value computations. $(D_INLINECODE glReadPixels) returns values from each pixel with lower left corner at x + i y + j for 0 &lt;= i &lt; width and 0 &lt;= j &lt; height. This pixel is said to be the i th pixel in the j th row. Pixels are returned in row order from the lowest to the highest row, left to right in each row. $(D_INLINECODE format) specifies the format for the returned pixel values; accepted values are: The shift, scale, bias, and lookup factors just described are all specified by $(D_INLINECODE glPixelTransfer). The lookup table contents themselves are specified by $(D_INLINECODE glPixelMap). Finally, the indices or components are converted to the proper format, as specified by $(D_INLINECODE type). If $(D_INLINECODE format) is $(D_INLINECODE GL_COLOR_INDEX) or $(D_INLINECODE GL_STENCIL_INDEX) and $(D_INLINECODE type) is not $(D_INLINECODE GL_FLOAT), each index is masked with the mask value given in the following table. If $(D_INLINECODE type) is $(D_INLINECODE GL_FLOAT), then each integer index is converted to single-precision floating-point format. If $(D_INLINECODE format) is $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), $(D_INLINECODE GL_BLUE), $(D_INLINECODE GL_ALPHA), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_LUMINANCE), or $(D_INLINECODE GL_LUMINANCE_ALPHA) and $(D_INLINECODE type) is not $(D_INLINECODE GL_FLOAT), each component is multiplied by the multiplier shown in the following table. If type is $(D_INLINECODE GL_FLOAT), then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by the GL). $(D_INLINECODE type) $(B Index Mask) $(B Component Conversion) $(D_INLINECODE GL_UNSIGNED_BYTE) 2 8 - 1 2 8 - 1 &it; c $(D_INLINECODE GL_BYTE) 2 7 - 1 2 8 - 1 &it; c - 1 2 $(D_INLINECODE GL_BITMAP) 1 1 $(D_INLINECODE GL_UNSIGNED_SHORT) 2 16 - 1 2 16 - 1 &it; c $(D_INLINECODE GL_SHORT) 2 15 - 1 2 16 - 1 &it; c - 1 2 $(D_INLINECODE GL_UNSIGNED_INT) 2 32 - 1 2 32 - 1 &it; c $(D_INLINECODE GL_INT) 2 31 - 1 2 32 - 1 &it; c - 1 2 $(D_INLINECODE GL_FLOAT) none c Return values are placed in memory as follows. If $(D_INLINECODE format) is $(D_INLINECODE GL_COLOR_INDEX), $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), $(D_INLINECODE GL_BLUE), $(D_INLINECODE GL_ALPHA), or $(D_INLINECODE GL_LUMINANCE), a single value is returned and the data for the i th pixel in the j th row is placed in location j &it; width + i. $(D_INLINECODE GL_RGB) and $(D_INLINECODE GL_BGR) return three values, $(D_INLINECODE GL_RGBA) and $(D_INLINECODE GL_BGRA) return four values, and $(D_INLINECODE GL_LUMINANCE_ALPHA) returns two values for each pixel, with all values corresponding to a single pixel occupying contiguous space in $(D_INLINECODE data). Storage parameters set by $(D_INLINECODE glPixelStore), such as $(D_INLINECODE GL_PACK_LSB_FIRST) and $(D_INLINECODE GL_PACK_SWAP_BYTES), affect the way that data is written into memory. See $(D_INLINECODE glPixelStore) for a description.
     + 
     + Values for pixels that lie outside the window connected to the current GL context are undefined. If an error is generated, no change is made to the contents of $(D_INLINECODE data).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glReadBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* data) @system @nogc nothrow;

    /++
     + glEdgeFlag: man2/glEdgeFlag.xml
     + 
     + Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) pair is marked as the start of either a boundary or nonboundary edge. If the current edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary edge. Otherwise, the vertex is marked as the start of a nonboundary edge. $(D_INLINECODE glEdgeFlag) sets the edge flag bit to $(D_INLINECODE GL_TRUE) if $(D_INLINECODE flag) is $(D_INLINECODE GL_TRUE) and to $(D_INLINECODE GL_FALSE) otherwise. The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of the value of the edge flag. Boundary and nonboundary edge flags on vertices are significant only if $(D_INLINECODE GL_POLYGON_MODE) is set to $(D_INLINECODE GL_POINT) or $(D_INLINECODE GL_LINE). See $(D_INLINECODE glPolygonMode).
     + 
     + The current edge flag can be updated at any time. In particular, $(D_INLINECODE glEdgeFlag) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glPolygonMode)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEdgeFlag(GLboolean flag) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEdgeFlagv(const GLboolean* flag) @system @nogc nothrow;

    /++
     + glClear: man2/glClear.xml
     + 
     + $(D_INLINECODE glClear) sets the bitplane area of the window to values previously selected by $(D_INLINECODE glClearColor), $(D_INLINECODE glClearIndex), $(D_INLINECODE glClearDepth), $(D_INLINECODE glClearStencil), and $(D_INLINECODE glClearAccum). Multiple color buffers can be cleared simultaneously by selecting more than one buffer at a time using $(D_INLINECODE glDrawBuffer). The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of $(D_INLINECODE glClear). The scissor box bounds the cleared region. Alpha function, blend function, logical operation, stenciling, texture mapping, and depth-buffering are ignored by $(D_INLINECODE glClear). $(D_INLINECODE glClear) takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared. The values are as follows: The value to which each buffer is cleared depends on the setting of the clear value for that buffer.
     + 
     + If a buffer is not present, then a $(D_INLINECODE glClear) directed at that buffer has no effect.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearAccum), $(D_INLINECODE glClearColor), $(D_INLINECODE glClearDepth), $(D_INLINECODE glClearIndex), $(D_INLINECODE glClearStencil), $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClear(GLbitfield mask) @system @nogc nothrow;

    /++
     + glBufferData: man2/glBufferData.xml
     + 
     + $(D_INLINECODE glBufferData) creates a new data store for the buffer object currently bound to $(D_INLINECODE target). Any pre-existing data store is deleted. The new data store is created with the specified $(D_INLINECODE size) in bytes and $(D_INLINECODE usage). If $(D_INLINECODE data) is not $(D_INLINECODE null
     + ), the data store is initialized with data from this pointer. In its initial state, the new data store is not mapped, it has a $(D_INLINECODE null
     + ) mapped pointer, and its mapped access is $(D_INLINECODE GL_READ_WRITE). $(D_INLINECODE usage) is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. $(D_INLINECODE usage) can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these: The nature of access may be one of these:
     + 
     + $(D_INLINECODE glBufferData) is available only if the GL version is 1.5 or greater. Targets $(D_INLINECODE GL_PIXEL_PACK_BUFFER) and $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) are available only if the GL version is 2.1 or greater. If $(D_INLINECODE data) is $(D_INLINECODE null
     + ), a data store of the specified size is still created, but its contents remain uninitialized and thus undefined. Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N bytes be a multiple of N.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage) @system @nogc nothrow;

    /++
     + glDeleteLists: man2/glDeleteLists.xml
     + 
     + $(D_INLINECODE glDeleteLists) causes a contiguous group of display lists to be deleted. $(D_INLINECODE list) is the name of the first display list to be deleted, and $(D_INLINECODE range) is the number of display lists to delete. All display lists d with list &lt;= d &lt;= list + range - 1 are deleted. All storage locations allocated to the specified display lists are freed, and the names are available for reuse at a later time. Names within the range that do not have an associated display list are ignored. If $(D_INLINECODE range) is 0, nothing happens.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glGenLists), $(D_INLINECODE glIsList), $(D_INLINECODE glNewList)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDeleteLists(GLuint list, GLsizei range) @system @nogc nothrow;

    /++
     + glVertexAttrib: man2/glVertexAttrib.xml
     + 
     + OpenGL defines a number of standard vertex attributes that applications can modify with standard API entry points (color, normal, texture coordinates, etc.). The $(D_INLINECODE glVertexAttrib) family of entry points allows an application to pass generic vertex attributes in numbered locations. Generic attributes are defined as four-component values that are organized into an array. The first entry of this array is numbered 0, and the size of the array is specified by the implementation-dependent constant $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS). Individual elements of this array can be modified with a $(D_INLINECODE glVertexAttrib) call that specifies the index of the element to be modified and a value for that element. These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified by $(D_INLINECODE index). A $(D_INLINECODE 1) in the name of the command indicates that only one value is passed, and it will be used to modify the first component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component will be set to 1. Similarly, a $(D_INLINECODE 2) in the name of the command indicates that values are provided for the first two components, the third component will be set to 0, and the fourth component will be set to 1. A $(D_INLINECODE 3) in the name of the command indicates that values are provided for the first three components and the fourth component will be set to 1, whereas a $(D_INLINECODE 4) in the name indicates that values are provided for all four components. The letters $(D_INLINECODE s), $(D_INLINECODE f), $(D_INLINECODE i), $(D_INLINECODE d), $(D_INLINECODE ub), $(D_INLINECODE us), and $(D_INLINECODE ui) indicate whether the arguments are of type short, float, int, double, unsigned byte, unsigned short, or unsigned int. When $(D_INLINECODE v) is appended to the name, the commands can take a pointer to an array of such values. The commands containing $(D_INLINECODE N) indicate that the arguments will be passed as fixed-point values that are scaled to a normalized range according to the component conversion rules defined by the OpenGL specification. Signed values are understood to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values in the range [0,1]. OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may be loaded using the $(D_INLINECODE glVertexAttrib) entry points. Matrices must be loaded into successive generic attribute slots in column major order, with one column of the matrix in each generic attribute slot. A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling $(D_INLINECODE glBindAttribLocation). This allows an application to use more descriptive variable names in a vertex shader. A subsequent change to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable in the vertex shader. The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different program object is used. An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable. These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing, the vertex shader will repeatedly use the current value for the generic vertex attribute. The generic vertex attribute with index 0 is the same as the vertex position attribute previously defined by OpenGL. A $(D_INLINECODE glVertex2), $(D_INLINECODE glVertex3), or $(D_INLINECODE glVertex4) command is completely equivalent to the corresponding $(D_INLINECODE glVertexAttrib) command with an index argument of 0. A vertex shader can access generic vertex attribute 0 by using the built-in attribute variable $(D_INLINECODE gl_Vertex). There are no current values for generic vertex attribute 0. This is the only generic vertex attribute with this property; calls to set other standard vertex attributes can be freely mixed with calls to set any of the other generic vertex attributes.
     + 
     + $(D_INLINECODE glVertexAttrib) is available only if the GL version is 2.0 or greater. Generic vertex attributes can be updated at any time. In particular, $(D_INLINECODE glVertexAttrib) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd). It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location. OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing. There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes with standard attributes.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glVertex), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1f(GLuint index, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1s(GLuint index, GLshort v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1d(GLuint index, GLdouble v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1fv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib1dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2fv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib2dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3fv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib3dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4fv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4bv(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4ubv(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4usv(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nbv(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nsv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Niv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nubv(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nusv(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttrib4Nuiv(GLuint index, const GLuint* v) @system @nogc nothrow;

    /++
     + glColorPointer: man2/glColorPointer.xml
     + 
     + $(D_INLINECODE glColorPointer) specifies the location and data format of an array of color components to use when rendering. $(D_INLINECODE size) specifies the number of components per color, and must be 3 or 4. $(D_INLINECODE type) specifies the data type of each color component, and $(D_INLINECODE stride) specifies the byte stride from one color to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see $(D_INLINECODE glInterleavedArrays).) If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a color array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as color vertex array client-side state ( $(D_INLINECODE GL_COLOR_ARRAY_BUFFER_BINDING) ). When a color array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the color array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_COLOR_ARRAY). If enabled, the color array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glColorPointer) is available only if the GL version is 1.1 or greater. The color array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glColorPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glColorPointer) is typically implemented on the client side. Color array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColor), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + gluLookAt: man2/gluLookAt.xml
     + 
     + $(D_INLINECODE gluLookAt) creates a viewing matrix derived from an eye point, a reference point indicating the center of the scene, and an vector. The matrix maps the reference point to the negative axis and the eye point to the origin. When a typical projection matrix is used, the center of the scene therefore maps to the center of the viewport. Similarly, the direction described by the vector projected onto the viewing plane is mapped to the positive axis so that it points upward in the viewport. The vector must not be parallel to the line of sight from the eye point to the reference point. Let F = centerX - eyeX centerY - eyeY centerZ - eyeZ Let be the vector upX upY upZ. Then normalize as follows: f = F F UP &Prime; = UP UP Finally, let s = f &times; UP &Prime;, and u = s s &times; f. M is then constructed as follows: M = s &af; 0 s &af; 1 s &af; 2 0 u &af; 0 u &af; 1 u &af; 2 0 - f &af; 0 - f &af; 1 - f &af; 2 0 0 0 0 1 and $(D_INLINECODE gluLookAt) is equivalent to
     + 
     + ---
     + glMultMatrixf(M);
     + glTranslated(-eyex, -eyey, -eyez);
     +         
     + ---
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluPerspective), $(D_INLINECODE glFrustum)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ) @system @nogc nothrow;

    /++
     + glDeleteTextures: man2/glDeleteTextures.xml
     + 
     + $(D_INLINECODE glDeleteTextures) deletes $(D_INLINECODE n) textures named by the elements of the array $(D_INLINECODE textures). After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by $(D_INLINECODE glGenTextures) ). If a texture that is currently bound is deleted, the binding reverts to 0 (the default texture). $(D_INLINECODE glDeleteTextures) silently ignores 0's and names that do not correspond to existing textures.
     + 
     + $(D_INLINECODE glDeleteTextures) is available only if the GL version is 1.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAreTexturesResident), $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glPrioritizeTextures), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glDeleteTextures(GLsizei n, const GLuint* textures) @system @nogc nothrow;

    /++
     + glMap2: man2/glMap2.xml
     + 
     + Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further stages of GL processing just as if they had been presented using $(D_INLINECODE glVertex), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), and $(D_INLINECODE glColor) commands, except that the generated values do not update the current normal, texture coordinates, or color. All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators. These include almost all surfaces used in computer graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on. Evaluators define surfaces based on bivariate Bernstein polynomials. Define p &af; u &Hat; v &Hat; as p &af; u &Hat; v &Hat; = &Sigma; i = 0 n &Sigma; j = 0 m B i n &af; u &Hat; &it; B j m &af; v &Hat; &it; R ij where R ij is a control point, B i n &af; u &Hat; is the i th Bernstein polynomial of degree n ( $(D_INLINECODE uorder) = n + 1 ) B i n &af; u &Hat; = n i &it; u &Hat; i &it; 1 - u &Hat; n - i and B j m &af; v &Hat; is the j th Bernstein polynomial of degree m ( $(D_INLINECODE vorder) = m + 1 ) B j m &af; v &Hat; = m j &it; v &Hat; j &it; 1 - v &Hat; m - j Recall that 0 0 == 1 and n 0 == 1 $(D_INLINECODE glMap2) is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with the map name, one of the nine predefined values for $(D_INLINECODE target), described below. When $(D_INLINECODE glEvalCoord2) presents values u and v, the bivariate Bernstein polynomials are evaluated using u &Hat; and v &Hat;, where u &Hat; = u - u1 u2 - u1 v &Hat; = v - v1 v2 - v1 $(D_INLINECODE target) is a symbolic constant that indicates what kind of control points are provided in $(D_INLINECODE points), and what output is generated when the map is evaluated. It can assume one of nine predefined values: $(D_INLINECODE ustride), $(D_INLINECODE uorder), $(D_INLINECODE vstride), $(D_INLINECODE vorder), and $(D_INLINECODE points) define the array addressing for accessing the control points. $(D_INLINECODE points) is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. There are uorder &times; vorder control points in the array. $(D_INLINECODE ustride) specifies how many float or double locations are skipped to advance the internal memory pointer from control point R i &it; j to control point R i + 1 &it; j. $(D_INLINECODE vstride) specifies how many float or double locations are skipped to advance the internal memory pointer from control point R i &it; j to control point R i &af; j + 1.
     + 
     + As is the case with all GL commands that accept pointers to data, it is as if the contents of $(D_INLINECODE points) were copied by $(D_INLINECODE glMap2) before $(D_INLINECODE glMap2) returns. Changes to the contents of $(D_INLINECODE points) have no effect after $(D_INLINECODE glMap2) is called. Initially, $(D_INLINECODE GL_AUTO_NORMAL) is enabled. If $(D_INLINECODE GL_AUTO_NORMAL) is enabled, normal vectors are generated when either $(D_INLINECODE GL_MAP2_VERTEX_3) or $(D_INLINECODE GL_MAP2_VERTEX_4) is used to generate vertices.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glEnable), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glMap1), $(D_INLINECODE glMapGrid), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points) @system @nogc nothrow;

    /++
     + glMinmax: man2/glMinmax.xml
     + 
     + When $(D_INLINECODE GL_MINMAX) is enabled, the RGBA components of incoming pixels are compared to the minimum and maximum values for each component, which are stored in the two-element minmax table. (The first element stores the minima, and the second element stores the maxima.) If a pixel component is greater than the corresponding component in the maximum element, then the maximum element is updated with the pixel component value. If a pixel component is less than the corresponding component in the minimum element, then the minimum element is updated with the pixel component value. (In both cases, if the internal format of the minmax table includes luminance, then the R color component of incoming pixels is used for comparison.) The contents of the minmax table may be retrieved at a later time by calling $(D_INLINECODE glGetMinmax). The minmax operation is enabled or disabled by calling $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable), respectively, with an argument of $(D_INLINECODE GL_MINMAX). $(D_INLINECODE glMinmax) redefines the current minmax table to have entries of the format specified by $(D_INLINECODE internalformat). The maximum element is initialized with the smallest possible component values, and the minimum element is initialized with the largest possible component values. The values in the previous minmax table, if any, are lost. If $(D_INLINECODE sink) is $(D_INLINECODE GL_TRUE), then pixels are discarded after minmax; no further processing of the pixels takes place, and no drawing, texture loading, or pixel readback will result.
     + 
     + $(D_INLINECODE glMinmax) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetMinmax), $(D_INLINECODE glResetMinmax)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glMinmax(GLenum target, GLenum internalformat, GLboolean sink) @system @nogc nothrow;

    /++
     + gluPerspective: man2/gluPerspective.xml
     + 
     + $(D_INLINECODE gluPerspective) specifies a viewing frustum into the world coordinate system. In general, the aspect ratio in $(D_INLINECODE gluPerspective) should match the aspect ratio of the associated viewport. For example, aspect = 2.0 means the viewer's angle of view is twice as wide in as it is in. If the viewport is twice as wide as it is tall, it displays the image without distortion. The matrix generated by $(D_INLINECODE gluPerspective) is multipled by the current matrix, just as if $(D_INLINECODE glMultMatrix) were called with the generated matrix. To load the perspective matrix onto the current matrix stack instead, precede the call to $(D_INLINECODE gluPerspective) with a call to $(D_INLINECODE glLoadIdentity). Given defined as follows: f = cotangent &af; fovy 2 The generated matrix is f aspect 0 0 0 0 f 0 0 0 0 zFar + zNear zNear - zFar 2 &times; zFar &times; zNear zNear - zFar 0 0 -1 0
     + 
     + Depth buffer precision is affected by the values specified for $(D_INLINECODE zNear) and $(D_INLINECODE zFar). The greater the ratio of $(D_INLINECODE zFar) to $(D_INLINECODE zNear) is, the less effective the depth buffer will be at distinguishing between surfaces that are near each other. If r = zFar zNear roughly log 2 &af; r bits of depth buffer precision are lost. Because r approaches infinity as $(D_INLINECODE zNear) approaches 0, $(D_INLINECODE zNear) must never be set to 0.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluOrtho2D), $(D_INLINECODE glFrustum), $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glMultMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;

    /++
     + glAreTexturesResident: man2/glAreTexturesResident.xml
     + 
     + GL establishes a ``working set'' of textures that are resident in texture memory. These textures can be bound to a texture target much more efficiently than textures that are not resident. $(D_INLINECODE glAreTexturesResident) queries the texture residence status of the $(D_INLINECODE n) textures named by the elements of $(D_INLINECODE textures). If all the named textures are resident, $(D_INLINECODE glAreTexturesResident) returns $(D_INLINECODE GL_TRUE), and the contents of $(D_INLINECODE residences) are undisturbed. If not all the named textures are resident, $(D_INLINECODE glAreTexturesResident) returns $(D_INLINECODE GL_FALSE), and detailed status is returned in the $(D_INLINECODE n) elements of $(D_INLINECODE residences). If an element of $(D_INLINECODE residences) is $(D_INLINECODE GL_TRUE), then the texture named by the corresponding element of $(D_INLINECODE textures) is resident. The residence status of a single bound texture may also be queried by calling $(D_INLINECODE glGetTexParameter) with the argument set to the target to which the texture is bound, and the argument set to $(D_INLINECODE GL_TEXTURE_RESIDENT). This is the only way that the residence status of a default texture can be queried.
     + 
     + $(D_INLINECODE glAreTexturesResident) is available only if the GL version is 1.1 or greater. $(D_INLINECODE glAreTexturesResident) returns the residency status of the textures at the time of invocation. It does not guarantee that the textures will remain resident at any other time. If textures reside in virtual memory (there is no texture memory), they are considered always resident. Some implementations may not load a texture until the first use of that texture.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glPrioritizeTextures), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    GLboolean glAreTexturesResident(GLsizei n, const GLuint* textures, GLboolean* residences) @system @nogc nothrow;

    /++
     + glCopyTexImage1D: man2/glCopyTexImage1D.xml
     + 
     + $(D_INLINECODE glCopyTexImage1D) defines a one-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER). The screen-aligned pixel row with left corner at x y and with a length of width + 2 &af; border defines the texture array at the mipmap level specified by $(D_INLINECODE level). $(D_INLINECODE internalformat) specifies the internal format of the texture array. The pixels in the row are processed exactly as if $(D_INLINECODE glCopyPixels) had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. Pixel ordering is such that lower x screen coordinates correspond to lower texture coordinates. If any of the pixels within the specified row of the current $(D_INLINECODE GL_READ_BUFFER) are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined. $(D_INLINECODE glCopyTexImage1D) defines a one-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER). When $(D_INLINECODE internalformat) is one of the sRGB  types, the GL does not automatically convert the source pixels to the sRGB color space.  In this case, the $(D_INLINECODE glPixelMap) function can be used to accomplish the conversion.
     + 
     + $(D_INLINECODE glCopyTexImage1D) is available only if the GL version is 1.1 or greater. Texturing has no effect in color index mode. 1, 2, 3, and 4 are not accepted values for $(D_INLINECODE internalformat). An image with 0 width indicates a null texture.
     +  When the $(D_INLINECODE ARB_imaging) extension is supported, the RGBA components copied from the framebuffer may be processed by the imaging pipeline.  See $(D_INLINECODE glTexImage1D) for specific details. $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_COMPONENT16), $(D_INLINECODE GL_DEPTH_COMPONENT24), and $(D_INLINECODE GL_DEPTH_COMPONENT32) are available only if the GL version is 1.4 or greater. Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the $(D_INLINECODE GL_ARB_texture_non_power_of_two) extension. The $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_SLUMINANCE), $(D_INLINECODE GL_SLUMINANCE8), $(D_INLINECODE GL_SLUMINANCE_ALPHA), and $(D_INLINECODE GL_SLUMINANCE8_ALPHA8) internal formats are only available if the GL version is 2.1 or greater.  See $(D_INLINECODE glTexImage1D) for specific details about sRGB conversion.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;

    /++
     + glGetActiveUniform: man2/glGetActiveUniform.xml
     + 
     + $(D_INLINECODE glGetActiveUniform) returns information about an active uniform variable in the program object specified by $(D_INLINECODE program). The number of active uniform variables can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_UNIFORMS). A value of 0 for $(D_INLINECODE index) selects the first active uniform variable. Permissible values for $(D_INLINECODE index) range from 0 to the number of active uniform variables minus 1. Shaders may use either built-in uniform variables, user-defined uniform variables, or both. Built-in uniform variables have a prefix of &quot;gl_&quot; and reference existing OpenGL state or values derived from such state (e.g., $(D_INLINECODE gl_Fog), $(D_INLINECODE gl_ModelViewMatrix), etc., see the OpenGL Shading Language specification for a complete list.) User-defined uniform variables have arbitrary names and obtain their values from the application through calls to $(D_INLINECODE glUniform). A uniform variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, $(D_INLINECODE program) should have previously been the target of a call to $(D_INLINECODE glLinkProgram), but it is not necessary for it to have been linked successfully. The size of the character buffer required to store the longest uniform variable name in $(D_INLINECODE program) can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_UNIFORM_MAX_LENGTH). This value should be used to allocate a buffer of sufficient size to store the returned uniform variable name. The size of this character buffer is passed in $(D_INLINECODE bufSize), and a pointer to this character buffer is passed in $(D_INLINECODE name.) $(D_INLINECODE glGetActiveUniform) returns the name of the uniform variable indicated by $(D_INLINECODE index), storing it in the character buffer specified by $(D_INLINECODE name). The string returned will be null terminated. The actual number of characters written into this buffer is returned in $(D_INLINECODE length), and this count does not include the null termination character. If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The $(D_INLINECODE type) argument will return a pointer to the uniform variable's data type. The symbolic constants $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_FLOAT_VEC2), $(D_INLINECODE GL_FLOAT_VEC3), $(D_INLINECODE GL_FLOAT_VEC4), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_INT_VEC2), $(D_INLINECODE GL_INT_VEC3), $(D_INLINECODE GL_INT_VEC4), $(D_INLINECODE GL_BOOL), $(D_INLINECODE GL_BOOL_VEC2), $(D_INLINECODE GL_BOOL_VEC3), $(D_INLINECODE GL_BOOL_VEC4), $(D_INLINECODE GL_FLOAT_MAT2), $(D_INLINECODE GL_FLOAT_MAT3), $(D_INLINECODE GL_FLOAT_MAT4), $(D_INLINECODE GL_FLOAT_MAT2x3), $(D_INLINECODE GL_FLOAT_MAT2x4), $(D_INLINECODE GL_FLOAT_MAT3x2), $(D_INLINECODE GL_FLOAT_MAT3x4), $(D_INLINECODE GL_FLOAT_MAT4x2), $(D_INLINECODE GL_FLOAT_MAT4x3), $(D_INLINECODE GL_SAMPLER_1D), $(D_INLINECODE GL_SAMPLER_2D), $(D_INLINECODE GL_SAMPLER_3D), $(D_INLINECODE GL_SAMPLER_CUBE), $(D_INLINECODE GL_SAMPLER_1D_SHADOW), or $(D_INLINECODE GL_SAMPLER_2D_SHADOW) may be returned. If one or more elements of an array are active, the name of the array is returned in $(D_INLINECODE name), the type is returned in $(D_INLINECODE type), and the $(D_INLINECODE size) parameter returns the highest array element index used, plus one, as determined by the compiler and/or linker. Only one active uniform variable will be reported for a uniform array. Uniform variables that are declared as structures or arrays of structures will not be returned directly by this function. Instead, each of these uniform variables will be reduced to its fundamental components containing the &quot;.&quot; and &quot;[]&quot; operators such that each of the names is valid as an argument to $(D_INLINECODE glGetUniformLocation). Each of these reduced uniform variables is counted as one active uniform variable and is assigned an index. A valid name cannot be a structure, an array of structures, or a subcomponent of a vector or matrix. The size of the uniform variable will be returned in $(D_INLINECODE size). Uniform variables other than arrays will have a size of 1. Structures and arrays of structures will be reduced as described earlier, such that each of the names returned will be a data type in the earlier list. If this reduction results in an array, the size returned will be as described for uniform arrays; otherwise, the size returned will be 1. The list of active uniform variables may include both built-in uniform variables (which begin with the prefix &quot;gl_&quot;) as well as user-defined uniform variable names. This function will return as much information as it can about the specified active uniform variable. If no information is available, $(D_INLINECODE length) will be 0, and $(D_INLINECODE name) will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values $(D_INLINECODE length), $(D_INLINECODE size), $(D_INLINECODE type), and $(D_INLINECODE name) will be unmodified.
     + 
     + $(D_INLINECODE glGetActiveUniform) is available only if the GL version is 2.0 or greater. $(D_INLINECODE GL_FLOAT_MAT2x3), $(D_INLINECODE GL_FLOAT_MAT2x4), $(D_INLINECODE GL_FLOAT_MAT3x2), $(D_INLINECODE GL_FLOAT_MAT3x4), $(D_INLINECODE GL_FLOAT_MAT4x2), and $(D_INLINECODE GL_FLOAT_MAT4x3) will only be returned as a $(D_INLINECODE type) if the GL version is 2.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetUniform), $(D_INLINECODE glGetUniformLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) @system @nogc nothrow;

    /++
     + glUniform: man2/glUniform.xml
     + 
     + $(D_INLINECODE glUniform) modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by $(D_INLINECODE location), which should be a value returned by $(D_INLINECODE glGetUniformLocation). $(D_INLINECODE glUniform) operates on the program object that was made part of current state by calling $(D_INLINECODE glUseProgram). The commands $(D_INLINECODE glUniform{1|2|3|4}{f|i}) are used to change the value of the uniform variable specified by $(D_INLINECODE location) using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for float, int, bool; $(D_INLINECODE 2) for vec2, ivec2, bvec2, etc.). The suffix $(D_INLINECODE f) indicates that floating-point values are being passed; the suffix $(D_INLINECODE i) indicates that integer values are being passed, and this type should also match the data type of the specified uniform variable. The $(D_INLINECODE i) variants of this function should be used to provide values for uniform variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The $(D_INLINECODE f) variants should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the $(D_INLINECODE i) or the $(D_INLINECODE f) variants may be used to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise. All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to $(D_INLINECODE glUniform) until the next successful link operation occurs on the program object, when they are once again initialized to 0. The commands $(D_INLINECODE glUniform{1|2|3|4}{f|i}v) can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading elements starting at an arbitrary position in a uniform variable array, elements + - 1 in the array will be replaced with the new values. If $(D_INLINECODE m) + $(D_INLINECODE n) - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in $(D_INLINECODE value), and it should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for float, int, bool; $(D_INLINECODE 2) for vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for $(D_INLINECODE glUniform{1|2|3|4}{f|i}). For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., $(D_INLINECODE glUniform3f) or $(D_INLINECODE glUniform3fv) can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by $(D_INLINECODE count) The commands $(D_INLINECODE glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv) are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number $(D_INLINECODE 2) indicates a 2 &#215; 2 matrix (i.e., 4 values), the number $(D_INLINECODE 3) indicates a 3 &#215; 3 matrix (i.e., 9 values), and the number $(D_INLINECODE 4) indicates a 4 &#215; 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows.  For example, $(D_INLINECODE 2x4) indicates a 2 &#215; 4 matrix with 2 columns and 4 rows (i.e., 8 values). If $(D_INLINECODE transpose) is $(D_INLINECODE GL_FALSE), each matrix is assumed to be supplied in column major order. If $(D_INLINECODE transpose) is $(D_INLINECODE GL_TRUE), each matrix is assumed to be supplied in row major order. The $(D_INLINECODE count) argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.
     + 
     + $(D_INLINECODE glUniform) is available only if the GL version is 2.0 or greater. $(D_INLINECODE glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv) is available only if the GL version is 2.1 or greater. $(D_INLINECODE glUniform1i) and $(D_INLINECODE glUniform1iv) are the only two functions that may be used to load uniform variables defined as sampler types. Loading samplers with any other function will result in a $(D_INLINECODE GL_INVALID_OPERATION) error. If $(D_INLINECODE count) is greater than 1 and the indicated uniform variable is not an array, a $(D_INLINECODE GL_INVALID_OPERATION) error is generated and the specified uniform variable will remain unchanged. Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match the type and size specified in the name of the command used to load its value, a $(D_INLINECODE GL_INVALID_OPERATION) error will be generated and the specified uniform variable will remain unchanged. If $(D_INLINECODE location) is a value other than -1 and it does not represent a valid uniform variable location in the current program object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object. If $(D_INLINECODE location) is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform1f(GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform2f(GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform1i(GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform2i(GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform1fv(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform2fv(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform3fv(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform4fv(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform1iv(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform2iv(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform3iv(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniform4iv(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;

    /++
     + glLoadTransposeMatrix: man2/glLoadTransposeMatrix.xml
     + 
     + $(D_INLINECODE glLoadTransposeMatrix) replaces the current matrix with the one whose elements are specified by $(D_INLINECODE m). The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix mode (see $(D_INLINECODE glMatrixMode) ). The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview matrix. If v = v &af; 0 v &af; 1 v &af; 2 v &af; 3 is the set of object coordinates of a vertex, and $(D_INLINECODE m) points to an array of 16 single- or double-precision floating-point values m = m &af; 0 m &af; 1... m &af; 15, then the modelview transformation M &af; v does the following: M &af; v = m &af; 0 m &af; 1 m &af; 2 m &af; 3 m &af; 4 m &af; 5 m &af; 6 m &af; 7 m &af; 8 m &af; 9 m &af; 10 m &af; 11 m &af; 12 m &af; 13 m &af; 14 m &af; 15 &times; v &af; 0 v &af; 1 v &af; 2 v &af; 3 Projection and texture transformations are similarly defined. Calling $(D_INLINECODE glLoadTransposeMatrix) with matrix M is identical in operation to $(D_INLINECODE glLoadMatrix) with M T, where T represents the transpose.
     + 
     + $(D_INLINECODE glLoadTransposeMatrix) is available only if the GL version is 1.3 or greater. While the elements of the matrix may be specified with single or double precision, the GL implementation may store or operate on these values in less than single precision.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glLoadTransposeMatrixd(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glLoadTransposeMatrixf(const GLfloat* m) @system @nogc nothrow;

    /++
     + gluScaleImage: man2/gluScaleImage.xml
     + 
     + $(D_INLINECODE gluScaleImage) scales a pixel image using the appropriate pixel store modes to unpack data from the source image and pack data into the destination image. When shrinking an image, $(D_INLINECODE gluScaleImage) uses a box filter to sample the source image and create pixels for the destination image.  When magnifying an image, the pixels from the source image are linearly interpolated to create the destination image. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). See the $(D_INLINECODE glReadPixels) reference page for a description of the acceptable values for the $(D_INLINECODE format), $(D_INLINECODE typeIn), and $(D_INLINECODE typeOut) parameters.
     + 
     + Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void* dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut) @system @nogc nothrow;

    /++
     + glCompressedTexImage1D: man2/glCompressedTexImage1D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.  To enable and disable one-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_1D). $(D_INLINECODE glCompressedTexImage1D) loads a previously defined, and retrieved, compressed one-dimensional texture image if $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D) (see $(D_INLINECODE glTexImage1D) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_1D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. $(D_INLINECODE internalformat) must be extension-specified compressed-texture format. When a texture is loaded with $(D_INLINECODE glTexImage1D) using a generic compressed  texture format (e.g., $(D_INLINECODE GL_COMPRESSED_RGB) ) the GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image using $(D_INLINECODE glCompressedTexImage1D), query the compressed texture image's size and format using $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glCompressedTexImage1D) is available only if the GL version is 1.3 or greater. Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the $(D_INLINECODE GL_ARB_texture_non_power_of_two) extension.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glColorTable), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;

    /++
     + glBlendFuncSeparate: man2/glBlendFuncSeparate.xml
     + 
     + In RGBA mode, pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_BLEND) to enable and disable blending. $(D_INLINECODE glBlendFuncSeparate) defines the operation of blending when it is enabled. $(D_INLINECODE srcRGB) specifies which method is used to scale the source RGB-color components. $(D_INLINECODE dstRGB) specifies which method is used to scale the destination RGB-color components. Likewise, $(D_INLINECODE srcAlpha) specifies which method is used to scale the source alpha color component, and $(D_INLINECODE dstAlpha) specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, source and destination color components are referred to as R s G s B s A s and R d G d B d A d. The color specified by $(D_INLINECODE glBlendColor) is referred to as R c G c B c A c. They are understood to have integer values between 0 and k R k G k B k A, where k c = 2 m c - 1 and m R m G m B m A is the number of red, green, blue, and alpha bitplanes. Source and destination scale factors are referred to as s R s G s B s A and d R d G d B d A. All scale factors have range 0 1. $(B Parameter) $(B RGB Factor) $(B Alpha Factor) $(D_INLINECODE GL_ZERO) 0 0 0 0 $(D_INLINECODE GL_ONE) 1 1 1 1 $(D_INLINECODE GL_SRC_COLOR) R s k R G s k G B s k B A s k A $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 1 1 1 - R s k R G s k G B s k B 1 - A s k A $(D_INLINECODE GL_DST_COLOR) R d k R G d k G B d k B A d k A $(D_INLINECODE GL_ONE_MINUS_DST_COLOR) 1 1 1 - R d k R G d k G B d k B 1 - A d k A $(D_INLINECODE GL_SRC_ALPHA) A s k A A s k A A s k A A s k A $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 1 1 - A s k A A s k A A s k A 1 - A s k A $(D_INLINECODE GL_DST_ALPHA) A d k A A d k A A d k A A d k A $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA) 1 1 1 - A d k A A d k A A d k A 1 - A d k A $(D_INLINECODE GL_CONSTANT_COLOR) R c G c B c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR) 1 1 1 - R c G c B c 1 - A c $(D_INLINECODE GL_CONSTANT_ALPHA) A c A c A c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA) 1 1 1 - A c A c A c 1 - A c $(D_INLINECODE GL_SRC_ALPHA_SATURATE) i i i 1 In the table, i = min &af; A s 1 - A d To determine the blended RGBA values of a pixel when drawing in RGBA mode, the system uses the following equations: R d = min &af; k R R s &it; s R + R d &it; d R G d = min &af; k G G s &it; s G + G d &it; d G B d = min &af; k B B s &it; s B + B d &it; d B A d = min &af; k A A s &it; s A + A d &it; d A Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values.  However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0.  For example, when $(D_INLINECODE srcRGB) is $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE dstRGB) is $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), and A s is equal to k A, the equations reduce to simple replacement: R d = R s G d = G s B d = B s A d = A s
     + 
     + $(D_INLINECODE glBlendFuncSeparate) is available only if the GL version is 1.4 or greater. Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency. When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See $(D_INLINECODE glDrawBuffer).) Blending affects only RGBA rendering. It is ignored by color index renderers. $(D_INLINECODE GL_CONSTANT_COLOR), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR), $(D_INLINECODE GL_CONSTANT_ALPHA), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA) are available only if the GL version is 1.4 or greater or if the $(D_INLINECODE ARB_imaging) is supported by your implementation. $(D_INLINECODE GL_SRC_COLOR) and $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) are valid only for $(D_INLINECODE srcRGB) if the GL version is 1.4 or greater. $(D_INLINECODE GL_DST_COLOR) and $(D_INLINECODE GL_ONE_MINUS_DST_COLOR) are valid only for $(D_INLINECODE dstRGB) if the GL version is 1.4 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glBlendEquation), $(D_INLINECODE glClear), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;

    /++
     + glGetBufferPointerv: man2/glGetBufferPointerv.xml
     + 
     + $(D_INLINECODE glGetBufferPointerv) returns pointer information. $(D_INLINECODE pname) is a symbolic constant indicating the pointer to be returned, which must be $(D_INLINECODE GL_BUFFER_MAP_POINTER), the pointer to which the buffer object's data store is mapped.  If the data store is not currently mapped, $(D_INLINECODE null
     + ) is returned. $(D_INLINECODE params) is a pointer to a location in which to place the returned pointer value.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE glGetBufferPointerv) is available only if the GL version is 1.5 or greater. Targets $(D_INLINECODE GL_PIXEL_PACK_BUFFER) and $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) are available only if the GL version is 2.1 or greater. The initial value for the pointer is $(D_INLINECODE null
     + ).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glMapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid** params) @system @nogc nothrow;

    /++
     + glPushMatrix: man2/glPushMatrix.xml
     + 
     + There is a stack of matrices for each of the matrix modes. In $(D_INLINECODE GL_MODELVIEW) mode, the stack depth is at least 32. In the other modes, $(D_INLINECODE GL_COLOR), $(D_INLINECODE GL_PROJECTION), and $(D_INLINECODE GL_TEXTURE), the depth is at least 2. The current matrix in any mode is the matrix on the top of the stack for that mode. $(D_INLINECODE glPushMatrix) pushes the current matrix stack down by one, duplicating the current matrix. That is, after a $(D_INLINECODE glPushMatrix) call, the matrix on top of the stack is identical to the one below it. $(D_INLINECODE glPopMatrix) pops the current matrix stack, replacing the current matrix with the one below it on the stack. Initially, each of the stacks contains one matrix, an identity matrix. It is an error to push a full matrix stack or to pop a matrix stack that contains only a single matrix. In either case, the error flag is set and no other change is made to GL state.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFrustum), $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glOrtho), $(D_INLINECODE glRotate), $(D_INLINECODE glScale), $(D_INLINECODE glTranslate), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPushMatrix() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPopMatrix() @system @nogc nothrow;

    /++
     + glConvolutionFilter2D: man2/glConvolutionFilter2D.xml
     + 
     + $(D_INLINECODE glConvolutionFilter2D) builds a two-dimensional convolution filter kernel from an array of pixels. The pixel array specified by $(D_INLINECODE width), $(D_INLINECODE height), $(D_INLINECODE format), $(D_INLINECODE type), and $(D_INLINECODE data) is extracted from memory and processed just as if $(D_INLINECODE glDrawPixels) were called, but processing stops after the final expansion to RGBA is completed. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a convolution filter is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The R, G, B, and A components of each pixel are next scaled by the four 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_CONVOLUTION_2D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. They form a two-dimensional filter kernel image indexed with coordinates and such that starts at zero and increases from left to right, and starts at zero and increases from bottom to top. Kernel location is derived from the th pixel, where is + * $(D_INLINECODE width). Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glConvolutionFilter2D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + gluUnProject4: man2/gluUnProject4.xml
     + 
     + $(D_INLINECODE gluUnProject4) maps the specified window coordinatesi: $(D_INLINECODE winX), $(D_INLINECODE winY), and $(D_INLINECODE winZ) and its clip w coordinate $(D_INLINECODE clipW) into object coordinates objX objY objZ objW using $(D_INLINECODE model), $(D_INLINECODE proj), and $(D_INLINECODE view). $(D_INLINECODE clipW) can be other than 1 as for vertices in $(D_INLINECODE glFeedbackBuffer) when data type $(D_INLINECODE GLU_4D_COLOR_TEXTURE) is returned. This also handles the case where the $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) planes are different from the default, 0 and 1, respectively. A return value of $(D_INLINECODE GLU_TRUE) indicates success; a return value of $(D_INLINECODE GLU_FALSE) indicates failure. To compute the coordinates objX objY objZ objW, $(D_INLINECODE gluUnProject4) multiplies the normalized device coordinates by the inverse of $(D_INLINECODE model) * $(D_INLINECODE proj) as follows: objX objY objZ objW = INV &af; P &it; M &it; 2 &af; winX - view &af; 0 view &af; 2 - 1 2 &af; winY - view &af; 1 view &af; 3 - 1 2 &af; winZ - nearVal farVal - nearVal - 1 clipW INV denotes matrix inversion. $(D_INLINECODE gluUnProject4) is equivalent to $(D_INLINECODE gluUnProject) when $(D_INLINECODE clipW) is 1, $(D_INLINECODE nearVal) is 0, and $(D_INLINECODE farVal) is 1.
     + 
     + $(D_INLINECODE gluUnProject4) is available only if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluProject), $(D_INLINECODE gluUnProject), $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble* model, const GLdouble* proj, const GLint* view, GLdouble nearVal, GLdouble farVal, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW) @system @nogc nothrow;

    /++
     + glLineStipple: man2/glLineStipple.xml
     + 
     + Line stippling masks out certain fragments produced by rasterization; those fragments will not be drawn. The masking is achieved by using three parameters: the 16-bit line stipple pattern $(D_INLINECODE pattern), the repeat count $(D_INLINECODE factor), and an integer stipple counter s. Counter s is reset to 0 whenever $(D_INLINECODE glBegin) is called and before each line segment of a $(D_INLINECODE glBegin) ( $(D_INLINECODE GL_LINES) )/ $(D_INLINECODE glEnd) sequence is generated. It is incremented after each fragment of a unit width aliased line segment is generated or after each i fragments of an i width line segment are generated. The i fragments associated with count s are masked out if $(D_INLINECODE pattern) bit s factor % 16 is 0, otherwise these fragments are sent to the frame buffer. Bit zero of $(D_INLINECODE pattern) is the least significant bit. Antialiased lines are treated as a sequence of 1 &times; width rectangles for purposes of stippling. Whether rectangle s is rasterized or not depends on the fragment rule described for aliased lines, counting rectangles rather than groups of fragments. To enable and disable line stippling, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_LINE_STIPPLE). When enabled, the line stipple pattern is applied as described above. When disabled, it is as if the pattern were all 1's. Initially, line stippling is disabled.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLineWidth), $(D_INLINECODE glPolygonStipple)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLineStipple(GLint factor, GLushort pattern) @system @nogc nothrow;

    /++
     + glResetMinmax: man2/glResetMinmax.xml
     + 
     + $(D_INLINECODE glResetMinmax) resets the elements of the current minmax table to their initial values: the ``maximum'' element receives the minimum possible component values, and the ``minimum'' element receives the maximum possible component values.
     + 
     + $(D_INLINECODE glResetMinmax) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMinmax)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glResetMinmax(GLenum target) @system @nogc nothrow;

    /++
     + glGetMaterial: man2/glGetMaterial.xml
     + 
     + $(D_INLINECODE glGetMaterial) returns in $(D_INLINECODE params) the value or values of parameter $(D_INLINECODE pname) of material $(D_INLINECODE face). Six parameters are defined:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMaterial)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMaterialfv(GLenum face, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMaterialiv(GLenum face, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glFeedbackBuffer: man2/glFeedbackBuffer.xml
     + 
     + The $(D_INLINECODE glFeedbackBuffer) function controls feedback. Feedback, like selection, is a GL mode. The mode is selected by calling $(D_INLINECODE glRenderMode) with $(D_INLINECODE GL_FEEDBACK). When the GL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application using the GL. $(D_INLINECODE glFeedbackBuffer) has three arguments: $(D_INLINECODE buffer) is a pointer to an array of floating-point values into which feedback information is placed. $(D_INLINECODE size) indicates the size of the array. $(D_INLINECODE type) is a symbolic constant describing the information that is fed back for each vertex. $(D_INLINECODE glFeedbackBuffer) must be issued before feedback mode is enabled (by calling $(D_INLINECODE glRenderMode) with argument $(D_INLINECODE GL_FEEDBACK) ). Setting $(D_INLINECODE GL_FEEDBACK) without establishing the feedback buffer, or calling $(D_INLINECODE glFeedbackBuffer) while the GL is in feedback mode, is an error. When $(D_INLINECODE glRenderMode) is called while in feedback mode, it returns the number of entries placed in the feedback array and resets the feedback array pointer to the base of the feedback buffer. The returned value never exceeds $(D_INLINECODE size). If the feedback data required more room than was available in $(D_INLINECODE buffer), $(D_INLINECODE glRenderMode) returns a negative value. To take the GL out of feedback mode, call $(D_INLINECODE glRenderMode) with a parameter value other than $(D_INLINECODE GL_FEEDBACK). While in feedback mode, each primitive, bitmap, or pixel rectangle that would be rasterized generates a block of values that are copied into the feedback array. If doing so would cause the number of entries to exceed the maximum, the block is partially written so as to fill the array (if there is any room left at all), and an overflow flag is set. Each block begins with a code indicating the primitive type, followed by values that describe the primitive's vertices and associated data. Entries are also written for bitmaps and pixel rectangles. Feedback occurs after polygon culling and $(D_INLINECODE glPolygonMode) interpretation of polygons has taken place, so polygons that are culled are not returned in the feedback buffer. It can also occur after polygons with more than three edges are broken up into triangles, if the GL implementation renders polygons by performing this decomposition. The $(D_INLINECODE glPassThrough) command can be used to insert a marker into the feedback buffer. See $(D_INLINECODE glPassThrough). Following is the grammar for the blocks of values written into the feedback buffer. Each primitive is indicated with a unique identifying value followed by some number of vertices. Polygon entries include an integer value indicating how many vertices follow. A vertex is fed back as some number of floating-point values, as determined by $(D_INLINECODE type). Colors are fed back as four values in RGBA mode and one value in color index mode. feedbackList &#x2190; feedbackItem feedbackList | feedbackItem feedbackItem &#x2190; point | lineSegment | polygon | bitmap | pixelRectangle | passThru point &#x2190; $(D_INLINECODE GL_POINT_TOKEN) vertex lineSegment &#x2190; $(D_INLINECODE GL_LINE_TOKEN) vertex vertex | $(D_INLINECODE GL_LINE_RESET_TOKEN) vertex vertex polygon &#x2190; $(D_INLINECODE GL_POLYGON_TOKEN) n polySpec polySpec &#x2190; polySpec vertex | vertex vertex vertex bitmap &#x2190; $(D_INLINECODE GL_BITMAP_TOKEN) vertex pixelRectangle &#x2190; $(D_INLINECODE GL_DRAW_PIXEL_TOKEN) vertex | $(D_INLINECODE GL_COPY_PIXEL_TOKEN) vertex passThru &#x2190; $(D_INLINECODE GL_PASS_THROUGH_TOKEN) value vertex &#x2190; 2d | 3d | 3dColor | 3dColorTexture | 4dColorTexture 2d &#x2190; value value 3d &#x2190; value value value 3dColor &#x2190; value value value color 3dColorTexture &#x2190; value value value color tex 4dColorTexture &#x2190; value value value value color tex color &#x2190; rgba | index rgba &#x2190; value value value value index &#x2190; value tex &#x2190; value value value value is a floating-point number, and is a floating-point integer giving the number of vertices in the polygon. $(D_INLINECODE GL_POINT_TOKEN), $(D_INLINECODE GL_LINE_TOKEN), $(D_INLINECODE GL_LINE_RESET_TOKEN), $(D_INLINECODE GL_POLYGON_TOKEN), $(D_INLINECODE GL_BITMAP_TOKEN), $(D_INLINECODE GL_DRAW_PIXEL_TOKEN), $(D_INLINECODE GL_COPY_PIXEL_TOKEN) and $(D_INLINECODE GL_PASS_THROUGH_TOKEN) are symbolic floating-point constants. $(D_INLINECODE GL_LINE_RESET_TOKEN) is returned whenever the line stipple pattern is reset. The data returned as a vertex depends on the feedback $(D_INLINECODE type). The following table gives the correspondence between $(D_INLINECODE type) and the number of values per vertex. is 1 in color index mode and 4 in RGBA mode. $(B Type) $(B Coordinates) $(B Color) $(B Texture) $(B Total Number of Values) $(D_INLINECODE GL_2D), 2 $(D_INLINECODE GL_3D),, 3 $(D_INLINECODE GL_3D_COLOR),, k 3 + k $(D_INLINECODE GL_3D_COLOR_TEXTURE),, k 4 7 + k $(D_INLINECODE GL_4D_COLOR_TEXTURE),,, k 4 8 + k Feedback vertex coordinates are in window coordinates, except, which is in clip coordinates. Feedback colors are lighted, if lighting is enabled. Feedback texture coordinates are generated, if texture coordinate generation is enabled. They are always transformed by the texture matrix.
     + 
     + $(D_INLINECODE glFeedbackBuffer), when used in a display list, is not compiled into the display list but is executed immediately. $(D_INLINECODE glFeedbackBuffer) returns only the texture coordinate of texture unit $(D_INLINECODE GL_TEXTURE0).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glLineStipple), $(D_INLINECODE glPassThrough), $(D_INLINECODE glPolygonMode), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat* buffer) @system @nogc nothrow;

    /++
     + glGetVertexAttribPointerv: man2/glGetVertexAttribPointerv.xml
     + 
     + $(D_INLINECODE glGetVertexAttribPointerv) returns pointer information. $(D_INLINECODE index) is the generic vertex attribute to be queried, $(D_INLINECODE pname) is a symbolic constant indicating the pointer to be returned, and $(D_INLINECODE params) is a pointer to a location in which to place the returned data. If a non-zero named buffer object was bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) when the desired pointer was previously specified, the $(D_INLINECODE pointer) returned is a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glGetVertexAttribPointerv) is available only if the GL version is 2.0 or greater. The pointer returned is client-side state. The initial value for each pointer is 0.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer) @system @nogc nothrow;

    /++
     + glBlendColor: man2/glBlendColor.xml
     + 
     + The $(D_INLINECODE GL_BLEND_COLOR) may be used to calculate the source and destination blending factors. The color components are clamped to the range 0 1 before being stored. See $(D_INLINECODE glBlendFunc) for a complete description of the blending operations. Initially the $(D_INLINECODE GL_BLEND_COLOR) is set to (0, 0, 0, 0).
     + 
     + $(D_INLINECODE glBlendColor) is part of the $(D_INLINECODE ARB_imaging) subset. $(D_INLINECODE glBlendColor) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with $(D_INLINECODE GL_EXTENSIONS) as its argument.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendEquation), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glGetString)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    @OpenGL_Extension("GL_ARB_imaging")
    void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) @system @nogc nothrow;

    /++
     + glSelectBuffer: man2/glSelectBuffer.xml
     + 
     + $(D_INLINECODE glSelectBuffer) has two arguments: $(D_INLINECODE buffer) is a pointer to an array of unsigned integers, and $(D_INLINECODE size) indicates the size of the array. $(D_INLINECODE buffer) returns values from the name stack (see $(D_INLINECODE glInitNames), $(D_INLINECODE glLoadName), $(D_INLINECODE glPushName) ) when the rendering mode is $(D_INLINECODE GL_SELECT) (see $(D_INLINECODE glRenderMode) ). $(D_INLINECODE glSelectBuffer) must be issued before selection mode is enabled, and it must not be issued while the rendering mode is $(D_INLINECODE GL_SELECT). A programmer can use selection to determine which primitives are drawn into some region of a window. The region is defined by the current modelview and perspective matrices. In selection mode, no pixel fragments are produced from rasterization. Instead, if a primitive or a raster position intersects the clipping volume defined by the viewing frustum and the user-defined clipping planes, this primitive causes a selection hit. (With polygons, no hit occurs if the polygon is culled.) When a change is made to the name stack, or when $(D_INLINECODE glRenderMode) is called, a hit record is copied to $(D_INLINECODE buffer) if any hits have occurred since the last such event (name stack change or $(D_INLINECODE glRenderMode) call). The hit record consists of the number of names in the name stack at the time of the event, followed by the minimum and maximum depth values of all vertices that hit since the previous event, followed by the name stack contents, bottom name first. Depth values (which are in the range [0,1]) are multiplied by 2 32 - 1, before being placed in the hit record. An internal index into $(D_INLINECODE buffer) is reset to 0 whenever selection mode is entered. Each time a hit record is copied into $(D_INLINECODE buffer), the index is incremented to point to the cell just past the end of the block of names\(emthat is, to the next available cell If the hit record is larger than the number of remaining locations in $(D_INLINECODE buffer), as much data as can fit is copied, and the overflow flag is set. If the name stack is empty when a hit record is copied, that record consists of 0 followed by the minimum and maximum depth values. To exit selection mode, call $(D_INLINECODE glRenderMode) with an argument other than $(D_INLINECODE GL_SELECT). Whenever $(D_INLINECODE glRenderMode) is called while the render mode is $(D_INLINECODE GL_SELECT), it returns the number of hit records copied to $(D_INLINECODE buffer), resets the overflow flag and the selection buffer pointer, and initializes the name stack to be empty. If the overflow bit was set when $(D_INLINECODE glRenderMode) was called, a negative hit record count is returned.
     + 
     + The contents of $(D_INLINECODE buffer) is undefined until $(D_INLINECODE glRenderMode) is called with an argument other than $(D_INLINECODE GL_SELECT). $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) primitives and calls to $(D_INLINECODE glRasterPos) can result in hits. $(D_INLINECODE glWindowPos) will always generate a selection hit.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glInitNames), $(D_INLINECODE glLoadName), $(D_INLINECODE glPushName), $(D_INLINECODE glRenderMode)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glSelectBuffer(GLsizei size, GLuint* buffer) @system @nogc nothrow;

    /++
     + glPixelStore: man2/glPixelStore.xml
     + 
     + $(D_INLINECODE glPixelStore) sets pixel storage modes that affect the operation of subsequent $(D_INLINECODE glDrawPixels) and $(D_INLINECODE glReadPixels) as well as the unpacking of polygon stipple patterns (see $(D_INLINECODE glPolygonStipple) ), bitmaps (see $(D_INLINECODE glBitmap) ), texture patterns (see $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D) ). Additionally, if the $(D_INLINECODE ARB_imaging) extension is supported, pixel storage modes affect convolution filters (see $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), and $(D_INLINECODE glSeparableFilter2D), color table (see $(D_INLINECODE glColorTable), and $(D_INLINECODE glColorSubTable), and unpacking histogram (See $(D_INLINECODE glHistogram) ), and minmax (See $(D_INLINECODE glMinmax) ) data. $(D_INLINECODE pname) is a symbolic constant indicating the parameter to be set, and $(D_INLINECODE param) is the new value.  Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows: The other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for $(D_INLINECODE glDrawPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glBitmap), and $(D_INLINECODE glPolygonStipple). Additionally, if the $(D_INLINECODE ARB_imaging) extension is supported, $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), and $(D_INLINECODE glSeparableFilter2D). They are as follows: The following table gives the type, initial value, and range of valid values for each storage parameter that can be set with $(D_INLINECODE glPixelStore). $(B $(D_INLINECODE pname)) $(B Type) $(B Initial Value) $(B Valid Range) $(D_INLINECODE GL_PACK_SWAP_BYTES) boolean false true or false $(D_INLINECODE GL_PACK_LSB_FIRST) boolean false true or false $(D_INLINECODE GL_PACK_ROW_LENGTH) integer 0 0&#8734; $(D_INLINECODE GL_PACK_IMAGE_HEIGHT) integer 0 0&#8734; $(D_INLINECODE GL_PACK_SKIP_ROWS) integer 0 0&#8734; $(D_INLINECODE GL_PACK_SKIP_PIXELS) integer 0 0&#8734; $(D_INLINECODE GL_PACK_SKIP_IMAGES) integer 0 0&#8734; $(D_INLINECODE GL_PACK_ALIGNMENT) integer 4 1, 2, 4, or 8 $(D_INLINECODE GL_UNPACK_SWAP_BYTES) boolean false true or false $(D_INLINECODE GL_UNPACK_LSB_FIRST) boolean false true or false $(D_INLINECODE GL_UNPACK_ROW_LENGTH) integer 0 0&#8734; $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT) integer 0 0&#8734; $(D_INLINECODE GL_UNPACK_SKIP_ROWS) integer 0 0&#8734; $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) integer 0 0&#8734; $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) integer 0 0&#8734; $(D_INLINECODE GL_UNPACK_ALIGNMENT) integer 4 1, 2, 4, or 8 $(D_INLINECODE glPixelStoref) can be used to set any pixel store parameter. If the parameter type is boolean, then if $(D_INLINECODE param) is 0, the parameter is false; otherwise it is set to true. If $(D_INLINECODE pname) is a integer type parameter, $(D_INLINECODE param) is rounded to the nearest integer. Likewise, $(D_INLINECODE glPixelStorei) can also be used to set any of the pixel store parameters. Boolean parameters are set to false if $(D_INLINECODE param) is 0 and true otherwise.
     + 
     + The pixel storage modes in effect when $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glBitmap), or $(D_INLINECODE glPolygonStipple) is placed in a display list control the interpretation of memory data. Likewise, if the $(D_INLINECODE ARB_imaging) extension is supported, the pixel storage modes in effect when $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), of $(D_INLINECODE glSeparableFilter2D) is placed in a display list control the interpretation of memory data. The pixel storage modes in effect when a display list is executed are not significant. Pixel storage modes are client state and must be pushed and restored using $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBitmap), $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glHistogram), $(D_INLINECODE glMinmax), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPixelZoom), $(D_INLINECODE glPolygonStipple), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelStoref(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelStorei(GLenum pname, GLint param) @system @nogc nothrow;

    /++
     + glSampleCoverage: man2/glSampleCoverage.xml
     + 
     + Multisampling samples a pixel multiple times at various implementation-dependent subpixel locations to generate antialiasing effects.  Multisampling transparently antialiases points, lines, polygons, bitmaps, and images if it is enabled. $(D_INLINECODE value) is used in constructing a temporary mask used in determining which samples will be used in resolving the final fragment color.  This mask is bitwise-anded with the coverage mask generated from the multisampling computation.  If the $(D_INLINECODE invert) flag is set, the temporary mask is inverted (all bits flipped) and then the bitwise-and is computed. If an implementation does not have any multisample buffers available, or multisampling is disabled, rasterization occurs with only a single sample computing a pixel's final RGB color. Provided an implementation supports multisample buffers, and multisampling is enabled, then a pixel's final color is generated by combining several samples per pixel.  Each sample contains color, depth, and stencil information, allowing those operations to be performed on each sample.
     + 
     + $(D_INLINECODE glSampleCoverage) is available only if the GL version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glPushAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glSampleCoverage(GLclampf value, GLboolean invert) @system @nogc nothrow;

    /++
     + gluPartialDisk: man2/gluPartialDisk.xml
     + 
     + $(D_INLINECODE gluPartialDisk) renders a partial disk on the z = 0 plane. A partial disk is similar to a full disk, except that only the subset of the disk from $(D_INLINECODE start) through $(D_INLINECODE start) + $(D_INLINECODE sweep) is included (where 0 degrees is along the +\f2y\f axis, 90 degrees along the + axis, 180 degrees along the \- axis, and 270 degrees along the \- axis). The partial disk has a radius of $(D_INLINECODE outer) and contains a concentric circular hole with a radius of $(D_INLINECODE inner). If $(D_INLINECODE inner) is 0, then no hole is generated. The partial disk is subdivided around the axis into slices (like pizza slices) and also about the axis into rings (as specified by $(D_INLINECODE slices) and $(D_INLINECODE loops), respectively). With respect to orientation, the + side of the partial disk is considered to be outside (see $(D_INLINECODE gluQuadricOrientation) ). This means that if the orientation is set to $(D_INLINECODE GLU_OUTSIDE), then any normals generated point along the + axis. Otherwise, they point along the \- axis. If texturing is turned on (with $(D_INLINECODE gluQuadricTexture) ), texture coordinates are generated linearly such that where r = outer, the value at (, 0, 0) is (1.0, 0.5), at (0,, 0) it is (0.5, 1.0), at (\-, 0, 0) it is (0.0, 0.5), and at (0, \-, 0) it is (0.5, 0.0).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluCylinder), $(D_INLINECODE gluDisk), $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture), $(D_INLINECODE gluSphere)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluPartialDisk(GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep) @system @nogc nothrow;

    /++
     + gluTessBeginPolygon: man2/gluTessBeginPolygon.xml
     + 
     + $(D_INLINECODE gluTessBeginPolygon) and $(D_INLINECODE gluTessEndPolygon) delimit the definition of a convex, concave or self-intersecting polygon. Within each $(D_INLINECODE gluTessBeginPolygon) / $(D_INLINECODE gluTessEndPolygon) pair, there must be one or more calls to $(D_INLINECODE gluTessBeginContour) / $(D_INLINECODE gluTessEndContour). Within each contour, there are zero or more calls to $(D_INLINECODE gluTessVertex). The vertices specify a closed contour (the last vertex of each contour is automatically linked to the first). See the $(D_INLINECODE gluTessVertex), $(D_INLINECODE gluTessBeginContour), and $(D_INLINECODE gluTessEndContour) reference pages for more details. $(D_INLINECODE data) is a pointer to a user-defined data structure. If the appropriate callback(s) are specified (see $(D_INLINECODE gluTessCallback) ), then this pointer is returned to the callback function(s). Thus, it is a convenient way to store per-polygon information. Once $(D_INLINECODE gluTessEndPolygon) is called, the polygon is tessellated, and the resulting triangles are described through callbacks. See $(D_INLINECODE gluTessCallback) for descriptions of the callback functions.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessEndPolygon), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluTessBeginPolygon(GLUtesselator* tess, GLvoid* data) @system @nogc nothrow;

    /++
     + glCullFace: man2/glCullFace.xml
     + 
     + $(D_INLINECODE glCullFace) specifies whether front- or back-facing facets are culled (as specified by ) when facet culling is enabled. Facet culling is initially disabled. To enable and disable facet culling, call the $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) commands with the argument $(D_INLINECODE GL_CULL_FACE). Facets include triangles, quadrilaterals, polygons, and rectangles. $(D_INLINECODE glFrontFace) specifies which of the clockwise and counterclockwise facets are front-facing and back-facing. See $(D_INLINECODE glFrontFace).
     + 
     + If $(D_INLINECODE mode) is $(D_INLINECODE GL_FRONT_AND_BACK), no facets are drawn, but other primitives such as points and lines are drawn.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glFrontFace)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glCullFace(GLenum mode) @system @nogc nothrow;

    /++
     + glIndexMask: man2/glIndexMask.xml
     + 
     + $(D_INLINECODE glIndexMask) controls the writing of individual bits in the color index buffers. The least significant n bits of $(D_INLINECODE mask), where n is the number of bits in a color index buffer, specify a mask. Where a 1 (one) appears in the mask, it's possible to write to the corresponding bit in the color index buffer (or buffers). Where a 0 (zero) appears, the corresponding bit is write-protected. This mask is used only in color index mode, and it affects only the buffers currently selected for writing (see $(D_INLINECODE glDrawBuffer) ). Initially, all bits are enabled for writing.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glIndex), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexMask(GLuint mask) @system @nogc nothrow;

    /++
     + glGetConvolutionFilter: man2/glGetConvolutionFilter.xml
     + 
     + $(D_INLINECODE glGetConvolutionFilter) returns the current 1D or 2D convolution filter kernel as an image. The one- or two-dimensional image is placed in $(D_INLINECODE image) according to the specifications in $(D_INLINECODE format) and $(D_INLINECODE type). No pixel transfer operations are performed on this image, but the relevant pixel storage modes are applied. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a convolution filter is requested, $(D_INLINECODE image) is treated as a byte offset into the buffer object's data store. Color components that are present in $(D_INLINECODE format) but not included in the internal format of the filter are returned as zero. The assignments of internal color components to the components of $(D_INLINECODE format) are as follows. $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red Intensity Red
     + 
     + $(D_INLINECODE glGetConvolutionFilter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS). The current separable 2D filter must be retrieved with $(D_INLINECODE glGetSeparableFilter) rather than $(D_INLINECODE glGetConvolutionFilter).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetSeparableFilter), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid* image) @system @nogc nothrow;

    /++
     + glCopyColorTable: man2/glCopyColorTable.xml
     + 
     + $(D_INLINECODE glCopyColorTable) loads a color table with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glColorTable) ). The screen-aligned pixel rectangle with lower-left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ) having width $(D_INLINECODE width) and height 1 is loaded into the color table. If any pixels within this region are outside the window that is associated with the GL context, the values obtained for those pixels are undefined. The pixels in the rectangle are processed just as if $(D_INLINECODE glReadPixels) were called, with $(D_INLINECODE internalformat) set to RGBA, but processing stops after the final conversion to RGBA. The four scale parameters and the four bias parameters that are defined for the table are then used to scale and bias the R, G, B, and A components of each pixel. The scale and bias parameters are set by calling $(D_INLINECODE glColorTableParameter). Next, the R, G, B, and A values are clamped to the range 0 1. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A Finally, the red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in the color table. They form a one-dimensional table with indices in the range 0 width - 1.
     + 
     + $(D_INLINECODE glCopyColorTable) is available only if $(D_INLINECODE ARB_imaging) is returned from calling $(D_INLINECODE glGetString) with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glColorTableParameter), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;

    /++
     + gluGetTessProperty: man2/gluGetTessProperty.xml
     + 
     + $(D_INLINECODE gluGetTessProperty) retrieves properties stored in a tessellation object. These properties affect the way that tessellation objects are interpreted and rendered. See the $(D_INLINECODE gluTessProperty) reference page for information about the properties and what they do.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluGetTessProperty(GLUtesselator* tess, GLenum which, GLdouble* data) @system @nogc nothrow;

    /++
     + glScissor: man2/glScissor.xml
     + 
     + $(D_INLINECODE glScissor) defines a rectangle, called the scissor box, in window coordinates. The first two arguments, $(D_INLINECODE x) and $(D_INLINECODE y), specify the lower left corner of the box. $(D_INLINECODE width) and $(D_INLINECODE height) specify the width and height of the box. To enable and disable the scissor test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_SCISSOR_TEST). The test is initially disabled. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. $(D_INLINECODE glScissor(0,0,1,1)) allows modification of only the lower left pixel in the window, and $(D_INLINECODE glScissor(0,0,0,0)) doesn't allow modification of any pixels in the window. When the scissor test is disabled, it is as though the scissor box includes the entire window.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glScissor(GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glCopyTexImage2D: man2/glCopyTexImage2D.xml
     + 
     + $(D_INLINECODE glCopyTexImage2D) defines a two-dimensional texture image, or cube-map texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER). The screen-aligned pixel rectangle with lower left corner at ( $(D_INLINECODE x), $(D_INLINECODE y) ) and with a width of width + 2 &af; border and a height of height + 2 &af; border defines the texture array at the mipmap level specified by $(D_INLINECODE level). $(D_INLINECODE internalformat) specifies the internal format of the texture array. The pixels in the rectangle are processed exactly as if $(D_INLINECODE glCopyPixels) had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates. If any of the pixels within the specified rectangle of the current $(D_INLINECODE GL_READ_BUFFER) are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined. When $(D_INLINECODE internalformat) is one of the sRGB  types, the GL does not automatically convert the source pixels to the sRGB color space.  In this case, the $(D_INLINECODE glPixelMap) function can be used to accomplish the conversion.
     + 
     + $(D_INLINECODE glCopyTexImage2D) is available only if the GL version is 1.1 or greater. Texturing has no effect in color index mode. 1, 2, 3, and 4 are not accepted values for $(D_INLINECODE internalformat). An image with height or width of 0 indicates a null texture.
     +  When the $(D_INLINECODE ARB_imaging) extension is supported, the RGBA components read from the framebuffer may be processed by the imaging pipeline.  See $(D_INLINECODE glTexImage1D) for specific details. $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP) are available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_COMPONENT16), $(D_INLINECODE GL_DEPTH_COMPONENT24), and $(D_INLINECODE GL_DEPTH_COMPONENT32) are available only if the GL version is 1.4 or greater. The $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_SLUMINANCE), $(D_INLINECODE GL_SLUMINANCE8), $(D_INLINECODE GL_SLUMINANCE_ALPHA), and $(D_INLINECODE GL_SLUMINANCE8_ALPHA8) internal formats are only available if the GL version is 2.1 or greater.  See $(D_INLINECODE glTexImage2D) for specific details about sRGB conversion.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;

    /++
     + glIsQuery: man2/glIsQuery.xml
     + 
     + $(D_INLINECODE glIsQuery) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE id) is currently the name of a query object. If $(D_INLINECODE id) is zero, or is a non-zero value that is not currently the name of a query object, or if an error occurs, $(D_INLINECODE glIsQuery) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenQueries), but not yet associated with a query object by calling $(D_INLINECODE glBeginQuery), is not the name of a query object.
     + 
     + $(D_INLINECODE glIsQuery) is available only if the GL version is 1.5 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    GLboolean glIsQuery(GLuint id) @system @nogc nothrow;

    /++
     + glClientActiveTexture: man2/glClientActiveTexture.xml
     + 
     + $(D_INLINECODE glClientActiveTexture) selects the vertex array client state parameters to be modified by $(D_INLINECODE glTexCoordPointer), and enabled or disabled with $(D_INLINECODE glEnableClientState) or $(D_INLINECODE glDisableClientState), respectively, when called with a parameter of $(D_INLINECODE GL_TEXTURE_COORD_ARRAY).
     + 
     + $(D_INLINECODE glClientActiveTexture) is supported only if the GL version is 1.3 or greater, or $(D_INLINECODE ARB_multitexture) is included in the string returned by $(D_INLINECODE glGetString) when called with the argument $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glTexCoordPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glClientActiveTexture(GLenum texture) @system @nogc nothrow;

    /++
     + glTexImage2D: man2/glTexImage2D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.  To enable and disable two-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_2D).  To enable and disable texturing using cube-mapped texture, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_CUBE_MAP). To define texture images, call $(D_INLINECODE glTexImage2D). The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see $(D_INLINECODE glTexParameter) ), and number of color components provided. The last three arguments describe how the image is represented in memory; they are identical to the pixel formats used for $(D_INLINECODE glDrawPixels). If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_2D) or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D), or one of the $(D_INLINECODE GL_TEXTURE_CUBE_MAP) targets, data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on $(D_INLINECODE type).  These values are grouped into sets of one, two, three, or four values, depending on $(D_INLINECODE format), to form elements.  If $(D_INLINECODE type) is $(D_INLINECODE GL_BITMAP), the data is considered as a string of unsigned bytes (and $(D_INLINECODE format) must be $(D_INLINECODE GL_COLOR_INDEX) ). Each data byte is treated as eight 1-bit elements, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image. $(D_INLINECODE format) determines the composition of each element in $(D_INLINECODE data). It can assume one of these symbolic values: Refer to the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for the $(D_INLINECODE type) parameter. If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with $(D_INLINECODE internalFormat). The GL will choose an internal representation that closely approximates that requested by $(D_INLINECODE internalFormat), but it may not match exactly. (The representations specified by $(D_INLINECODE GL_LUMINANCE), $(D_INLINECODE GL_LUMINANCE_ALPHA), $(D_INLINECODE GL_RGB), and $(D_INLINECODE GL_RGBA) must match exactly. The numeric values 1, 2, 3, and 4 may also be used to specify the above representations.) If the $(D_INLINECODE internalFormat) parameter is one of the generic compressed formats, $(D_INLINECODE GL_COMPRESSED_ALPHA), $(D_INLINECODE GL_COMPRESSED_INTENSITY), $(D_INLINECODE GL_COMPRESSED_LUMINANCE), $(D_INLINECODE GL_COMPRESSED_LUMINANCE_ALPHA), $(D_INLINECODE GL_COMPRESSED_RGB), or $(D_INLINECODE GL_COMPRESSED_RGBA), the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format. If the $(D_INLINECODE internalFormat) parameter is $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_SLUMINANCE), $(D_INLINECODE GL_SLUMINANCE8), $(D_INLINECODE GL_SLUMINANCE_ALPHA), or $(D_INLINECODE GL_SLUMINANCE8_ALPHA8), the texture is treated as if the red, green, blue, or luminance components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component c s to a linear component c l is: c l = { c s 12.92 if c s &le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the $(D_INLINECODE GL_PROXY_TEXTURE_2D) or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP) target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call $(D_INLINECODE glGetTexLevelParameter). If the texture cannot be accommodated, texture state is set to 0. A one-component texture image uses only the red component of the RGBA color extracted from $(D_INLINECODE data). A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components. Depth textures can be treated as LUMINANCE, INTENSITY or ALPHA textures during texture filtering and application. Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result.  See $(D_INLINECODE glTexParameter) for details on texture comparison.
     + 
     + Texturing has no effect in color index mode. If the $(D_INLINECODE ARB_imaging) extension is supported, RGBA elements may also be processed by the imaging pipeline.  The following stages may be applied to an RGBA color before color component clamping to the range 0 1 : The texture image can be represented by the same data formats as the pixels in a $(D_INLINECODE glDrawPixels) command, except that $(D_INLINECODE GL_STENCIL_INDEX) cannot be used. $(D_INLINECODE glPixelStore) and $(D_INLINECODE glPixelTransfer) modes affect texture images in exactly the way they affect $(D_INLINECODE glDrawPixels). $(D_INLINECODE glTexImage2D) and $(D_INLINECODE GL_PROXY_TEXTURE_2D) are available only if the GL version is 1.1 or greater. Internal formats other than 1, 2, 3, or 4 may be used only if the GL version is 1.1 or greater. In GL version 1.1 or greater, $(D_INLINECODE data) may be a null pointer. In this case, texture memory is allocated to accommodate a texture of width $(D_INLINECODE width) and height $(D_INLINECODE height). You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive. Formats $(D_INLINECODE GL_BGR), and $(D_INLINECODE GL_BGRA) and types $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) are available only if the GL version is 1.2 or greater. When the $(D_INLINECODE ARB_multitexture) extension is supported or the GL version is 1.3 or greater, $(D_INLINECODE glTexImage2D) specifies the two-dimensional texture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_TEXTURE_CUBE_MAP) and $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP) are available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_COMPONENT16), $(D_INLINECODE GL_DEPTH_COMPONENT24), and $(D_INLINECODE GL_DEPTH_COMPONENT32) are available only if the GL version is 1.4 or greater. Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the $(D_INLINECODE GL_ARB_texture_non_power_of_two) extension. The $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_SLUMINANCE), $(D_INLINECODE GL_SLUMINANCE8), $(D_INLINECODE GL_SLUMINANCE_ALPHA), and $(D_INLINECODE GL_SLUMINANCE8_ALPHA8) internal formats are only available if the GL version is 2.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glColorTable), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glPixelMap: man2/glPixelMap.xml
     + 
     + $(D_INLINECODE glPixelMap) sets up translation tables, or, used by $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D). Additionally, if the $(D_INLINECODE ARB_imaging) subset is supported, the routines $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glHistogram), $(D_INLINECODE glMinmax), and $(D_INLINECODE glSeparableFilter2D). Use of these maps is described completely in the $(D_INLINECODE glPixelTransfer) reference page, and partly in the reference pages for the pixel and texture image commands. Only the specification of the maps is described in this reference page. $(D_INLINECODE map) is a symbolic map name, indicating one of ten maps to set. $(D_INLINECODE mapsize) specifies the number of entries in the map, and $(D_INLINECODE values) is a pointer to an array of $(D_INLINECODE mapsize) map values. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a pixel transfer map is specified, $(D_INLINECODE values) is treated as a byte offset into the buffer object's data store. The ten maps are as follows: The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned int integers. Maps that store color component values (all but $(D_INLINECODE GL_PIXEL_MAP_I_TO_I) and $(D_INLINECODE GL_PIXEL_MAP_S_TO_S) ) retain their values in floating-point format, with unspecified mantissa and exponent sizes. Floating-point values specified by $(D_INLINECODE glPixelMapfv) are converted directly to the internal floating-point format of these maps, then clamped to the range [0,1]. Unsigned integer values specified by $(D_INLINECODE glPixelMapusv) and $(D_INLINECODE glPixelMapuiv) are converted linearly such that the largest representable integer maps to 1.0, and 0 maps to 0.0. Maps that store indices, $(D_INLINECODE GL_PIXEL_MAP_I_TO_I) and $(D_INLINECODE GL_PIXEL_MAP_S_TO_S), retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point. Floating-point values specified by $(D_INLINECODE glPixelMapfv) are converted directly to the internal fixed-point format of these maps. Unsigned integer values specified by $(D_INLINECODE glPixelMapusv) and $(D_INLINECODE glPixelMapuiv) specify integer values, with all 0's to the right of the binary point. The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either color or stencil indices must have $(D_INLINECODE mapsize) = 2 n for some n or the results are undefined. The maximum allowable size for each map depends on the implementation and can be determined by calling $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_PIXEL_MAP_TABLE). The single maximum applies to all maps; it is at least 32. $(B $(D_INLINECODE map)) $(B Lookup Index) $(B Lookup Value) $(B Initial Size) $(B Initial Value) $(D_INLINECODE GL_PIXEL_MAP_I_TO_I) color index color index 1 0 $(D_INLINECODE GL_PIXEL_MAP_S_TO_S) stencil index stencil index 1 0 $(D_INLINECODE GL_PIXEL_MAP_I_TO_R) color index R 1 0 $(D_INLINECODE GL_PIXEL_MAP_I_TO_G) color index G 1 0 $(D_INLINECODE GL_PIXEL_MAP_I_TO_B) color index B 1 0 $(D_INLINECODE GL_PIXEL_MAP_I_TO_A) color index A 1 0 $(D_INLINECODE GL_PIXEL_MAP_R_TO_R) R R 1 0 $(D_INLINECODE GL_PIXEL_MAP_G_TO_G) G G 1 0 $(D_INLINECODE GL_PIXEL_MAP_B_TO_B) B B 1 0 $(D_INLINECODE GL_PIXEL_MAP_A_TO_A) A A 1 0
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glHistogram), $(D_INLINECODE glMinmax), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glReadPixels), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort* values) @system @nogc nothrow;

    /++
     + glColorMask: man2/glColorMask.xml
     + 
     + $(D_INLINECODE glColorMask) specifies whether the individual color components in the frame buffer can or cannot be written. If $(D_INLINECODE red) is $(D_INLINECODE GL_FALSE), for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted. Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE glColor), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDepthMask), $(D_INLINECODE glIndex), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glIndexMask), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) @system @nogc nothrow;

    /++
     + glClipPlane: man2/glClipPlane.xml
     + 
     + Geometry is always clipped against the boundaries of a six-plane frustum in,, and. $(D_INLINECODE glClipPlane) allows the specification of additional planes, not necessarily perpendicular to the,, or axis, against which all geometry is clipped. To determine the maximum number of additional clipping planes, call $(D_INLINECODE glGetIntegerv) with argument $(D_INLINECODE GL_MAX_CLIP_PLANES). All implementations support at least six such clipping planes. Because the resulting clipping region is the intersection of the defined half-spaces, it is always convex. $(D_INLINECODE glClipPlane) specifies a half-space using a four-component plane equation. When $(D_INLINECODE glClipPlane) is called, $(D_INLINECODE equation) is transformed by the inverse of the modelview matrix and stored in the resulting eye coordinates. Subsequent changes to the modelview matrix have no effect on the stored plane-equation components. If the dot product of the eye coordinates of a vertex with the stored plane equation components is positive or zero, the vertex is with respect to that clipping plane. Otherwise, it is. To enable and disable clipping planes, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with the argument $(D_INLINECODE GL_CLIP_PLANE), where is the plane number. All clipping planes are initially defined as (0, 0, 0, 0) in eye coordinates and are disabled.
     + 
     + It is always the case that $(D_INLINECODE GL_CLIP_PLANE) i = $(D_INLINECODE GL_CLIP_PLANE0) + i.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClipPlane(GLenum plane, const GLdouble* equation) @system @nogc nothrow;

    /++
     + glGetTexEnv: man2/glGetTexEnv.xml
     + 
     + $(D_INLINECODE glGetTexEnv) returns in $(D_INLINECODE params) selected values of a texture environment that was specified with $(D_INLINECODE glTexEnv). $(D_INLINECODE target) specifies a texture environment. When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_FILTER_CONTROL), $(D_INLINECODE pname) must be $(D_INLINECODE GL_TEXTURE_LOD_BIAS). When $(D_INLINECODE target) is $(D_INLINECODE GL_POINT_SPRITE), $(D_INLINECODE pname) must be $(D_INLINECODE GL_COORD_REPLACE). When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_ENV), $(D_INLINECODE pname) can be $(D_INLINECODE GL_TEXTURE_ENV_MODE), $(D_INLINECODE GL_TEXTURE_ENV_COLOR), $(D_INLINECODE GL_COMBINE_RGB), $(D_INLINECODE GL_COMBINE_ALPHA), $(D_INLINECODE GL_RGB_SCALE), $(D_INLINECODE GL_ALPHA_SCALE), $(D_INLINECODE GL_SRC0_RGB), $(D_INLINECODE GL_SRC1_RGB), $(D_INLINECODE GL_SRC2_RGB), $(D_INLINECODE GL_SRC0_ALPHA), $(D_INLINECODE GL_SRC1_ALPHA), or $(D_INLINECODE GL_SRC2_ALPHA). $(D_INLINECODE pname) names a specific texture environment parameter, as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glGetTexEnv) returns the texture environment parameters for the active texture unit. $(D_INLINECODE GL_COMBINE_RGB), $(D_INLINECODE GL_COMBINE_ALPHA), $(D_INLINECODE GL_SRC0_RGB), $(D_INLINECODE GL_SRC1_RGB), $(D_INLINECODE GL_SRC2_RGB), $(D_INLINECODE GL_SRC0_ALPHA), $(D_INLINECODE GL_SRC1_ALPHA), $(D_INLINECODE GL_SRC2_ALPHA), $(D_INLINECODE GL_OPERAND0_RGB), $(D_INLINECODE GL_OPERAND1_RGB), $(D_INLINECODE GL_OPERAND2_RGB), $(D_INLINECODE GL_OPERAND0_ALPHA), $(D_INLINECODE GL_OPERAND1_ALPHA), $(D_INLINECODE GL_OPERAND2_ALPHA), $(D_INLINECODE GL_RGB_SCALE), and $(D_INLINECODE GL_ALPHA_SCALE) are available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_TEXTURE_FILTER_CONTROL) and $(D_INLINECODE GL_TEXTURE_LOD_BIAS) are available only if the GL version is 1.4 or greater. $(D_INLINECODE GL_POINT_SPRITE) and $(D_INLINECODE GL_COORD_REPLACE) are available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glTexEnv)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexEnviv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + gluNurbsCallbackData: man2/gluNurbsCallbackData.xml
     + 
     + $(D_INLINECODE gluNurbsCallbackData) is used to pass a pointer to the application's data to NURBS tessellator. A copy of this pointer will be passed by the tessellator in the NURBS callback functions (set by $(D_INLINECODE gluNurbsCallback) ).
     + 
     + $(D_INLINECODE gluNurbsCallbackData) is available only if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData) @system @nogc nothrow;

    /++
     + glDepthFunc: man2/glDepthFunc.xml
     + 
     + $(D_INLINECODE glDepthFunc) specifies the function used to compare each incoming pixel depth value with the depth value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) of $(D_INLINECODE GL_DEPTH_TEST).) $(D_INLINECODE func) specifies the conditions under which the pixel will be drawn. The comparison functions are as follows: The initial value of $(D_INLINECODE func) is $(D_INLINECODE GL_LESS). Initially, depth testing is disabled.  If depth testing is disabled or if no depth buffer exists, it is as if the depth test always passes.
     + 
     + Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange), $(D_INLINECODE glEnable), $(D_INLINECODE glPolygonOffset)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDepthFunc(GLenum func) @system @nogc nothrow;

    /++
     + glGetTexGen: man2/glGetTexGen.xml
     + 
     + $(D_INLINECODE glGetTexGen) returns in $(D_INLINECODE params) selected parameters of a texture coordinate generation function that was specified using $(D_INLINECODE glTexGen). $(D_INLINECODE coord) names one of the (,,, ) texture coordinates, using the symbolic constant $(D_INLINECODE GL_S), $(D_INLINECODE GL_T), $(D_INLINECODE GL_R), or $(D_INLINECODE GL_Q). $(D_INLINECODE pname) specifies one of three symbolic names:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glGetTexGen) returns the texture coordinate generation parameters for the active texture unit.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glTexGen)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexGendv(GLenum coord, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexGeniv(GLenum coord, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glClearDepth: man2/glClearDepth.xml
     + 
     + $(D_INLINECODE glClearDepth) specifies the depth value used by $(D_INLINECODE glClear) to clear the depth buffer. Values specified by $(D_INLINECODE glClearDepth) are clamped to the range 0 1.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearDepth(GLclampd depth) @system @nogc nothrow;

    /++
     + gluBeginPolygon: man2/gluBeginPolygon.xml
     + 
     + $(D_INLINECODE gluBeginPolygon) and $(D_INLINECODE gluEndPolygon) delimit the definition of a nonconvex polygon. To define such a polygon, first call $(D_INLINECODE gluBeginPolygon). Then define the contours of the polygon by calling $(D_INLINECODE gluTessVertex) for each vertex and $(D_INLINECODE gluNextContour) to start each new contour. Finally, call $(D_INLINECODE gluEndPolygon) to signal the end of the definition. See the $(D_INLINECODE gluTessVertex) and $(D_INLINECODE gluNextContour) reference pages for more details. Once $(D_INLINECODE gluEndPolygon) is called, the polygon is tessellated, and the resulting triangles are described through callbacks. See $(D_INLINECODE gluTessCallback) for descriptions of the callback functions.
     + 
     + This command is obsolete and is provided for backward compatibility only. Calls to $(D_INLINECODE gluBeginPolygon) are mapped to $(D_INLINECODE gluTessBeginPolygon) followed by $(D_INLINECODE gluTessBeginContour). Calls to $(D_INLINECODE gluEndPolygon) are mapped to $(D_INLINECODE gluTessEndContour) followed by $(D_INLINECODE gluTessEndPolygon).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluNextContour), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluBeginPolygon(GLUtesselator* tess) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluEndPolygon(GLUtesselator* tess) @system @nogc nothrow;

    /++
     + glStencilOp: man2/glStencilOp.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST); to control it, call $(D_INLINECODE glStencilFunc) or $(D_INLINECODE glStencilFuncSeparate). There can be two separate sets of $(D_INLINECODE sfail), $(D_INLINECODE dpfail), and $(D_INLINECODE dppass) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilOp) sets both front and back stencil state to the same values. Use $(D_INLINECODE glStencilOpSeparate) to set front and back stencil state to different values. $(D_INLINECODE glStencilOp) takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and $(D_INLINECODE sfail) specifies what happens to the stencil buffer contents. The following eight actions are possible. Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n - 1, where n is the value returned by querying $(D_INLINECODE GL_STENCIL_BITS). The other two arguments to $(D_INLINECODE glStencilOp) specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed ( $(D_INLINECODE dppass) ) or fail ( $(D_INLINECODE dpfail) ) (see $(D_INLINECODE glDepthFunc) ). The actions are specified using the same eight symbolic constants as $(D_INLINECODE sfail). Note that $(D_INLINECODE dpfail) is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, $(D_INLINECODE sfail) and $(D_INLINECODE dppass) specify stencil action when the stencil test fails and passes, respectively.
     + 
     + $(D_INLINECODE GL_DECR_WRAP) and $(D_INLINECODE GL_INCR_WRAP) are available only if the GL version is 1.4 or greater. Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil tests always pass, regardless of any call to $(D_INLINECODE glStencilOp). $(D_INLINECODE glStencilOp) is the same as calling $(D_INLINECODE glStencilOpSeparate) with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass) @system @nogc nothrow;

    /++
     + gluPickMatrix: man2/gluPickMatrix.xml
     + 
     + $(D_INLINECODE gluPickMatrix) creates a projection matrix that can be used to restrict drawing to a small region of the viewport. This is typically useful to determine what objects are being drawn near the cursor. Use $(D_INLINECODE gluPickMatrix) to restrict drawing to a small region around the cursor. Then, enter selection mode (with $(D_INLINECODE glRenderMode) ) and rerender the scene. All primitives that would have been drawn near the cursor are identified and stored in the selection buffer. The matrix created by $(D_INLINECODE gluPickMatrix) is multiplied by the current matrix just as if $(D_INLINECODE glMultMatrix) is called with the generated matrix. To effectively use the generated pick matrix for picking, first call $(D_INLINECODE glLoadIdentity) to load an identity matrix onto the perspective matrix stack. Then call $(D_INLINECODE gluPickMatrix), and, finally, call a command (such as $(D_INLINECODE gluPerspective) ) to multiply the perspective matrix by the pick matrix. When using $(D_INLINECODE gluPickMatrix) to pick NURBS, be careful to turn off the NURBS property $(D_INLINECODE GLU_AUTO_LOAD_MATRIX).  If $(D_INLINECODE GLU_AUTO_LOAD_MATRIX) is not turned off, then any NURBS surface rendered is subdivided differently with the pick matrix than the way it was subdivided without the pick matrix.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluPerspective), $(D_INLINECODE glGet), $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glRenderMode)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint* viewport) @system @nogc nothrow;

    /++
     + glCopyTexSubImage1D: man2/glCopyTexSubImage1D.xml
     + 
     + $(D_INLINECODE glCopyTexSubImage1D) replaces a portion of a one-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glTexSubImage1D) ). The screen-aligned pixel row with left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ), and with length $(D_INLINECODE width) replaces the portion of the texture array with x indices $(D_INLINECODE xoffset) through xoffset + width - 1, inclusive. The destination in the texture array may not include any texels outside the texture array as it was originally specified. The pixels in the row are processed exactly as if $(D_INLINECODE glCopyPixels) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. It is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels within the specified row of the current $(D_INLINECODE GL_READ_BUFFER) are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the,, or parameters of the specified texture array or to texel values outside the specified subregion.
     + 
     + $(D_INLINECODE glCopyTexSubImage1D) is available only if the GL version is 1.1 or greater. Texturing has no effect in color index mode. $(D_INLINECODE glPixelStore) and $(D_INLINECODE glPixelTransfer) modes affect texture images in exactly the way they affect $(D_INLINECODE glDrawPixels). When the $(D_INLINECODE ARB_imaging) extension is supported, the RGBA components copied from the framebuffer may be processed by the imaging pipeline.  See $(D_INLINECODE glTexImage1D) for specific details.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;

    /++
     + glPolygonStipple: man2/glPolygonStipple.xml
     + 
     + Polygon stippling, like line stippling (see $(D_INLINECODE glLineStipple) ), masks out certain fragments produced by rasterization, creating a pattern. Stippling is independent of polygon antialiasing. $(D_INLINECODE pattern) is a pointer to a 32 &times; 32 stipple pattern that is stored in memory just like the pixel data supplied to a $(D_INLINECODE glDrawPixels) call with height and both equal to 32, a pixel format of $(D_INLINECODE GL_COLOR_INDEX), and data type of $(D_INLINECODE GL_BITMAP). That is, the stipple pattern is represented as a 32 &times; 32 array of 1-bit color indices packed in unsigned bytes. $(D_INLINECODE glPixelStore) parameters like $(D_INLINECODE GL_UNPACK_SWAP_BYTES) and $(D_INLINECODE GL_UNPACK_LSB_FIRST) affect the assembling of the bits into a stipple pattern. Pixel transfer operations (shift, offset, pixel map) are not applied to the stipple image, however. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a stipple pattern is specified, $(D_INLINECODE pattern) is treated as a byte offset into the buffer object's data store. To enable and disable polygon stippling, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_POLYGON_STIPPLE). Polygon stippling is initially disabled. If it's enabled, a rasterized polygon fragment with window coordinates x w and y w is sent to the next stage of the GL if and only if the ( x w % 32 )th bit in the ( y w % 32 )th row of the stipple pattern is 1 (one). When polygon stippling is disabled, it is as if the stipple pattern consists of all 1's.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawPixels), $(D_INLINECODE glLineStipple), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPolygonStipple(const(GLubyte)* pattern) @system @nogc nothrow;

    /++
     + gluQuadricTexture: man2/gluQuadricTexture.xml
     + 
     + $(D_INLINECODE gluQuadricTexture) specifies if texture coordinates should be generated for quadrics rendered with $(D_INLINECODE quad). If the value of $(D_INLINECODE texture) is $(D_INLINECODE GLU_TRUE), then texture coordinates are generated, and if $(D_INLINECODE texture) is $(D_INLINECODE GLU_FALSE), they are not.  The initial value is $(D_INLINECODE GLU_FALSE). The manner in which texture coordinates are generated depends upon the specific quadric rendered.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricDrawStyle), $(D_INLINECODE gluQuadricNormals), $(D_INLINECODE gluQuadricOrientation)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluQuadricTexture(GLUquadric* quad, GLboolean texture) @system @nogc nothrow;

    /++
     + glPassThrough: man2/glPassThrough.xml
     + 
     + Feedback is a GL render mode. The mode is selected by calling $(D_INLINECODE glRenderMode) with $(D_INLINECODE GL_FEEDBACK). When the GL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application using the GL. See the $(D_INLINECODE glFeedbackBuffer) reference page for a description of the feedback buffer and the values in it. $(D_INLINECODE glPassThrough) inserts a user-defined marker in the feedback buffer when it is executed in feedback mode. $(D_INLINECODE token) is returned as if it were a primitive; it is indicated with its own unique identifying value: $(D_INLINECODE GL_PASS_THROUGH_TOKEN). The order of $(D_INLINECODE glPassThrough) commands with respect to the specification of graphics primitives is maintained.
     + 
     + $(D_INLINECODE glPassThrough) is ignored if the GL is not in feedback mode.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glRenderMode)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPassThrough(GLfloat token) @system @nogc nothrow;

    /++
     + gluBuild1DMipmapLevels: man2/gluBuild1DMipmapLevels.xml
     + 
     + $(D_INLINECODE gluBuild1DMipmapLevels) builds a subset of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). A series of mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max) is built by decimating $(D_INLINECODE data) in half until size 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding two texels in the larger mipmap level. $(D_INLINECODE glTexImage1D) is called to load these mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max). If $(D_INLINECODE max) is larger than the highest mipmap level for the texture of the specified size, then a GLU error code is returned (see $(D_INLINECODE gluErrorString) ) and nothing is loaded. For example, if $(D_INLINECODE level) is 2 and $(D_INLINECODE width) is 16, the following levels are possible: 16 &times; 1, 8 &times; 1, 4 &times; 1, 2 &times; 1, 1 &times; 1. These correspond to levels 2 through 6 respectively. If $(D_INLINECODE base) is 3 and $(D_INLINECODE max) is 5, then only mipmap levels 8 &times; 1, 4 &times; 1 and 2 &times; 1 are loaded. However, if $(D_INLINECODE max) is 7, then an error is returned and nothing is loaded since $(D_INLINECODE max) is larger than the highest mipmap level which is, in this case, 6. The highest mipmap level can be derived from the formula log 2 &af; width &times; 2 level. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE level) parameter.
     + 
     + $(D_INLINECODE gluBuild1DMipmapLevels) is only available if the GLU version is 1.3 or greater. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void* data) @system @nogc nothrow;

    /++
     + glGetPolygonStipple: man2/glGetPolygonStipple.xml
     + 
     + $(D_INLINECODE glGetPolygonStipple) returns to $(D_INLINECODE pattern) a 32 &times; 32 polygon stipple pattern. The pattern is packed into memory as if $(D_INLINECODE glReadPixels) with both and of 32, of $(D_INLINECODE GL_BITMAP), and of $(D_INLINECODE GL_COLOR_INDEX) were called, and the stipple pattern were stored in an internal 32 &times; 32 color index buffer. Unlike $(D_INLINECODE glReadPixels), however, pixel transfer operations (shift, offset, pixel map) are not applied to the returned stipple image. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a polygon stipple pattern is requested, $(D_INLINECODE pattern) is treated as a byte offset into the buffer object's data store.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE pattern).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPolygonStipple), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetPolygonStipple(GLubyte* pattern) @system @nogc nothrow;

    /++
     + glDrawArrays: man2/glDrawArrays.xml
     + 
     + $(D_INLINECODE glDrawArrays) specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glDrawArrays). When $(D_INLINECODE glDrawArrays) is called, it uses $(D_INLINECODE count) sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element $(D_INLINECODE first). $(D_INLINECODE mode) specifies what kind of primitives are constructed and how the array elements construct those primitives. If $(D_INLINECODE GL_VERTEX_ARRAY) is not enabled, no geometric primitives are generated. Vertex attributes that are modified by $(D_INLINECODE glDrawArrays) have an unspecified value after $(D_INLINECODE glDrawArrays) returns. For example, if $(D_INLINECODE GL_COLOR_ARRAY) is enabled, the value of the current color is undefined after $(D_INLINECODE glDrawArrays) executes. Attributes that aren't modified remain well defined.
     + 
     + $(D_INLINECODE glDrawArrays) is available only if the GL version is 1.1 or greater. $(D_INLINECODE glDrawArrays) is included in display lists. If $(D_INLINECODE glDrawArrays) is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glDrawArrays(GLenum mode, GLint first, GLsizei count) @system @nogc nothrow;

    /++
     + glIndex: man2/glIndex.xml
     + 
     + $(D_INLINECODE glIndex) updates the current (single-valued) color index. It takes one argument, the new value for the current color index. The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1. Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
     + 
     + $(D_INLINECODE glIndexub) and $(D_INLINECODE glIndexubv) are available only if the GL version is 1.1 or greater. The current index can be updated at any time. In particular, $(D_INLINECODE glIndex) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColor), $(D_INLINECODE glIndexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexs(GLshort c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexi(GLint c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexf(GLfloat c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexd(GLdouble c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glIndexub(GLubyte c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexsv(const GLshort* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexiv(const GLint* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexfv(const GLfloat* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glIndexdv(const GLdouble* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glIndexubv(const(GLubyte)* c) @system @nogc nothrow;

    /++
     + glMatrixMode: man2/glMatrixMode.xml
     + 
     + $(D_INLINECODE glMatrixMode) sets the current matrix mode. $(D_INLINECODE mode) can assume one of four values: To find out which matrix stack is currently the target of all matrix operations, call $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MATRIX_MODE). The initial value is $(D_INLINECODE GL_MODELVIEW).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPopMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMatrixMode(GLenum mode) @system @nogc nothrow;

    /++
     + glDeleteProgram: man2/glDeleteProgram.xml
     + 
     + $(D_INLINECODE glDeleteProgram) frees the memory and invalidates the name associated with the program object specified by $(D_INLINECODE program.) This command effectively undoes the effects of a call to $(D_INLINECODE glCreateProgram). If a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted until it is no longer part of current state for any rendering context. If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached but not deleted unless they have already been flagged for deletion by a previous call to $(D_INLINECODE glDeleteShader). A value of 0 for $(D_INLINECODE program) will be silently ignored. To determine whether a program object has been flagged for deletion, call $(D_INLINECODE glGetProgram) with arguments $(D_INLINECODE program) and $(D_INLINECODE GL_DELETE_STATUS).
     + 
     + $(D_INLINECODE glDeleteProgram) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDeleteProgram(GLuint program) @system @nogc nothrow;

    /++
     + glEnable: man2/glEnable.xml
     + 
     + $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) enable and disable various capabilities. Use $(D_INLINECODE glIsEnabled) or $(D_INLINECODE glGet) to determine the current setting of any capability. The initial value for each capability with the exception of $(D_INLINECODE GL_DITHER) and $(D_INLINECODE GL_MULTISAMPLE) is $(D_INLINECODE GL_FALSE). The initial value for $(D_INLINECODE GL_DITHER) and $(D_INLINECODE GL_MULTISAMPLE) is $(D_INLINECODE GL_TRUE). Both $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) take a single argument, $(D_INLINECODE cap), which can assume one of the following values:
     + 
     + $(D_INLINECODE GL_POLYGON_OFFSET_FILL), $(D_INLINECODE GL_POLYGON_OFFSET_LINE), $(D_INLINECODE GL_POLYGON_OFFSET_POINT), $(D_INLINECODE GL_COLOR_LOGIC_OP), and $(D_INLINECODE GL_INDEX_LOGIC_OP) are available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_RESCALE_NORMAL), and $(D_INLINECODE GL_TEXTURE_3D) are available only if the GL version is 1.2 or greater. $(D_INLINECODE GL_MULTISAMPLE), $(D_INLINECODE GL_SAMPLE_ALPHA_TO_COVERAGE), $(D_INLINECODE GL_SAMPLE_ALPHA_TO_ONE), $(D_INLINECODE GL_SAMPLE_COVERAGE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP) are available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_POINT_SPRITE), $(D_INLINECODE GL_VERTEX_PROGRAM_POINT_SIZE), and $(D_INLINECODE GL_VERTEX_PROGRAM_TWO_SIDE) is available only if the GL version is 2.0 or greater. $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_CONVOLUTION_1D), $(D_INLINECODE GL_CONVOLUTION_2D), $(D_INLINECODE GL_HISTOGRAM), $(D_INLINECODE GL_MINMAX), $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), and $(D_INLINECODE GL_SEPARABLE_2D) are available only if $(D_INLINECODE ARB_imaging) is returned from $(D_INLINECODE glGet) with an argument of $(D_INLINECODE GL_EXTENSIONS). For OpenGL versions 1.3 and greater, or when $(D_INLINECODE ARB_multitexture) is supported, $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_GEN_S), $(D_INLINECODE GL_TEXTURE_GEN_T), $(D_INLINECODE GL_TEXTURE_GEN_R), and $(D_INLINECODE GL_TEXTURE_GEN_Q) enable or disable the respective state for the active texture unit specified with $(D_INLINECODE glActiveTexture).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glClipPlane), $(D_INLINECODE glColorMaterial), $(D_INLINECODE glCullFace), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFog), $(D_INLINECODE glGet), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glLight), $(D_INLINECODE glLightModel), $(D_INLINECODE glLineWidth), $(D_INLINECODE glLineStipple), $(D_INLINECODE glLogicOp), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2), $(D_INLINECODE glMaterial), $(D_INLINECODE glNormal), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPointSize), $(D_INLINECODE glPolygonMode), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glPolygonStipple), $(D_INLINECODE glSampleCoverage), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilOp), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEnable(GLenum cap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDisable(GLenum cap) @system @nogc nothrow;

    /++
     + glCreateProgram: man2/glCreateProgram.xml
     + 
     + $(D_INLINECODE glCreateProgram) creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program. It also provides a means for checking the compatibility of the shaders that will be used to create a program (for instance, checking the compatibility between a vertex shader and a fragment shader). When no longer needed as part of a program object, shader objects can be detached. One or more executables are created in a program object by successfully attaching shader objects to it with $(D_INLINECODE glAttachShader), successfully compiling the shader objects with $(D_INLINECODE glCompileShader), and successfully linking the program object with $(D_INLINECODE glLinkProgram). These executables are made part of current state when $(D_INLINECODE glUseProgram) is called. Program objects can be deleted by calling $(D_INLINECODE glDeleteProgram). The memory associated with the program object will be deleted when it is no longer part of current rendering state for any context.
     + 
     + $(D_INLINECODE glCreateProgram) is available only if the GL version is 2.0 or greater. Like display lists and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well. Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLuint glCreateProgram() @system @nogc nothrow;

    /++
     + glBindTexture: man2/glBindTexture.xml
     + 
     + $(D_INLINECODE glBindTexture) lets you create or use a named texture. Calling $(D_INLINECODE glBindTexture) with $(D_INLINECODE target) set to $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D) or $(D_INLINECODE GL_TEXTURE_CUBE_MAP) and $(D_INLINECODE texture) set to the name of the new texture binds the texture name to the target. When a texture is bound to a target, the previous binding for that target is automatically broken. Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared display-list space (see $(D_INLINECODE glXCreateContext) ) of the current GL rendering context; two rendering contexts share texture names only if they also share display lists. You may use $(D_INLINECODE glGenTextures) to generate a set of new texture names. When a texture is first bound, it assumes the specified target: A texture first bound to $(D_INLINECODE GL_TEXTURE_1D) becomes one-dimensional texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_2D) becomes two-dimensional texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_3D) becomes three-dimensional texture, and a texture first bound to $(D_INLINECODE GL_TEXTURE_CUBE_MAP) becomes a cube-mapped texture. The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the default $(D_INLINECODE GL_TEXTURE_1D) at GL initialization, and similarly for two- and three-dimensional textures and cube-mapped textures. While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. If texture mapping is active on the target to which a texture is bound, the bound texture is used. In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization. A texture binding created with $(D_INLINECODE glBindTexture) remains active until a different texture is bound to the same target, or until the bound texture is deleted with $(D_INLINECODE glDeleteTextures). Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use $(D_INLINECODE glBindTexture) to bind an existing named texture to one of the texture targets than it is to reload the texture image using $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), or $(D_INLINECODE glTexImage3D). For additional control over performance, use $(D_INLINECODE glPrioritizeTextures). $(D_INLINECODE glBindTexture) is included in display lists.
     + 
     + $(D_INLINECODE glBindTexture) is available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_TEXTURE_CUBE_MAP) is available only if the GL version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAreTexturesResident), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glPrioritizeTextures), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glBindTexture(GLenum target, GLuint texture) @system @nogc nothrow;

    /++
     + glBlendEquation: man2/glBlendEquation.xml
     + 
     + The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color).  This function sets both the RGB blend equation and the alpha blend equation to a single equation. These equations use the source and destination blend factors specified by either $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate). See $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate) for a description of the various blend factors. In the equations that follow, source and destination color components are referred to as R s G s B s A s and R d G d B d A d, respectively. The result color is referred to as R r G r B r A r. The source and destination blend factors are denoted s R s G s B s A and d R d G d B d A, respectively. For these equations all color components are understood to have values in the range 0 1. $(B Mode) $(B RGB Components) $(B Alpha Component) $(D_INLINECODE GL_FUNC_ADD) Rr = R s &it; s R + R d &it; d R Gr = G s &it; s G + G d &it; d G Br = B s &it; s B + B d &it; d B Ar = A s &it; s A + A d &it; d A $(D_INLINECODE GL_FUNC_SUBTRACT) Rr = R s &it; s R - R d &it; d R Gr = G s &it; s G - G d &it; d G Br = B s &it; s B - B d &it; d B Ar = A s &it; s A - A d &it; d A $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT) Rr = R d &it; d R - R s &it; s R Gr = G d &it; d G - G s &it; s G Br = B d &it; d B - B s &it; s B Ar = A d &it; d A - A s &it; s A $(D_INLINECODE GL_MIN) Rr = min &af; R s R d Gr = min &af; G s G d Br = min &af; B s B d Ar = min &af; A s A d $(D_INLINECODE GL_MAX) Rr = max &af; R s R d Gr = max &af; G s G d Br = max &af; B s B d Ar = max &af; A s A d The results of these equations are clamped to the range 0 1. The $(D_INLINECODE GL_MIN) and $(D_INLINECODE GL_MAX) equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The $(D_INLINECODE GL_FUNC_ADD) equation is useful for antialiasing and transparency, among other things. Initially, both the RGB blend equation and the alpha blend equation are set to $(D_INLINECODE GL_FUNC_ADD).
     + 
     + The $(D_INLINECODE GL_MIN), and $(D_INLINECODE GL_MAX) equations do not use the source or destination factors, only the source and destination colors.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetString), $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendFunc) $(D_INLINECODE glBlendFuncSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    @OpenGL_Extension("GL_ARB_imaging")
    void glBlendEquation(GLenum mode) @system @nogc nothrow;

    /++
     + glGetAttachedShaders: man2/glGetAttachedShaders.xml
     + 
     + $(D_INLINECODE glGetAttachedShaders) returns the names of the shader objects attached to $(D_INLINECODE program). The names of shader objects that are attached to $(D_INLINECODE program) will be returned in $(D_INLINECODE shaders.) The actual number of shader names written into $(D_INLINECODE shaders) is returned in $(D_INLINECODE count.) If no shader objects are attached to $(D_INLINECODE program), $(D_INLINECODE count) is set to 0. The maximum number of shader names that may be returned in $(D_INLINECODE shaders) is specified by $(D_INLINECODE maxCount). If the number of names actually returned is not required (for instance, if it has just been obtained by calling $(D_INLINECODE glGetProgram) ), a value of $(D_INLINECODE null
     + ) may be passed for count. If no shader objects are attached to $(D_INLINECODE program), a value of 0 will be returned in $(D_INLINECODE count). The actual number of attached shaders can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ATTACHED_SHADERS).
     + 
     + $(D_INLINECODE glGetAttachedShaders) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glDetachShader).
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders) @system @nogc nothrow;

    /++
     + glTranslate: man2/glTranslate.xml
     + 
     + $(D_INLINECODE glTranslate) produces a translation by x y z. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by this translation matrix, with the product replacing the current matrix, as if $(D_INLINECODE glMultMatrix) were called with the following matrix for its argument: 1 0 0 x 0 1 0 y 0 0 1 z 0 0 0 1 If the matrix mode is either $(D_INLINECODE GL_MODELVIEW) or $(D_INLINECODE GL_PROJECTION), all objects drawn after a call to $(D_INLINECODE glTranslate) are translated. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the untranslated coordinate system.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glRotate), $(D_INLINECODE glScale)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTranslated(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTranslatef(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;

    /++
     + glGetMap: man2/glGetMap.xml
     + 
     + $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2) define evaluators. $(D_INLINECODE glGetMap) returns evaluator parameters. $(D_INLINECODE target) chooses a map, $(D_INLINECODE query) selects a specific parameter, and $(D_INLINECODE v) points to storage where the values will be returned. The acceptable values for the $(D_INLINECODE target) parameter are described in the $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2) reference pages. $(D_INLINECODE query) can assume the following values:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE v).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEvalCoord), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMapdv(GLenum target, GLenum query, GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMapfv(GLenum target, GLenum query, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetMapiv(GLenum target, GLenum query, GLint* v) @system @nogc nothrow;

    /++
     + glEdgeFlagPointer: man2/glEdgeFlagPointer.xml
     + 
     + $(D_INLINECODE glEdgeFlagPointer) specifies the location and data format of an array of boolean edge flags to use when rendering. $(D_INLINECODE stride) specifies the byte stride from one edge flag to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while an edge flag array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as edge flag vertex array client-side state ( $(D_INLINECODE GL_EDGE_FLAG_ARRAY_BUFFER_BINDING) ). When an edge flag array is specified, $(D_INLINECODE stride) and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the edge flag array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_EDGE_FLAG_ARRAY). If enabled, the edge flag array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glEdgeFlagPointer) is available only if the GL version is 1.1 or greater. Edge flags are not supported for interleaved vertex array formats (see $(D_INLINECODE glInterleavedArrays) ). The edge flag array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glEdgeFlagPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glEdgeFlagPointer) is typically implemented on the client side. Edge flag array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlag), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glEdgeFlagPointer(GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + glCallLists: man2/glCallLists.xml
     + 
     + $(D_INLINECODE glCallLists) causes each display list in the list of names passed as $(D_INLINECODE lists) to be executed. As a result, the commands saved in each display list are executed in order, just as if they were called without using a display list. Names of display lists that have not been defined are ignored. $(D_INLINECODE glCallLists) provides an efficient means for executing more than one display list. $(D_INLINECODE type) allows lists with various name formats to be accepted. The formats are as follows: The list of display-list names is not null-terminated. Rather, $(D_INLINECODE n) specifies how many names are to be taken from $(D_INLINECODE lists). An additional level of indirection is made available with the $(D_INLINECODE glListBase) command, which specifies an unsigned offset that is added to each display-list name specified in $(D_INLINECODE lists) before that display list is executed. $(D_INLINECODE glCallLists) can appear inside a display list. To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution. This limit must be at least 64, and it depends on the implementation. GL state is not saved and restored across a call to $(D_INLINECODE glCallLists). Thus, changes made to GL state during the execution of the display lists remain after execution is completed. Use $(D_INLINECODE glPushAttrib), $(D_INLINECODE glPopAttrib), $(D_INLINECODE glPushMatrix), and $(D_INLINECODE glPopMatrix) to preserve GL state across $(D_INLINECODE glCallLists) calls.
     + 
     + Display lists can be executed between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd), as long as the display list includes only commands that are allowed in this interval.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glGenLists), $(D_INLINECODE glListBase), $(D_INLINECODE glNewList), $(D_INLINECODE glPushAttrib), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glCallLists(GLsizei n, GLenum type, const GLvoid* lists) @system @nogc nothrow;

    /++
     + glArrayElement: man2/glArrayElement.xml
     + 
     + $(D_INLINECODE glArrayElement) commands are used within $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) pairs to specify vertex and attribute data for point, line, and polygon primitives. If $(D_INLINECODE GL_VERTEX_ARRAY) is enabled when $(D_INLINECODE glArrayElement) is called, a single vertex is drawn, using vertex and attribute data taken from location $(D_INLINECODE i) of the enabled arrays. If $(D_INLINECODE GL_VERTEX_ARRAY) is not enabled, no drawing occurs but the attributes corresponding to the enabled arrays are modified. Use $(D_INLINECODE glArrayElement) to construct primitives by indexing vertex data, rather than by streaming through arrays of data in first-to-last order. Because each call specifies only a single vertex, it is possible to explicitly specify per-primitive attributes such as a single normal for each triangle. Changes made to array data between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd) may affect calls to $(D_INLINECODE glArrayElement) that are made within the same $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) period in nonsequential ways. That is, a call to $(D_INLINECODE glArrayElement) that precedes a change to array data may access the changed data, and a call that follows a change to array data may access original data.
     + 
     + $(D_INLINECODE glArrayElement) is available only if the GL version is 1.1 or greater. $(D_INLINECODE glArrayElement) is included in display lists. If $(D_INLINECODE glArrayElement) is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glArrayElement(GLint i) @system @nogc nothrow;

    /++
     + glEvalMesh: man2/glEvalMesh.xml
     + 
     + $(D_INLINECODE glMapGrid) and $(D_INLINECODE glEvalMesh) are used in tandem to efficiently generate and evaluate a series of evenly-spaced map domain values. $(D_INLINECODE glEvalMesh) steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2). $(D_INLINECODE mode) determines whether the resulting vertices are connected as points, lines, or filled polygons. In the one-dimensional case, $(D_INLINECODE glEvalMesh1), the mesh is generated as if the following code fragment were executed:
     + 
     + ---
     + glBegin(  $(D_INLINECODE type));
     + for ( i =  $(D_INLINECODE i1); i &lt;=  $(D_INLINECODE i2); i += 1 )
     +    glEvalCoord1(  i &CenterDot; &Delta; u + u 1);
     + glEnd();
     +         
     + ---
     +  where &Delta; u = u 2 - u 1 n and n, u 1, and u 2 are the arguments to the most recent $(D_INLINECODE glMapGrid1) command. is $(D_INLINECODE GL_POINTS) if $(D_INLINECODE mode) is $(D_INLINECODE GL_POINT), or $(D_INLINECODE GL_LINES) if $(D_INLINECODE mode) is $(D_INLINECODE GL_LINE). The one absolute numeric requirement is that if i = n, then the value computed from i &CenterDot; &Delta; u + u 1 is exactly u 2. In the two-dimensional case, $(D_INLINECODE glEvalMesh2), let .cp &Delta; u = u 2 - u 1 n &Delta; v = v 2 - v 1 m where n, u 1, u 2, m, v 1, and v 2 are the arguments to the most recent $(D_INLINECODE glMapGrid2) command.  Then, if $(D_INLINECODE mode) is $(D_INLINECODE GL_FILL), the $(D_INLINECODE glEvalMesh2) command is equivalent to:
     + 
     + ---
     + for ( j =  $(D_INLINECODE j1); j &lt;  $(D_INLINECODE j2); j += 1 ) {
     +    glBegin( GL_QUAD_STRIP );
     +    for ( i =  $(D_INLINECODE i1); i &lt;=  $(D_INLINECODE i2); i += 1 ) {
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j + 1 &CenterDot; &Delta; v + v 1);
     +    }
     +    glEnd();
     + }
     +         
     + ---
     +  If $(D_INLINECODE mode) is $(D_INLINECODE GL_LINE), then a call to $(D_INLINECODE glEvalMesh2) is equivalent to:
     + 
     + ---
     + for ( j =  $(D_INLINECODE j1); j &lt;=  $(D_INLINECODE j2); j += 1 ) {
     +    glBegin( GL_LINE_STRIP );
     +    for ( i =  $(D_INLINECODE i1); i &lt;=  $(D_INLINECODE i2); i += 1 )
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     +    glEnd();
     + }
     + 
     + for ( i =  $(D_INLINECODE i1);  i &lt;=  $(D_INLINECODE i2); i += 1 ) {
     +    glBegin( GL_LINE_STRIP );
     +    for ( j =  $(D_INLINECODE j1); j &lt;=  $(D_INLINECODE j1); j += 1 )
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     +    glEnd();
     + }
     +         
     + ---
     +  And finally, if $(D_INLINECODE mode) is $(D_INLINECODE GL_POINT), then a call to $(D_INLINECODE glEvalMesh2) is equivalent to:
     + 
     + ---
     + glBegin( GL_POINTS );
     + for ( j =  $(D_INLINECODE j1); j &lt;=  $(D_INLINECODE j2); j += 1 )
     +    for ( i =  $(D_INLINECODE i1); i &lt;=  $(D_INLINECODE i2); i += 1 )
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     + glEnd();
     +         
     + ---
     +  In all three cases, the only absolute numeric requirements are that if i = n, then the value computed from i &CenterDot; &Delta; u + u 1 is exactly u 2, and if j = m, then the value computed from j &CenterDot; &Delta; v + v 1 is exactly v 2.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2), $(D_INLINECODE glMapGrid)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalMesh1(GLenum mode, GLint i1, GLint i2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) @system @nogc nothrow;

    /++
     + glAccum: man2/glAccum.xml
     + 
     + The accumulation buffer is an extended-range color buffer. Images are not rendered into it. Rather, images rendered into one of the color buffers are added to the contents of the accumulation buffer after rendering. Effects such as antialiasing (of points, lines, and polygons), motion blur, and depth of field can be created by accumulating images generated with different transformation matrices. Each pixel in the accumulation buffer consists of red, green, blue, and alpha values. The number of bits per component in the accumulation buffer depends on the implementation. You can examine this number by calling $(D_INLINECODE glGetIntegerv) four times, with arguments $(D_INLINECODE GL_ACCUM_RED_BITS), $(D_INLINECODE GL_ACCUM_GREEN_BITS), $(D_INLINECODE GL_ACCUM_BLUE_BITS), and $(D_INLINECODE GL_ACCUM_ALPHA_BITS). Regardless of the number of bits per component, the range of values stored by each component is -1 1. The accumulation buffer pixels are mapped one-to-one with frame buffer pixels. $(D_INLINECODE glAccum) operates on the accumulation buffer. The first argument, $(D_INLINECODE op), is a symbolic constant that selects an accumulation buffer operation. The second argument, $(D_INLINECODE value), is a floating-point value to be used in that operation. Five operations are specified: $(D_INLINECODE GL_ACCUM), $(D_INLINECODE GL_LOAD), $(D_INLINECODE GL_ADD), $(D_INLINECODE GL_MULT), and $(D_INLINECODE GL_RETURN). All accumulation buffer operations are limited to the area of the current scissor box and applied identically to the red, green, blue, and alpha components of each pixel. If a $(D_INLINECODE glAccum) operation results in a value outside the range -1 1, the contents of an accumulation buffer pixel component are undefined. The operations are as follows: To clear the accumulation buffer, call $(D_INLINECODE glClearAccum) with R, G, B, and A values to set it to, then call $(D_INLINECODE glClear) with the accumulation buffer enabled.
     + 
     + Only pixels within the current scissor box are updated by a $(D_INLINECODE glAccum) operation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE glClearAccum), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glGet), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glReadPixels), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilOp)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glAccum(GLenum op, GLfloat value) @system @nogc nothrow;

    /++
     + gluNurbsCurve: man2/gluNurbsCurve.xml
     + 
     + Use $(D_INLINECODE gluNurbsCurve) to describe a NURBS curve. When $(D_INLINECODE gluNurbsCurve) appears between a $(D_INLINECODE gluBeginCurve) / $(D_INLINECODE gluEndCurve) pair, it is used to describe a curve to be rendered. Positional, texture, and color coordinates are associated by presenting each as a separate $(D_INLINECODE gluNurbsCurve) between a $(D_INLINECODE gluBeginCurve) / $(D_INLINECODE gluEndCurve) pair. No more than one call to $(D_INLINECODE gluNurbsCurve) for each of color, position, and texture data can be made within a single $(D_INLINECODE gluBeginCurve) / $(D_INLINECODE gluEndCurve) pair. Exactly one call must be made to describe the position of the curve (a $(D_INLINECODE type) of $(D_INLINECODE GLU_MAP1_VERTEX_3) or $(D_INLINECODE GLU_MAP1_VERTEX_4) ). When $(D_INLINECODE gluNurbsCurve) appears between a $(D_INLINECODE gluBeginTrim) / $(D_INLINECODE gluEndTrim) pair, it is used to describe a trimming curve on a NURBS surface. If $(D_INLINECODE type) is $(D_INLINECODE GLU_MAP1_TRIM_2), then it describes a curve in two-dimensional ( and ) parameter space. If it is $(D_INLINECODE GLU_MAP1_TRIM_3), then it describes a curve in two-dimensional homogeneous (,, and ) parameter space. See the $(D_INLINECODE gluBeginTrim) reference page for more discussion about trimming curves.
     + 
     + To define trim curves that stitch well, use $(D_INLINECODE gluPwlCurve).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginCurve), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluPwlCurve)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluNurbsCurve(GLUnurbs* nurb, GLint knotCount, GLfloat* knots, GLint stride, GLfloat* control, GLint order, GLenum type) @system @nogc nothrow;

    /++
     + glPushClientAttrib: man2/glPushClientAttrib.xml
     + 
     + $(D_INLINECODE glPushClientAttrib) takes one argument, a mask that indicates which groups of client-state variables to save on the client attribute stack. Symbolic constants are used to set bits in the mask. $(D_INLINECODE mask) is typically constructed by specifying the bitwise-or of several of these constants together. The special mask $(D_INLINECODE GL_CLIENT_ALL_ATTRIB_BITS) can be used to save all stackable client state. The symbolic mask constants and their associated GL client state are as follows (the second column lists which attributes are saved): $(D_INLINECODE GL_CLIENT_PIXEL_STORE_BIT) Pixel storage modes $(D_INLINECODE GL_CLIENT_VERTEX_ARRAY_BIT) Vertex arrays (and enables) $(D_INLINECODE glPopClientAttrib) restores the values of the client-state variables saved with the last $(D_INLINECODE glPushClientAttrib). Those not saved are left unchanged. It is an error to push attributes onto a full client attribute stack or to pop attributes off an empty stack. In either case, the error flag is set, and no other change is made to GL state. Initially, the client attribute stack is empty.
     + 
     + $(D_INLINECODE glPushClientAttrib) is available only if the GL version is 1.1 or greater. Not all values for GL client state can be saved on the attribute stack. For example, select and feedback state cannot be saved. The depth of the attribute stack depends on the implementation, but it must be at least 16. Use $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib) to push and restore state that is kept on the server. Only pixel storage modes and vertex array state may be pushed and popped with $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib). For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, pushing and popping client vertex array state applies to all supported texture units, and the active client texture state.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glGet), $(D_INLINECODE glGetError), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glNewList), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPushAttrib), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glPushClientAttrib(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glPopClientAttrib() @system @nogc nothrow;

    /++
     + gluCylinder: man2/gluCylinder.xml
     + 
     + $(D_INLINECODE gluCylinder) draws a cylinder oriented along the axis. The base of the cylinder is placed at = 0 and the top at z = height. Like a sphere, a cylinder is subdivided around the axis into slices and along the axis into stacks. Note that if $(D_INLINECODE top) is set to 0.0, this routine generates a cone. If the orientation is set to $(D_INLINECODE GLU_OUTSIDE) (with $(D_INLINECODE gluQuadricOrientation) ), then any generated normals point away from the axis. Otherwise, they point toward the axis. If texturing is turned on (with $(D_INLINECODE gluQuadricTexture) ), then texture coordinates are generated so that ranges linearly from 0.0 at = 0 to 1.0 at = $(D_INLINECODE height), and ranges from 0.0 at the + axis, to 0.25 at the + axis, to 0.5 at the - axis, to 0.75 at the \- axis, and back to 1.0 at the + axis.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluDisk), $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluPartialDisk), $(D_INLINECODE gluQuadricTexture), $(D_INLINECODE gluSphere)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluCylinder(GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks) @system @nogc nothrow;

    /++
     + glSecondaryColor: man2/glSecondaryColor.xml
     + 
     + The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where alpha is always set to 0.0) that is associated with every vertex. The secondary color is interpolated and applied to each fragment during rasterization when $(D_INLINECODE GL_COLOR_SUM) is enabled.  When lighting is enabled, and $(D_INLINECODE GL_SEPARATE_SPECULAR_COLOR) is specified, the value of the secondary color is assigned the value computed from the specular term of the lighting computation. Both the primary and secondary current colors are applied to each fragment, regardless of the state of $(D_INLINECODE GL_COLOR_SUM), under such conditions.  When $(D_INLINECODE GL_SEPARATE_SPECULAR_COLOR) is specified, the value returned from querying the current secondary color is undefined. $(D_INLINECODE glSecondaryColor3b), $(D_INLINECODE glSecondaryColor3s), and $(D_INLINECODE glSecondaryColor3i) take three signed byte, short, or long integers as arguments.  When $(B v) is appended to the name, the color commands can take a pointer to an array of such values. Color values are stored in floating-point format, with unspecified mantissa and exponent sizes.  Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity).  Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0).  Floating-point values are mapped directly. Neither floating-point nor signed integer values are clamped to the range 0 1 before the current color is updated.  However, color components are clamped to this range before they are interpolated or written into a color buffer.
     + 
     + $(D_INLINECODE glSecondaryColor) is available only if the GL version is 1.4 or greater. The initial value for the secondary color is (0, 0, 0, 0). The secondary color can be updated at any time.  In particular, $(D_INLINECODE glSecondaryColor) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColor), $(D_INLINECODE glIndex), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glLightModel), $(D_INLINECODE glSecondaryColorPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3i(GLint red, GLint green, GLint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3bv(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3ubv(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3usv(const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glSecondaryColor3uiv(const GLuint* v) @system @nogc nothrow;

    /++
     + gluQuadricDrawStyle: man2/gluQuadricDrawStyle.xml
     + 
     + $(D_INLINECODE gluQuadricDrawStyle) specifies the draw style for quadrics rendered with $(D_INLINECODE quad). The legal values are as follows:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricNormals), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluQuadricDrawStyle(GLUquadric* quad, GLenum draw) @system @nogc nothrow;

    /++
     + glTexSubImage2D: man2/glTexSubImage2D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable two-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_2D). $(D_INLINECODE glTexSubImage2D) redefines a contiguous subregion of an existing two-dimensional texture image. The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive, and y indices $(D_INLINECODE yoffset) and yoffset + height - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glTexSubImage2D) is available only if the GL version is 1.1 or greater. Texturing has no effect in color index mode. $(D_INLINECODE glPixelStore) and $(D_INLINECODE glPixelTransfer) modes affect texture images in exactly the way they affect $(D_INLINECODE glDrawPixels). Formats $(D_INLINECODE GL_BGR), and $(D_INLINECODE GL_BGRA) and types $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) are available only if the GL version is 1.2 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexSubImage2D) specifies a two-dimensional subtexture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). When the $(D_INLINECODE ARB_imaging) extension is supported, the RGBA components specified in $(D_INLINECODE data) may be processed by the imaging pipeline.  See $(D_INLINECODE glTexImage1D) for specific details.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + gluQuadricCallback: man2/gluQuadricCallback.xml
     + 
     + $(D_INLINECODE gluQuadricCallback) is used to define a new callback to be used by a quadrics object. If the specified callback is already defined, then it is replaced. If $(D_INLINECODE CallBackFunc) is null, then any existing callback is erased.
     +  The one legal callback is $(D_INLINECODE GLU_ERROR) :
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluErrorString), $(D_INLINECODE gluNewQuadric)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluQuadricCallback(GLUquadric* quad, GLenum which, _GLUfuncptr CallBackFunc) @system @nogc nothrow;

    /++
     + glValidateProgram: man2/glValidateProgram.xml
     + 
     + $(D_INLINECODE glValidateProgram) checks to see whether the executables contained in $(D_INLINECODE program) can execute given the current OpenGL state. The information generated by the validation process will be stored in $(D_INLINECODE program) 's information log. The validation information may consist of an empty string, or it may be a string containing information about how the current program object interacts with the rest of current OpenGL state. This provides a way for OpenGL implementers to convey more information about why the current program is inefficient, suboptimal, failing to execute, and so on. The status of the validation operation will be stored as part of the program object's state. This value will be set to $(D_INLINECODE GL_TRUE) if the validation succeeded, and $(D_INLINECODE GL_FALSE) otherwise. It can be queried by calling $(D_INLINECODE glGetProgram) with arguments $(D_INLINECODE program) and $(D_INLINECODE GL_VALIDATE_STATUS). If validation is successful, $(D_INLINECODE program) is guaranteed to execute given the current state. Otherwise, $(D_INLINECODE program) is guaranteed to not execute. This function is typically useful only during application development. The informational string stored in the information log is completely implementation dependent; therefore, an application should not expect different OpenGL implementations to produce identical information strings.
     + 
     + $(D_INLINECODE glValidateProgram) is available only if the GL version is 2.0 or greater. This function mimics the validation operation that OpenGL implementations must perform when rendering commands are issued while programmable shaders are part of current state. The error $(D_INLINECODE GL_INVALID_OPERATION) will be generated by $(D_INLINECODE glBegin), $(D_INLINECODE glRasterPos), or any command that performs an implicit call to $(D_INLINECODE glBegin) if: $(OL $(LI any two active samplers in the current program object are of different types, but refer to the same texture image unit,) $(LI any active sampler in the current program object refers to a texture image unit where fixed-function fragment processing accesses a texture target that does not match the sampler type, or) $(LI the sum of the number of active samplers in the program and the number of texture image units enabled for fixed-function fragment processing exceeds the combined limit on the total number of texture image units allowed.)) It may be difficult or cause a performance degradation for applications to catch these errors when rendering commands are issued. Therefore, applications are advised to make calls to $(D_INLINECODE glValidateProgram) to detect these issues during application development.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glValidateProgram(GLuint program) @system @nogc nothrow;

    /++
     + glDeleteQueries: man2/glDeleteQueries.xml
     + 
     + $(D_INLINECODE glDeleteQueries) deletes $(D_INLINECODE n) query objects named by the elements of the array $(D_INLINECODE ids). After a query object is deleted, it has no contents, and its name is free for reuse (for example by $(D_INLINECODE glGenQueries) ). $(D_INLINECODE glDeleteQueries) silently ignores 0's and names that do not correspond to existing query objects.
     + 
     + $(D_INLINECODE glDeleteQueries) is available only if the GL version is 1.5 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glGetQueryObject)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glDeleteQueries(GLsizei n, const GLuint* ids) @system @nogc nothrow;

    /++
     + glCompressedTexSubImage3D: man2/glCompressedTexSubImage3D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.  To enable and disable three-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_3D). $(D_INLINECODE glCompressedTexSubImage3D) redefines a contiguous subregion of an existing three-dimensional texture image.  The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, and the y indices $(D_INLINECODE yoffset) and yoffset + height - 1, and the z indices $(D_INLINECODE zoffset) and zoffset + depth - 1, inclusive.  This region may not include any texels outside the range of the texture array as it was originally specified.  It is not an error to specify a subtexture with width of 0, but such a specification has no effect. $(D_INLINECODE format) must be an extension-specified compressed-texture format.  The $(D_INLINECODE format) of the compressed texture image is selected by the GL implementation that compressed it (see $(D_INLINECODE glTexImage3D) ) and should be queried at the time the texture was compressed with $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glCompressedTexSubImage3D) is available only if the GL version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glColorTable), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;

    /++
     + gluGetNurbsProperty: man2/gluGetNurbsProperty.xml
     + 
     + $(D_INLINECODE gluGetNurbsProperty) retrieves properties stored in a NURBS object. These properties affect the way that NURBS curves and surfaces are rendered. See the $(D_INLINECODE gluNurbsProperty) reference page for information about what the properties are and what they do.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluGetNurbsProperty(GLUnurbs* nurb, GLenum property, GLfloat* data) @system @nogc nothrow;

    /++
     + glHint: man2/glHint.xml
     + 
     + Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is specified with two arguments. $(D_INLINECODE target) is a symbolic constant indicating the behavior to be controlled, and $(D_INLINECODE mode) is another symbolic constant indicating the desired behavior. The initial value for each $(D_INLINECODE target) is $(D_INLINECODE GL_DONT_CARE). $(D_INLINECODE mode) can be one of the following: Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation. The hint aspects that can be specified with $(D_INLINECODE target), along with suggested semantics, are as follows:
     + 
     + The interpretation of hints depends on the implementation. Some implementations ignore $(D_INLINECODE glHint) settings. $(D_INLINECODE GL_TEXTURE_COMPRESSION_HINT) is available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_GENERATE_MIPMAP_HINT) is available only if the GL version is 1.4 or greater. $(D_INLINECODE GL_FRAGMENT_SHADER_DERIVATIVE_HINT) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glHint(GLenum target, GLenum mode) @system @nogc nothrow;

    /++
     + glGenTextures: man2/glGenTextures.xml
     + 
     + $(D_INLINECODE glGenTextures) returns $(D_INLINECODE n) texture names in $(D_INLINECODE textures). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenTextures). The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see $(D_INLINECODE glBindTexture) ). Texture names returned by a call to $(D_INLINECODE glGenTextures) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteTextures).
     + 
     + $(D_INLINECODE glGenTextures) is available only if the GL version is 1.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glGenTextures(GLsizei n, GLuint* textures) @system @nogc nothrow;

    /++
     + glIndexPointer: man2/glIndexPointer.xml
     + 
     + $(D_INLINECODE glIndexPointer) specifies the location and data format of an array of color indexes to use when rendering. $(D_INLINECODE type) specifies the data type of each color index and $(D_INLINECODE stride) specifies the byte stride from one color index to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a color index array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as color index vertex array client-side state ( $(D_INLINECODE GL_INDEX_ARRAY_BUFFER_BINDING) ). When a color index array is specified, $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the color index array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_INDEX_ARRAY). If enabled, the color index array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glIndexPointer) is available only if the GL version is 1.1 or greater. Color indexes are not supported for interleaved vertex array formats (see $(D_INLINECODE glInterleavedArrays) ). The color index array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glIndexPointer) is not allowed between $(D_INLINECODE glBegin) and the corresponding $(D_INLINECODE glEnd), but an error may or may not be generated. If an error is not generated, the operation is undefined. $(D_INLINECODE glIndexPointer) is typically implemented on the client side. Color index array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndex), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glIndexPointer(GLenum type, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + glIsTexture: man2/glIsTexture.xml
     + 
     + $(D_INLINECODE glIsTexture) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE texture) is currently the name of a texture. If $(D_INLINECODE texture) is zero, or is a non-zero value that is not currently the name of a texture, or if an error occurs, $(D_INLINECODE glIsTexture) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenTextures), but not yet associated with a texture by calling $(D_INLINECODE glBindTexture), is not the name of a texture.
     + 
     + $(D_INLINECODE glIsTexture) is available only if the GL version is 1.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    GLboolean glIsTexture(GLuint texture) @system @nogc nothrow;

    /++
     + gluBeginSurface: man2/gluBeginSurface.xml
     + 
     + Use $(D_INLINECODE gluBeginSurface) to mark the beginning of a NURBS surface definition. After calling $(D_INLINECODE gluBeginSurface), make one or more calls to $(D_INLINECODE gluNurbsSurface) to define the attributes of the surface. Exactly one of these calls to $(D_INLINECODE gluNurbsSurface) must have a surface type of $(D_INLINECODE GLU_MAP2_VERTEX_3) or $(D_INLINECODE GLU_MAP2_VERTEX_4). To mark the end of the NURBS surface definition, call $(D_INLINECODE gluEndSurface). Trimming of NURBS surfaces is supported with $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluPwlCurve), $(D_INLINECODE gluNurbsCurve), and $(D_INLINECODE gluEndTrim). See the $(D_INLINECODE gluBeginTrim) reference page for details. GL evaluators are used to render the NURBS surface as a set of polygons. Evaluator state is preserved during rendering with $(D_INLINECODE glPushAttrib) ( $(D_INLINECODE GLU_EVAL_BIT) ) and $(D_INLINECODE glPopAttrib). See the $(D_INLINECODE glPushAttrib) reference page for details on exactly what state these calls preserve.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginCurve), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCurve), $(D_INLINECODE gluNurbsSurface), $(D_INLINECODE gluPwlCurve), $(D_INLINECODE glPushAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluBeginSurface(GLUnurbs* nurb) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluEndSurface(GLUnurbs* nurb) @system @nogc nothrow;

    /++
     + glGetProgramInfoLog: man2/glGetProgramInfoLog.xml
     + 
     + $(D_INLINECODE glGetProgramInfoLog) returns the information log for the specified program object. The information log for a program object is modified when the program object is linked or validated. The string that is returned will be null terminated. $(D_INLINECODE glGetProgramInfoLog) returns in $(D_INLINECODE infoLog) as much of the information log as it can, up to a maximum of $(D_INLINECODE maxLength) characters. The number of characters actually returned, excluding the null termination character, is specified by $(D_INLINECODE length). If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The size of the buffer required to store the returned information log can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_INFO_LOG_LENGTH). The information log for a program object is either an empty string, or a string containing information about the last link operation, or a string containing information about the last validation operation. It may contain diagnostic messages, warning messages, and other information. When a program object is created, its information log will be a string of length 0.
     + 
     + $(D_INLINECODE glGetProgramInfoLog) is available only if the GL version is 2.0 or greater. The information log for a program object is the OpenGL implementer's primary mechanism for conveying information about linking and validating. Therefore, the information log can be helpful to application developers during the development process, even when these operations are successful. Application developers should not expect different OpenGL implementations to produce identical information logs.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glGetShaderInfoLog), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;

    /++
     + glDrawElements: man2/glDrawElements.xml
     + 
     + $(D_INLINECODE glDrawElements) specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glDrawElements). When $(D_INLINECODE glDrawElements) is called, it uses $(D_INLINECODE count) sequential elements from an enabled array, starting at $(D_INLINECODE indices) to construct a sequence of geometric primitives. $(D_INLINECODE mode) specifies what kind of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used. If $(D_INLINECODE GL_VERTEX_ARRAY) is not enabled, no geometric primitives are constructed. Vertex attributes that are modified by $(D_INLINECODE glDrawElements) have an unspecified value after $(D_INLINECODE glDrawElements) returns. For example, if $(D_INLINECODE GL_COLOR_ARRAY) is enabled, the value of the current color is undefined after $(D_INLINECODE glDrawElements) executes. Attributes that aren't modified maintain their previous values.
     + 
     + $(D_INLINECODE glDrawElements) is available only if the GL version is 1.1 or greater. $(D_INLINECODE glDrawElements) is included in display lists. If $(D_INLINECODE glDrawElements) is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices) @system @nogc nothrow;

    /++
     + glGetPointerv: man2/glGetPointerv.xml
     + 
     + $(D_INLINECODE glGetPointerv) returns pointer information. $(D_INLINECODE pname) is a symbolic constant indicating the pointer to be returned, and $(D_INLINECODE params) is a pointer to a location in which to place the returned data. For all $(D_INLINECODE pname) arguments except $(D_INLINECODE GL_FEEDBACK_BUFFER_POINTER) and $(D_INLINECODE GL_SELECTION_BUFFER_POINTER), if a non-zero named buffer object was bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) when the desired pointer was previously specified, the pointer returned is a byte offset into the buffer object's data store. Buffer objects are only available in OpenGL versions 1.5 and greater.
     + 
     + $(D_INLINECODE glGetPointerv) is available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_FOG_COORD_ARRAY_POINTER) and $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY_POINTER) are available only if the GL version is 1.4 or greater. The pointers are all client-side state. The initial value for each pointer is 0. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, querying the $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_POINTER) returns the value for the active client texture unit.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glColorPointer), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glGetVertexAttribPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glSelectBuffer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetPointerv(GLenum pname, GLvoid** params) @system @nogc nothrow;

    /++
     + glBlendFunc: man2/glBlendFunc.xml
     + 
     + In RGBA mode, pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_BLEND) to enable and disable blending. $(D_INLINECODE glBlendFunc) defines the operation of blending when it is enabled. $(D_INLINECODE sfactor) specifies which method is used to scale the source color components. $(D_INLINECODE dfactor) specifies which method is used to scale the destination color components. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, source and destination color components are referred to as R s G s B s A s and R d G d B d A d. The color specified by $(D_INLINECODE glBlendColor) is referred to as R c G c B c A c. They are understood to have integer values between 0 and k R k G k B k A, where k c = 2 m c - 1 and m R m G m B m A is the number of red, green, blue, and alpha bitplanes. Source and destination scale factors are referred to as s R s G s B s A and d R d G d B d A. The scale factors described in the table, denoted f R f G f B f A, represent either source or destination factors. All scale factors have range 0 1. $(B Parameter) $(B f R f G f B f A) $(D_INLINECODE GL_ZERO) 0 0 0 0 $(D_INLINECODE GL_ONE) 1 1 1 1 $(D_INLINECODE GL_SRC_COLOR) R s k R G s k G B s k B A s k A $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 1 1 1 - R s k R G s k G B s k B A s k A $(D_INLINECODE GL_DST_COLOR) R d k R G d k G B d k B A d k A $(D_INLINECODE GL_ONE_MINUS_DST_COLOR) 1 1 1 1 - R d k R G d k G B d k B A d k A $(D_INLINECODE GL_SRC_ALPHA) A s k A A s k A A s k A A s k A $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 1 1 1 - A s k A A s k A A s k A A s k A $(D_INLINECODE GL_DST_ALPHA) A d k A A d k A A d k A A d k A $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA) 1 1 1 1 - A d k A A d k A A d k A A d k A $(D_INLINECODE GL_CONSTANT_COLOR) R c G c B c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR) 1 1 1 1 - R c G c B c A c $(D_INLINECODE GL_CONSTANT_ALPHA) A c A c A c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA) 1 1 1 1 - A c A c A c A c $(D_INLINECODE GL_SRC_ALPHA_SATURATE) i i i 1 In the table, i = min &af; A s k A - A d k A To determine the blended RGBA values of a pixel when drawing in RGBA mode, the system uses the following equations: R d = min &af; k R R s &it; s R + R d &it; d R G d = min &af; k G G s &it; s G + G d &it; d G B d = min &af; k B B s &it; s B + B d &it; d B A d = min &af; k A A s &it; s A + A d &it; d A Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when $(D_INLINECODE sfactor) is $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE dfactor) is $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), and A s is equal to k A, the equations reduce to simple replacement: R d = R s G d = G s B d = B s A d = A s
     + 
     + Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency. When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See $(D_INLINECODE glDrawBuffer).) Blending affects only RGBA rendering. It is ignored by color index renderers. $(D_INLINECODE GL_CONSTANT_COLOR), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR), $(D_INLINECODE GL_CONSTANT_ALPHA), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA) are available only if the GL version is 1.4 or greater or if the $(D_INLINECODE ARB_imaging) is supported by your implementation. $(D_INLINECODE GL_SRC_COLOR) and $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) are valid only for $(D_INLINECODE sfactor) if the GL version is 1.4 or greater. $(D_INLINECODE GL_DST_COLOR) and $(D_INLINECODE GL_ONE_MINUS_DST_COLOR) are valid only for $(D_INLINECODE dfactor) if the GL version is 1.4 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendEquation), $(D_INLINECODE glBlendFuncSeparate), $(D_INLINECODE glClear), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glBlendFunc(GLenum sfactor, GLenum dfactor) @system @nogc nothrow;

    /++
     + glIsShader: man2/glIsShader.xml
     + 
     + $(D_INLINECODE glIsShader) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE shader) is the name of a shader object previously created with $(D_INLINECODE glCreateShader) and not yet deleted with $(D_INLINECODE glDeleteShader). If $(D_INLINECODE shader) is zero or a non-zero value that is not the name of a shader object, or if an error occurs, $(D_INLINECODE glIsShader) returns $(D_INLINECODE GL_FALSE).
     + 
     + $(D_INLINECODE glIsShader) is available only if the GL version is 2.0 or greater. No error is generated if $(D_INLINECODE shader) is not a valid shader object name. A shader object marked for deletion with $(D_INLINECODE glDeleteShader) but still attached to a program object is still considered a shader object and $(D_INLINECODE glIsShader) will return $(D_INLINECODE GL_TRUE).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLboolean glIsShader(GLuint shader) @system @nogc nothrow;

    /++
     + glBegin: man2/glBegin.xml
     + 
     + $(D_INLINECODE glBegin) and $(D_INLINECODE glEnd) delimit the vertices that define a primitive or a group of like primitives. $(D_INLINECODE glBegin) accepts a single argument that specifies in which of ten ways the vertices are interpreted. Taking n as an integer count starting at one, and N as the total number of vertices specified, the interpretations are as follows: Only a subset of GL commands can be used between $(D_INLINECODE glBegin) and $(D_INLINECODE glEnd). The commands are $(D_INLINECODE glVertex), $(D_INLINECODE glColor), $(D_INLINECODE glSecondaryColor), $(D_INLINECODE glIndex), $(D_INLINECODE glNormal), $(D_INLINECODE glFogCoord), $(D_INLINECODE glTexCoord), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glArrayElement), $(D_INLINECODE glMaterial), and $(D_INLINECODE glEdgeFlag). Also, it is acceptable to use $(D_INLINECODE glCallList) or $(D_INLINECODE glCallLists) to execute display lists that include only the preceding commands. If any other GL command is executed between $(D_INLINECODE glBegin) and $(D_INLINECODE glEnd), the error flag is set and the command is ignored. Regardless of the value chosen for $(D_INLINECODE mode), there is no limit to the number of vertices that can be defined between $(D_INLINECODE glBegin) and $(D_INLINECODE glEnd). Lines, triangles, quadrilaterals, and polygons that are incompletely specified are not drawn. Incomplete specification results when either too few vertices are provided to specify even a single primitive or when an incorrect multiple of vertices is specified. The incomplete primitive is ignored; the rest are drawn. The minimum specification of vertices for each primitive is as follows: 1 for a point, 2 for a line, 3 for a triangle, 4 for a quadrilateral, and 3 for a polygon. Modes that require a certain multiple of vertices are $(D_INLINECODE GL_LINES) (2), $(D_INLINECODE GL_TRIANGLES) (3), $(D_INLINECODE GL_QUADS) (4), and $(D_INLINECODE GL_QUAD_STRIP) (2).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glColor), $(D_INLINECODE glEdgeFlag), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glFogCoord), $(D_INLINECODE glIndex), $(D_INLINECODE glMaterial), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glNormal), $(D_INLINECODE glSecondaryColor), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex), $(D_INLINECODE glVertexAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glBegin(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEnd() @system @nogc nothrow;

    /++
     + glPointParameter: man2/glPointParameter.xml
     + 
     + The following values are accepted for $(D_INLINECODE pname) :
     + 
     + $(D_INLINECODE glPointParameter) is available only if the GL version is 1.4 or greater. $(D_INLINECODE GL_POINT_SPRITE_COORD_ORIGIN) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPointSize)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glPointParameterf(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glPointParameteri(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glPointParameterfv(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glPointParameteriv(GLenum pname, const GLint* params) @system @nogc nothrow;

    /++
     + glLinkProgram: man2/glLinkProgram.xml
     + 
     + $(D_INLINECODE glLinkProgram) links the program object specified by $(D_INLINECODE program). If any shader objects of type $(D_INLINECODE GL_VERTEX_SHADER) are attached to $(D_INLINECODE program), they will be used to create an executable that will run on the programmable vertex processor. If any shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER) are attached to $(D_INLINECODE program), they will be used to create an executable that will run on the programmable fragment processor. The status of the link operation will be stored as part of the program object's state. This value will be set to $(D_INLINECODE GL_TRUE) if the program object was linked without errors and is ready for use, and $(D_INLINECODE GL_FALSE) otherwise. It can be queried by calling $(D_INLINECODE glGetProgram) with arguments $(D_INLINECODE program) and $(D_INLINECODE GL_LINK_STATUS). As a result of a successful link operation, all active user-defined uniform variables belonging to $(D_INLINECODE program) will be initialized to 0, and each of the program object's active uniform variables will be assigned a location that can be queried by calling $(D_INLINECODE glGetUniformLocation). Also, any active user-defined attribute variables that have not been bound to a generic vertex attribute index will be bound to one at this time. Linking of a program object can fail for a number of reasons as specified in the. The following lists some of the conditions that will cause a link error. $(OL $(LI The number of active attribute variables supported by the implementation has been exceeded.) $(LI The storage limit for uniform variables has been exceeded.) $(LI The number of active uniform variables supported by the implementation has been exceeded.) $(LI The $(D_INLINECODE main) function is missing for the vertex shader or the fragment shader.) $(LI A varying variable actually used in the fragment shader is not declared in the same way (or is not declared at all) in the vertex shader.) $(LI A reference to a function or variable name is unresolved.) $(LI A shared global is declared with two different types or two different initial values.) $(LI One or more of the attached shader objects has not been successfully compiled.) $(LI Binding a generic attribute matrix caused some rows of the matrix to fall outside the allowed maximum of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS).) $(LI Not enough contiguous vertex attribute slots could be found to bind attribute matrices.)) When a program object has been successfully linked, the program object can be made part of current state by calling $(D_INLINECODE glUseProgram). Whether or not the link operation was successful, the program object's information log will be overwritten. The information log can be retrieved by calling $(D_INLINECODE glGetProgramInfoLog). $(D_INLINECODE glLinkProgram) will also install the generated executables as part of the current rendering state if the link operation was successful and the specified program object is already currently in use as a result of a previous call to $(D_INLINECODE glUseProgram). If the program object currently in use is relinked unsuccessfully, its link status will be set to $(D_INLINECODE GL_FALSE), but the executables and associated state will remain part of the current state until a subsequent call to $(D_INLINECODE glUseProgram) removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked. If $(D_INLINECODE program) contains shader objects of type $(D_INLINECODE GL_VERTEX_SHADER) but does not contain shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER), the vertex shader will be linked against the implicit interface for fixed functionality fragment processing. Similarly, if $(D_INLINECODE program) contains shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER) but it does not contain shader objects of type $(D_INLINECODE GL_VERTEX_SHADER), the fragment shader will be linked against the implicit interface for fixed functionality vertex processing. The program object's information log is updated and the program is generated at the time of the link operation. After the link operation, applications are free to modify attached shader objects, compile attached shader objects, detach shader objects, delete shader objects, and attach additional shader objects. None of these operations affects the information log or the program that is part of the program object.
     + 
     + $(D_INLINECODE glLinkProgram) is available only if the GL version is 2.0 or greater. If the link operation is unsuccessful, any information about a previous link operation on $(D_INLINECODE program) is lost (i.e., a failed link does not restore the old state of $(D_INLINECODE program) ). Certain information can still be retrieved from $(D_INLINECODE program) even after an unsuccessful link operation. See for instance $(D_INLINECODE glGetActiveAttrib) and $(D_INLINECODE glGetActiveUniform).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glLinkProgram(GLuint program) @system @nogc nothrow;

    /++
     + glColorTable: man2/glColorTable.xml
     + 
     + $(D_INLINECODE glColorTable) may be used in two ways: to test the actual size and color resolution of a lookup table given a particular set of parameters, or to load the contents of a color lookup table. Use the targets $(D_INLINECODE GL_PROXY_*) for the first case and the other targets for the second case. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a color table is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. If $(D_INLINECODE target) is $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE), $(D_INLINECODE glColorTable) builds a color lookup table from an array of pixels. The pixel array specified by $(D_INLINECODE width), $(D_INLINECODE format), $(D_INLINECODE type), and $(D_INLINECODE data) is extracted from memory and processed just as if $(D_INLINECODE glDrawPixels) were called, but processing stops after the final expansion to RGBA is completed. The four scale parameters and the four bias parameters that are defined for the table are then used to scale and bias the R, G, B, and A components of each pixel. (Use $(D_INLINECODE glColorTableParameter) to set these scale and bias parameters.) Next, the R, G, B, and A values are clamped to the range 0 1. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A Finally, the red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in the color table. They form a one-dimensional table with indices in the range 0 width - 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_*), $(D_INLINECODE glColorTable) recomputes and stores the values of the proxy color table's state variables $(D_INLINECODE GL_COLOR_TABLE_FORMAT), $(D_INLINECODE GL_COLOR_TABLE_WIDTH), $(D_INLINECODE GL_COLOR_TABLE_RED_SIZE), $(D_INLINECODE GL_COLOR_TABLE_GREEN_SIZE), $(D_INLINECODE GL_COLOR_TABLE_BLUE_SIZE), $(D_INLINECODE GL_COLOR_TABLE_ALPHA_SIZE), $(D_INLINECODE GL_COLOR_TABLE_LUMINANCE_SIZE), and $(D_INLINECODE GL_COLOR_TABLE_INTENSITY_SIZE). There is no effect on the image or state of any actual color table. If the specified color table is too large to be supported, then all the proxy state variables listed above are set to zero. Otherwise, the color table could be supported by $(D_INLINECODE glColorTable) using the corresponding non-proxy target, and the proxy state variables are set as if that target were being defined. The proxy state variables can be retrieved by calling $(D_INLINECODE glGetColorTableParameter) with a target of $(D_INLINECODE GL_PROXY_*). This allows the application to decide if a particular $(D_INLINECODE glColorTable) command would succeed, and to determine what the resulting color table attributes would be. If a color table is enabled, and its width is non-zero, then its contents are used to replace a subset of the components of each RGBA pixel group, based on the internal format of the table. Each pixel group has color components (R, G, B, A) that are in the range 0.0 1.0. The color components are rescaled to the size of the color lookup table to form an index. Then a subset of the components based on the internal format of the table are replaced by the table entry selected by that index. If the color components and contents of the table are represented as follows: $(B Representation) $(B Meaning) $(D_INLINECODE r) Table index computed from $(D_INLINECODE R) $(D_INLINECODE g) Table index computed from $(D_INLINECODE G) $(D_INLINECODE b) Table index computed from $(D_INLINECODE B) $(D_INLINECODE a) Table index computed from $(D_INLINECODE A) $(D_INLINECODE L[i]) Luminance value at table index $(D_INLINECODE i) $(D_INLINECODE I[i]) Intensity value at table index $(D_INLINECODE i) $(D_INLINECODE R[i]) Red value at table index $(D_INLINECODE i) $(D_INLINECODE G[i]) Green value at table index $(D_INLINECODE i) $(D_INLINECODE B[i]) Blue value at table index $(D_INLINECODE i) $(D_INLINECODE A[i]) Alpha value at table index $(D_INLINECODE i) then the result of color table lookup is as follows: $(B Resulting Texture Components) $(B Table Internal Format) $(B R) $(B G) $(B B) $(B A) $(D_INLINECODE GL_ALPHA) $(D_INLINECODE R) $(D_INLINECODE G) $(D_INLINECODE B) $(D_INLINECODE A[a]) $(D_INLINECODE GL_LUMINANCE) $(D_INLINECODE L[r]) $(D_INLINECODE L[g]) $(D_INLINECODE L[b]) $(D_INLINECODE At) $(D_INLINECODE GL_LUMINANCE_ALPHA) $(D_INLINECODE L[r]) $(D_INLINECODE L[g]) $(D_INLINECODE L[b]) $(D_INLINECODE A[a]) $(D_INLINECODE GL_INTENSITY) $(D_INLINECODE I[r]) $(D_INLINECODE I[g]) $(D_INLINECODE I[b]) $(D_INLINECODE I[a]) $(D_INLINECODE GL_RGB) $(D_INLINECODE R[r]) $(D_INLINECODE G[g]) $(D_INLINECODE B[b]) $(D_INLINECODE A) $(D_INLINECODE GL_RGBA) $(D_INLINECODE R[r]) $(D_INLINECODE G[g]) $(D_INLINECODE B[b]) $(D_INLINECODE A[a]) When $(D_INLINECODE GL_COLOR_TABLE) is enabled, the colors resulting from the pixel map operation (if it is enabled) are mapped by the color lookup table before being passed to the convolution operation. The colors resulting from the convolution operation are modified by the post convolution color lookup table when $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE) is enabled. These modified colors are then sent to the color matrix operation. Finally, if $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE) is enabled, the colors resulting from the color matrix operation are mapped by the post color matrix color lookup table before being used by the histogram operation.
     + 
     + $(D_INLINECODE glColorTable) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS). If $(D_INLINECODE target) is set to $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE), then $(D_INLINECODE width) must be a power of two or a $(D_INLINECODE GL_INVALID_VALUE) error is generated.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorSubTable), $(D_INLINECODE glColorTableParameter), $(D_INLINECODE glCopyColorTable), $(D_INLINECODE glCopyColorSubTable), $(D_INLINECODE glGetColorTable)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glListBase: man2/glListBase.xml
     + 
     + $(D_INLINECODE glCallLists) specifies an array of offsets. Display-list names are generated by adding $(D_INLINECODE base) to each offset. Names that reference valid display lists are executed; the others are ignored.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallLists)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glListBase(GLuint base) @system @nogc nothrow;

    /++
     + glDetachShader: man2/glDetachShader.xml
     + 
     + $(D_INLINECODE glDetachShader) detaches the shader object specified by $(D_INLINECODE shader) from the program object specified by $(D_INLINECODE program). This command can be used to undo the effect of the command $(D_INLINECODE glAttachShader). If $(D_INLINECODE shader) has already been flagged for deletion by a call to $(D_INLINECODE glDeleteShader) and it is not attached to any other program object, it will be deleted after it has been detached.
     + 
     + $(D_INLINECODE glDetachShader) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDetachShader(GLuint program, GLuint shader) @system @nogc nothrow;

    /++
     + glMultiDrawArrays: man2/glMultiDrawArrays.xml
     + 
     + $(D_INLINECODE glMultiDrawArrays) specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glMultiDrawArrays). $(D_INLINECODE glMultiDrawArrays) behaves identically to $(D_INLINECODE glDrawArrays) except that $(D_INLINECODE primcount) separate ranges of elements are specified instead. When $(D_INLINECODE glMultiDrawArrays) is called, it uses $(D_INLINECODE count) sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element $(D_INLINECODE first). $(D_INLINECODE mode) specifies what kind of primitives are constructed, and how the array elements construct those primitives. If $(D_INLINECODE GL_VERTEX_ARRAY) is not enabled, no geometric primitives are generated. Vertex attributes that are modified by $(D_INLINECODE glMultiDrawArrays) have an unspecified value after $(D_INLINECODE glMultiDrawArrays) returns. For example, if $(D_INLINECODE GL_COLOR_ARRAY) is enabled, the value of the current color is undefined after $(D_INLINECODE glMultiDrawArrays) executes. Attributes that aren't modified remain well defined.
     + 
     + $(D_INLINECODE glMultiDrawArrays) is available only if the GL version is 1.4 or greater. $(D_INLINECODE glMultiDrawArrays) is included in display lists. If $(D_INLINECODE glMultiDrawArrays) is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glMultiDrawArrays(GLenum mode, GLint* first, GLsizei* count, GLsizei primcount) @system @nogc nothrow;

    /++
     + glMultTransposeMatrix: man2/glMultTransposeMatrix.xml
     + 
     + $(D_INLINECODE glMultTransposeMatrix) multiplies the current matrix with the one specified using $(D_INLINECODE m), and replaces the current matrix with the product. The current matrix is determined by the current matrix mode (see $(D_INLINECODE glMatrixMode) ). It is either the projection matrix, modelview matrix, or the texture matrix.
     + 
     + $(D_INLINECODE glMultTransposeMatrix) is available only if the GL version is 1.3 or greater. While the elements of the matrix may be specified with single or double precision, the GL may store or operate on these values in less-than-single precision. The order of the multiplication is important. For example, if the current transformation is a rotation, and $(D_INLINECODE glMultTransposeMatrix) is called with a translation matrix, the translation is done directly on the coordinates to be transformed, while the rotation is done on the results of that translation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultTransposeMatrixd(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultTransposeMatrixf(const GLfloat* m) @system @nogc nothrow;

    /++
     + glGetVertexAttrib: man2/glGetVertexAttrib.xml
     + 
     + $(D_INLINECODE glGetVertexAttrib) returns in $(D_INLINECODE params) the value of a generic vertex attribute parameter. The generic vertex attribute to be queried is specified by $(D_INLINECODE index), and the parameter to be queried is specified by $(D_INLINECODE pname). The accepted parameter names are as follows: All of the parameters except $(D_INLINECODE GL_CURRENT_VERTEX_ATTRIB) represent client-side state.
     + 
     + $(D_INLINECODE glGetVertexAttrib) is available only if the GL version is 2.0 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDisableVertexAttribArray), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetMinmaxParameter: man2/glGetMinmaxParameter.xml
     + 
     + $(D_INLINECODE glGetMinmaxParameter) retrieves parameters for the current minmax table by setting $(D_INLINECODE pname) to one of the following values: $(B Parameter) $(B Description) $(D_INLINECODE GL_MINMAX_FORMAT) Internal format of minmax table $(D_INLINECODE GL_MINMAX_SINK) Value of the parameter
     + 
     + $(D_INLINECODE glGetMinmaxParameter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMinmax), $(D_INLINECODE glGetMinmax)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glMultiTexCoord: man2/glMultiTexCoord.xml
     + 
     + $(D_INLINECODE glMultiTexCoord) specifies texture coordinates in one, two, three, or four dimensions. $(D_INLINECODE glMultiTexCoord1) sets the current texture coordinates to s 0 0 1; a call to $(D_INLINECODE glMultiTexCoord2) sets them to s t 0 1. Similarly, $(D_INLINECODE glMultiTexCoord3) specifies the texture coordinates as s t r 1, and $(D_INLINECODE glMultiTexCoord4) defines all four components explicitly as s t r q. The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for s t r q are 0 0 0 1.
     + 
     + $(D_INLINECODE glMultiTexCoord) is only supported if the GL version is 1.3 or greater, or if $(D_INLINECODE ARB_multitexture) is included in the string returned by $(D_INLINECODE glGetString) when called with the argument $(D_INLINECODE GL_EXTENSIONS). The current texture coordinates can be updated at any time. In particular, $(D_INLINECODE glMultiTexCoord) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd). It is always the case that $(D_INLINECODE GL_TEXTURE) i = $(D_INLINECODE GL_TEXTURE0) + i.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glTexCoord), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1s(GLenum target, GLshort s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1i(GLenum target, GLint s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1f(GLenum target, GLfloat s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1d(GLenum target, GLdouble s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2i(GLenum target, GLint s, GLint t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1sv(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1iv(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1fv(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord1dv(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2sv(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2iv(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2fv(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord2dv(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3sv(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3iv(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3fv(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord3dv(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4sv(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4iv(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4fv(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glMultiTexCoord4dv(GLenum target, const GLdouble* v) @system @nogc nothrow;

    /++
     + glCopyConvolutionFilter1D: man2/glCopyConvolutionFilter1D.xml
     + 
     + $(D_INLINECODE glCopyConvolutionFilter1D) defines a one-dimensional convolution filter kernel with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glConvolutionFilter1D) ). The screen-aligned pixel rectangle with lower-left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ), width $(D_INLINECODE width) and height 1 is used to define the convolution filter.  If any pixels within this region are outside the window that is associated with the GL context, the values obtained for those pixels are undefined. The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called with set to RGBA, but the process stops just before final conversion. The R, G, B, and A components of each pixel are next scaled by the four 1D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four 1D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_CONVOLUTION_1D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. Pixel ordering is such that lower x screen coordinates correspond to lower filter image coordinates. Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glCopyConvolutionFilter1D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;

    /++
     + glOrtho: man2/glOrtho.xml
     + 
     + $(D_INLINECODE glOrtho) describes a transformation that produces a parallel projection. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by this matrix and the result replaces the current matrix, as if $(D_INLINECODE glMultMatrix) were called with the following matrix as its argument: 2 right - left 0 0 t x 0 2 top - bottom 0 t y 0 0 -2 farVal - nearVal t z 0 0 0 1 where t x = - right + left right - left t y = - top + bottom top - bottom t z = - farVal + nearVal farVal - nearVal Typically, the matrix mode is $(D_INLINECODE GL_PROJECTION), and left bottom - nearVal and right top - nearVal specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, respectively, assuming that the eye is located at (0, 0, 0). - farVal specifies the location of the far clipping plane. Both $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) can be either positive or negative. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the current matrix stack.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFrustum), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal) @system @nogc nothrow;

    /++
     + glLightModel: man2/glLightModel.xml
     + 
     + $(D_INLINECODE glLightModel) sets the lighting model parameter. $(D_INLINECODE pname) names a parameter and $(D_INLINECODE params) gives the new value. There are three lighting model parameters: In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular. The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source. The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material. All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they evaluate to a negative value. The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance. In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to $(D_INLINECODE glMaterial) using $(D_INLINECODE GL_COLOR_INDEXES). Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
     + 
     + $(D_INLINECODE GL_LIGHT_MODEL_COLOR_CONTROL) is available only if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLight), $(D_INLINECODE glMaterial)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightModelf(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightModeli(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightModelfv(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLightModeliv(GLenum pname, const GLint* params) @system @nogc nothrow;

    /++
     + glTexImage1D: man2/glTexImage1D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable one-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_1D). Texture images are defined with $(D_INLINECODE glTexImage1D). The arguments describe the parameters of the texture image, such as width, width of the border, level-of-detail number (see $(D_INLINECODE glTexParameter) ), and the internal resolution and format used to store the image. The last three arguments describe how the image is represented in memory; they are identical to the pixel formats used for $(D_INLINECODE glDrawPixels). If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_1D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D), data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on $(D_INLINECODE type). These values are grouped into sets of one, two, three, or four values, depending on $(D_INLINECODE format), to form elements. If $(D_INLINECODE type) is $(D_INLINECODE GL_BITMAP), the data is considered as a string of unsigned bytes (and $(D_INLINECODE format) must be $(D_INLINECODE GL_COLOR_INDEX) ). Each data byte is treated as eight 1-bit elements, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The first element corresponds to the left end of the texture array. Subsequent elements progress left-to-right through the remaining texels in the texture array. The final element corresponds to the right end of the texture array. $(D_INLINECODE format) determines the composition of each element in $(D_INLINECODE data). It can assume one of these symbolic values: Refer to the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for the $(D_INLINECODE type) parameter. If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with $(D_INLINECODE internalFormat). The GL will choose an internal representation that closely approximates that requested by $(D_INLINECODE internalFormat), but it may not match exactly. (The representations specified by $(D_INLINECODE GL_LUMINANCE), $(D_INLINECODE GL_LUMINANCE_ALPHA), $(D_INLINECODE GL_RGB), and $(D_INLINECODE GL_RGBA) must match exactly. The numeric values 1, 2, 3, and 4 may also be used to specify the above representations.) If the $(D_INLINECODE internalFormat) parameter is one of the generic compressed formats, $(D_INLINECODE GL_COMPRESSED_ALPHA), $(D_INLINECODE GL_COMPRESSED_INTENSITY), $(D_INLINECODE GL_COMPRESSED_LUMINANCE), $(D_INLINECODE GL_COMPRESSED_LUMINANCE_ALPHA), $(D_INLINECODE GL_COMPRESSED_RGB), or $(D_INLINECODE GL_COMPRESSED_RGBA), the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format. If the $(D_INLINECODE internalFormat) parameter is $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_SLUMINANCE), $(D_INLINECODE GL_SLUMINANCE8), $(D_INLINECODE GL_SLUMINANCE_ALPHA), or $(D_INLINECODE GL_SLUMINANCE8_ALPHA8), the texture is treated as if the red, green, blue, or luminance components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component c s to a linear component c l is: c l = { c s 12.92 if c s &le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the $(D_INLINECODE GL_PROXY_TEXTURE_1D) target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call $(D_INLINECODE glGetTexLevelParameter). If the texture cannot be accommodated, texture state is set to 0. A one-component texture image uses only the red component of the RGBA color from $(D_INLINECODE data). A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components. Depth textures can be treated as LUMINANCE, INTENSITY or ALPHA textures during texture filtering and application. Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result.  See $(D_INLINECODE glTexParameter) for details on texture comparison.
     + 
     + Texturing has no effect in color index mode. If the $(D_INLINECODE ARB_imaging) extension is supported, RGBA elements may also be processed by the imaging pipeline.  The following stages may be applied to an RGBA color before color component clamping to the range 0 1 : The texture image can be represented by the same data formats as the pixels in a $(D_INLINECODE glDrawPixels) command, except that $(D_INLINECODE GL_STENCIL_INDEX) cannot be used. $(D_INLINECODE glPixelStore) and $(D_INLINECODE glPixelTransfer) modes affect texture images in exactly the way they affect $(D_INLINECODE glDrawPixels). $(D_INLINECODE GL_PROXY_TEXTURE_1D) may be used only if the GL version is 1.1 or greater. Internal formats other than 1, 2, 3, or 4 may be used only if the GL version is 1.1 or greater. In GL version 1.1 or greater, $(D_INLINECODE data) may be a null pointer. In this case texture memory is allocated to accommodate a texture of width $(D_INLINECODE width). You can then download subtextures to initialize the texture memory. The image is undefined if the program tries to apply an uninitialized portion of the texture image to a primitive. Formats $(D_INLINECODE GL_BGR), and $(D_INLINECODE GL_BGRA) and types $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) are available only if the GL version is 1.2 or greater. When the $(D_INLINECODE ARB_multitexture) extension is supported, or the GL version is 1.3 or greater, $(D_INLINECODE glTexImage1D) specifies the one-dimensional texture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_COMPONENT16), $(D_INLINECODE GL_DEPTH_COMPONENT24), and $(D_INLINECODE GL_DEPTH_COMPONENT32) are available only if the GL version is 1.4 or greater. Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the $(D_INLINECODE GL_ARB_texture_non_power_of_two) extension. The $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_SLUMINANCE), $(D_INLINECODE GL_SLUMINANCE8), $(D_INLINECODE GL_SLUMINANCE_ALPHA), and $(D_INLINECODE GL_SLUMINANCE8_ALPHA8) internal formats are only available if the GL version is 2.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glColorTable), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glStencilMask: man2/glStencilMask.xml
     + 
     + $(D_INLINECODE glStencilMask) controls the writing of individual bits in the stencil planes. The least significant n bits of $(D_INLINECODE mask), where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing. There can be two separate $(D_INLINECODE mask) writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilMask) sets both front and back stencil writemasks to the same values. Use $(D_INLINECODE glStencilMaskSeparate) to set front and back stencil writemasks to different values.
     + 
     + $(D_INLINECODE glStencilMask) is the same as calling $(D_INLINECODE glStencilMaskSeparate) with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glIndexMask), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glStencilMask(GLuint mask) @system @nogc nothrow;

    /++
     + glPushName: man2/glPushName.xml
     + 
     + The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers and is initially empty. $(D_INLINECODE glPushName) causes $(D_INLINECODE name) to be pushed onto the name stack. $(D_INLINECODE glPopName) pops one name off the top of the stack. The maximum name stack depth is implementation-dependent; call $(D_INLINECODE GL_MAX_NAME_STACK_DEPTH) to find out the value for a particular implementation. It is an error to push a name onto a full stack or to pop a name off an empty stack. It is also an error to manipulate the name stack between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd). In any of these cases, the error flag is set and no other change is made to GL state. The name stack is always empty while the render mode is not $(D_INLINECODE GL_SELECT). Calls to $(D_INLINECODE glPushName) or $(D_INLINECODE glPopName) while the render mode is not $(D_INLINECODE GL_SELECT) are ignored.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInitNames), $(D_INLINECODE glLoadName), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPushName(GLuint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPopName() @system @nogc nothrow;

    /++
     + glDeleteShader: man2/glDeleteShader.xml
     + 
     + $(D_INLINECODE glDeleteShader) frees the memory and invalidates the name associated with the shader object specified by $(D_INLINECODE shader). This command effectively undoes the effects of a call to $(D_INLINECODE glCreateShader). If a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted). A value of 0 for $(D_INLINECODE shader) will be silently ignored. To determine whether an object has been flagged for deletion, call $(D_INLINECODE glGetShader) with arguments $(D_INLINECODE shader) and $(D_INLINECODE GL_DELETE_STATUS).
     + 
     + $(D_INLINECODE glDeleteShader) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDeleteShader(GLuint shader) @system @nogc nothrow;

    /++
     + glFogCoordPointer: man2/glFogCoordPointer.xml
     + 
     + $(D_INLINECODE glFogCoordPointer) specifies the location and data format of an array of fog coordinates to use when rendering. $(D_INLINECODE type) specifies the data type of each fog coordinate, and $(D_INLINECODE stride) specifies the byte stride from one fog coordinate to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a fog coordinate array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as fog coordinate vertex array client-side state ( $(D_INLINECODE GL_FOG_COORD_ARRAY_BUFFER_BINDING) ). When a fog coordinate array is specified, $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the fog coordinate array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_FOG_COORD_ARRAY). If enabled, the fog coordinate array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glFogCoordPointer) is available only if the GL version is 1.4 or greater. Fog coordinates are not supported for interleaved vertex array formats (see $(D_INLINECODE glInterleavedArrays) ). The fog coordinate array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glFogCoordPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glFogCoordPointer) is typically implemented on the client side with no protocol. Fog coordinate array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoord), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoordPointer(GLenum type, GLsizei stride, GLvoid* pointer) @system @nogc nothrow;

    /++
     + glResetHistogram: man2/glResetHistogram.xml
     + 
     + $(D_INLINECODE glResetHistogram) resets all the elements of the current histogram table to zero.
     + 
     + $(D_INLINECODE glResetHistogram) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glHistogram)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glResetHistogram(GLenum target) @system @nogc nothrow;

    /++
     + glDeleteBuffers: man2/glDeleteBuffers.xml
     + 
     + $(D_INLINECODE glDeleteBuffers) deletes $(D_INLINECODE n) buffer objects named by the elements of the array $(D_INLINECODE buffers). After a buffer object is deleted, it has no contents, and its name is free for reuse (for example by $(D_INLINECODE glGenBuffers) ). If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any buffer object, which reverts to client memory usage). $(D_INLINECODE glDeleteBuffers) silently ignores 0's and names that do not correspond to existing buffer objects.
     + 
     + $(D_INLINECODE glDeleteBuffers) is available only if the GL version is 1.5 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glGenBuffers), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glDeleteBuffers(GLsizei n, const GLuint* buffers) @system @nogc nothrow;

    /++
     + glRenderMode: man2/glRenderMode.xml
     + 
     + $(D_INLINECODE glRenderMode) sets the rasterization mode. It takes one argument, $(D_INLINECODE mode), which can assume one of three predefined values: The return value of $(D_INLINECODE glRenderMode) is determined by the render mode at the time $(D_INLINECODE glRenderMode) is called, rather than by $(D_INLINECODE mode). The values returned for the three render modes are as follows: See the $(D_INLINECODE glSelectBuffer) and $(D_INLINECODE glFeedbackBuffer) reference pages for more details concerning selection and feedback operation.
     + 
     + If an error is generated, $(D_INLINECODE glRenderMode) returns 0 regardless of the current render mode.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glInitNames), $(D_INLINECODE glLoadName), $(D_INLINECODE glPassThrough), $(D_INLINECODE glPushName), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLint glRenderMode(GLenum mode) @system @nogc nothrow;

    /++
     + glMaterial: man2/glMaterial.xml
     + 
     + $(D_INLINECODE glMaterial) assigns values to material parameters. There are two matched sets of material parameters. One, the set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set,, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the $(D_INLINECODE glLightModel) reference page for details concerning one- and two-sided lighting calculations. $(D_INLINECODE glMaterial) takes three arguments. The first, $(D_INLINECODE face), specifies whether the $(D_INLINECODE GL_FRONT) materials, the $(D_INLINECODE GL_BACK) materials, or both $(D_INLINECODE GL_FRONT_AND_BACK) materials will be modified. The second, $(D_INLINECODE pname), specifies which of several parameters in one or both sets will be modified. The third, $(D_INLINECODE params), specifies what value or values will be assigned to the specified parameter. Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in the $(D_INLINECODE glLightModel) reference page. The parameters that can be specified using $(D_INLINECODE glMaterial), and their interpretations by the lighting equation, are as follows:
     + 
     + The material parameters can be updated at any time. In particular, $(D_INLINECODE glMaterial) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd). If only a single material parameter is to be changed per vertex, however, $(D_INLINECODE glColorMaterial) is preferred over $(D_INLINECODE glMaterial) (see $(D_INLINECODE glColorMaterial) ). While the ambient, diffuse, specular and emission material parameters all have alpha components, only the diffuse alpha component is used in the lighting computation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMaterial), $(D_INLINECODE glLight), $(D_INLINECODE glLightModel)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMaterialf(GLenum face, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMateriali(GLenum face, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMaterialfv(GLenum face, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMaterialiv(GLenum face, GLenum pname, const GLint* params) @system @nogc nothrow;

    /++
     + glGetMinmax: man2/glGetMinmax.xml
     + 
     + $(D_INLINECODE glGetMinmax) returns the accumulated minimum and maximum pixel values (computed on a per-component basis) in a one-dimensional image of width 2.  The first set of return values are the minima, and the second set of return values are the maxima. The format of the return values is determined by $(D_INLINECODE format), and their type is determined by $(D_INLINECODE types). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while minimum and maximum pixel values are requested, $(D_INLINECODE values) is treated as a byte offset into the buffer object's data store. No pixel transfer operations are performed on the return values, but pixel storage modes that are applicable to one-dimensional images are performed. Color components that are requested in the specified $(D_INLINECODE format), but that are not included in the internal format of the minmax table, are returned as zero.  The assignment of internal color components to the components requested by $(D_INLINECODE format) are as follows: $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red If $(D_INLINECODE reset) is $(D_INLINECODE GL_TRUE), the minmax table entries corresponding to the return values are reset to their initial values.  Minimum and maximum values that are not returned are not modified, even if $(D_INLINECODE reset) is $(D_INLINECODE GL_TRUE).
     + 
     + $(D_INLINECODE glGetMinmax) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMinmax), $(D_INLINECODE glResetMinmax),
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid* values) @system @nogc nothrow;

    /++
     + glGetCompressedTexImage: man2/glGetCompressedTexImage.xml
     + 
     + $(D_INLINECODE glGetCompressedTexImage) returns the compressed texture image associated with $(D_INLINECODE target) and $(D_INLINECODE lod) into $(D_INLINECODE img). $(D_INLINECODE img) should be an array of $(D_INLINECODE GL_TEXTURE_COMPRESSED_IMAGE_SIZE) bytes. $(D_INLINECODE target) specifies whether the desired texture image was one specified by $(D_INLINECODE glTexImage1D) ( $(D_INLINECODE GL_TEXTURE_1D) ), $(D_INLINECODE glTexImage2D) ( $(D_INLINECODE GL_TEXTURE_2D) or any of $(D_INLINECODE GL_TEXTURE_CUBE_MAP_*) ), or $(D_INLINECODE glTexImage3D) ( $(D_INLINECODE GL_TEXTURE_3D) ). $(D_INLINECODE lod) specifies the level-of-detail number of the desired image. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is requested, $(D_INLINECODE img) is treated as a byte offset into the buffer object's data store. To minimize errors, first verify that the texture is compressed by calling $(D_INLINECODE glGetTexLevelParameter) with argument $(D_INLINECODE GL_TEXTURE_COMPRESSED).  If the texture is compressed, then determine the amount of memory required to store the compressed texture by calling $(D_INLINECODE glGetTexLevelParameter) with argument $(D_INLINECODE GL_TEXTURE_COMPRESSED_IMAGE_SIZE).  Finally, retrieve the internal format of the texture by calling $(D_INLINECODE glGetTexLevelParameter) with argument $(D_INLINECODE GL_TEXTURE_INTERNAL_FORMAT). To store the texture for later use, associate the internal format and size with the retrieved texture image.  These data can be used by the respective texture or subtexture loading routine used for loading $(D_INLINECODE target) textures.
     + 
     + $(D_INLINECODE glGetCompressedTexImage) is available only if the GL version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid* img) @system @nogc nothrow;

    /++
     + glReadBuffer: man2/glReadBuffer.xml
     + 
     + $(D_INLINECODE glReadBuffer) specifies a color buffer as the source for subsequent $(D_INLINECODE glReadPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), and $(D_INLINECODE glCopyPixels) commands. $(D_INLINECODE mode) accepts one of twelve or more predefined values. ( $(D_INLINECODE GL_AUX0) through $(D_INLINECODE GL_AUX3) are always defined.) In a fully configured system, $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_LEFT), and $(D_INLINECODE GL_FRONT_LEFT) all name the front left buffer, $(D_INLINECODE GL_FRONT_RIGHT) and $(D_INLINECODE GL_RIGHT) name the front right buffer, and $(D_INLINECODE GL_BACK_LEFT) and $(D_INLINECODE GL_BACK) name the back left buffer. Nonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify a nonexistent buffer to $(D_INLINECODE glReadBuffer). $(D_INLINECODE mode) is initially $(D_INLINECODE GL_FRONT) in single-buffered configurations and $(D_INLINECODE GL_BACK) in double-buffered configurations.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glReadBuffer(GLenum mode) @system @nogc nothrow;

    /++
     + glGetBufferSubData: man2/glGetBufferSubData.xml
     + 
     + $(D_INLINECODE glGetBufferSubData) returns some or all of the data from the buffer object currently bound to $(D_INLINECODE target). Data starting at byte offset $(D_INLINECODE offset) and extending for $(D_INLINECODE size) bytes is copied from the data store to the memory pointed to by $(D_INLINECODE data). An error is thrown if the buffer object is currently mapped, or if $(D_INLINECODE offset) and $(D_INLINECODE size) together define a range beyond the bounds of the buffer object's data store.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE data). $(D_INLINECODE glGetBufferSubData) is available only if the GL version is 1.5 or greater. Targets $(D_INLINECODE GL_PIXEL_PACK_BUFFER) and $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) are available only if the GL version is 2.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data) @system @nogc nothrow;

    /++
     + glGet: man2/glGet.xml
     + 
     + These four commands return values for simple state variables in GL. $(D_INLINECODE pname) is a symbolic constant indicating the state variable to be returned, and $(D_INLINECODE params) is a pointer to an array of the indicated type in which to place the returned data. Type conversion is performed if $(D_INLINECODE params) has a different type than the state variable value being requested. If $(D_INLINECODE glGetBooleanv) is called, a floating-point (or integer) value is converted to $(D_INLINECODE GL_FALSE) if and only if it is 0.0 (or 0). Otherwise, it is converted to $(D_INLINECODE GL_TRUE). If $(D_INLINECODE glGetIntegerv) is called, boolean values are returned as $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE), and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and -1.0 to the most negative representable integer value. If $(D_INLINECODE glGetFloatv) or $(D_INLINECODE glGetDoublev) is called, boolean values are returned as $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE), and integer values are converted to floating-point values. The following symbolic constants are accepted by $(D_INLINECODE pname) : Many of the boolean parameters can also be queried more easily using $(D_INLINECODE glIsEnabled).
     + 
     + $(D_INLINECODE GL_COLOR_LOGIC_OP), $(D_INLINECODE GL_COLOR_ARRAY), $(D_INLINECODE GL_COLOR_ARRAY_SIZE), $(D_INLINECODE GL_COLOR_ARRAY_STRIDE), $(D_INLINECODE GL_COLOR_ARRAY_TYPE), $(D_INLINECODE GL_EDGE_FLAG_ARRAY), $(D_INLINECODE GL_EDGE_FLAG_ARRAY_STRIDE), $(D_INLINECODE GL_INDEX_ARRAY), $(D_INLINECODE GL_INDEX_ARRAY_STRIDE), $(D_INLINECODE GL_INDEX_ARRAY_TYPE), $(D_INLINECODE GL_INDEX_LOGIC_OP), $(D_INLINECODE GL_NORMAL_ARRAY), $(D_INLINECODE GL_NORMAL_ARRAY_STRIDE), $(D_INLINECODE GL_NORMAL_ARRAY_TYPE), $(D_INLINECODE GL_POLYGON_OFFSET_UNITS), $(D_INLINECODE GL_POLYGON_OFFSET_FACTOR), $(D_INLINECODE GL_POLYGON_OFFSET_FILL), $(D_INLINECODE GL_POLYGON_OFFSET_LINE), $(D_INLINECODE GL_POLYGON_OFFSET_POINT), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_SIZE), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_STRIDE), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_TYPE), $(D_INLINECODE GL_VERTEX_ARRAY), $(D_INLINECODE GL_VERTEX_ARRAY_SIZE), $(D_INLINECODE GL_VERTEX_ARRAY_STRIDE), and $(D_INLINECODE GL_VERTEX_ARRAY_TYPE) are available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_ALIASED_POINT_SIZE_RANGE), $(D_INLINECODE GL_FEEDBACK_BUFFER_SIZE), $(D_INLINECODE GL_FEEDBACK_BUFFER_TYPE), $(D_INLINECODE GL_LIGHT_MODEL_AMBIENT), $(D_INLINECODE GL_LIGHT_MODEL_COLOR_CONTROL), $(D_INLINECODE GL_MAX_3D_TEXTURE_SIZE), $(D_INLINECODE GL_MAX_ELEMENTS_INDICES), $(D_INLINECODE GL_MAX_ELEMENTS_VERTICES), $(D_INLINECODE GL_PACK_IMAGE_HEIGHT), $(D_INLINECODE GL_PACK_SKIP_IMAGES), $(D_INLINECODE GL_RESCALE_NORMAL), $(D_INLINECODE GL_SELECTION_BUFFER_SIZE), $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_GRANULARITY), $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_RANGE), $(D_INLINECODE GL_SMOOTH_POINT_SIZE_GRANULARITY), $(D_INLINECODE GL_SMOOTH_POINT_SIZE_RANGE), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_BINDING_3D), $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT), and $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) are available only if the GL version is 1.2 or greater. $(D_INLINECODE GL_COMPRESSED_TEXTURE_FORMATS), $(D_INLINECODE GL_NUM_COMPRESSED_TEXTURE_FORMATS), $(D_INLINECODE GL_TEXTURE_BINDING_CUBE_MAP), and $(D_INLINECODE GL_TEXTURE_COMPRESSION_HINT) are available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_BLEND_DST_ALPHA), $(D_INLINECODE GL_BLEND_DST_RGB), $(D_INLINECODE GL_BLEND_SRC_ALPHA), $(D_INLINECODE GL_BLEND_SRC_RGB), $(D_INLINECODE GL_CURRENT_FOG_COORD), $(D_INLINECODE GL_CURRENT_SECONDARY_COLOR), $(D_INLINECODE GL_FOG_COORD_ARRAY_STRIDE), $(D_INLINECODE GL_FOG_COORD_ARRAY_TYPE), $(D_INLINECODE GL_FOG_COORD_SRC), $(D_INLINECODE GL_MAX_TEXTURE_LOD_BIAS), $(D_INLINECODE GL_POINT_SIZE_MIN), $(D_INLINECODE GL_POINT_SIZE_MAX), $(D_INLINECODE GL_POINT_FADE_THRESHOLD_SIZE), $(D_INLINECODE GL_POINT_DISTANCE_ATTENUATION), $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY_SIZE), $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY_STRIDE), and $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY_TYPE) are available only if the GL version is 1.4 or greater. $(D_INLINECODE GL_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_COLOR_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_EDGE_FLAG_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_FOG_COORD_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_INDEX_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_NORMAL_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING), and $(D_INLINECODE GL_VERTEX_ARRAY_BUFFER_BINDING) are available only if the GL version is 1.5 or greater. $(D_INLINECODE GL_BLEND_EQUATION_ALPHA), $(D_INLINECODE GL_BLEND_EQUATION_RGB), $(D_INLINECODE GL_DRAW_BUFFER), $(D_INLINECODE GL_FRAGMENT_SHADER_DERIVATIVE_HINT), $(D_INLINECODE GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS), $(D_INLINECODE GL_MAX_DRAW_BUFFERS), $(D_INLINECODE GL_MAX_FRAGMENT_UNIFORM_COMPONENTS), $(D_INLINECODE GL_MAX_TEXTURE_COORDS), $(D_INLINECODE GL_MAX_TEXTURE_IMAGE_UNITS), $(D_INLINECODE GL_MAX_VARYING_FLOATS), $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS), $(D_INLINECODE GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS), $(D_INLINECODE GL_MAX_VERTEX_UNIFORM_COMPONENTS), $(D_INLINECODE GL_POINT_SPRITE), $(D_INLINECODE GL_STENCIL_BACK_FAIL), $(D_INLINECODE GL_STENCIL_BACK_FUNC), $(D_INLINECODE GL_STENCIL_BACK_PASS_DEPTH_FAIL), $(D_INLINECODE GL_STENCIL_BACK_PASS_DEPTH_PASS), $(D_INLINECODE GL_STENCIL_BACK_REF), $(D_INLINECODE GL_STENCIL_BACK_VALUE_MASK), $(D_INLINECODE GL_STENCIL_BACK_WRITEMASK), $(D_INLINECODE GL_VERTEX_PROGRAM_POINT_SIZE), and $(D_INLINECODE GL_VERTEX_PROGRAM_TWO_SIDE) are available only if the GL version is 2.0 or greater. $(D_INLINECODE GL_CURRENT_RASTER_SECONDARY_COLOR), $(D_INLINECODE GL_PIXEL_PACK_BUFFER_BINDING) and $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER_BINDING) are available only if the GL version is 2.1 or greater. $(D_INLINECODE GL_LINE_WIDTH_GRANULARITY) was deprecated in GL version 1.2.  Its functionality was replaced by $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_GRANULARITY). $(D_INLINECODE GL_LINE_WIDTH_RANGE) was deprecated in GL version 1.2.  Its functionality was replaced by $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_RANGE). $(D_INLINECODE GL_POINT_SIZE_GRANULARITY) was deprecated in GL version 1.2.  Its functionality was replaced by $(D_INLINECODE GL_SMOOTH_POINT_SIZE_GRANULARITY). $(D_INLINECODE GL_POINT_SIZE_RANGE) was deprecated in GL version 1.2.  Its functionality was replaced by $(D_INLINECODE GL_SMOOTH_POINT_SIZE_RANGE). $(D_INLINECODE GL_BLEND_EQUATION) was deprecated in GL version 2.0.  Its functionality was replaced by $(D_INLINECODE GL_BLEND_EQUATION_RGB) and $(D_INLINECODE GL_BLEND_EQUATION_ALPHA). $(D_INLINECODE GL_COLOR_MATRIX), $(D_INLINECODE GL_COLOR_MATRIX_STACK_DEPTH), $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_CONVOLUTION_1D), $(D_INLINECODE GL_CONVOLUTION_2D), $(D_INLINECODE GL_HISTOGRAM), $(D_INLINECODE GL_MAX_COLOR_MATRIX_STACK_DEPTH), $(D_INLINECODE GL_MINMAX), $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE), $(D_INLINECODE GL_POST_COLOR_MATRIX_RED_BIAS), $(D_INLINECODE GL_POST_COLOR_MATRIX_GREEN_BIAS), $(D_INLINECODE GL_POST_COLOR_MATRIX_BLUE_BIAS), $(D_INLINECODE GL_POST_COLOR_MATRIX_ALPHA_BIAS), $(D_INLINECODE GL_POST_COLOR_MATRIX_RED_SCALE), $(D_INLINECODE GL_POST_COLOR_MATRIX_GREEN_SCALE), $(D_INLINECODE GL_POST_COLOR_MATRIX_BLUE_SCALE), $(D_INLINECODE GL_POST_COLOR_MATRIX_ALPHA_SCALE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_RED_BIAS), $(D_INLINECODE GL_POST_CONVOLUTION_GREEN_BIAS), $(D_INLINECODE GL_POST_CONVOLUTION_BLUE_BIAS), $(D_INLINECODE GL_POST_CONVOLUTION_ALPHA_BIAS), $(D_INLINECODE GL_POST_CONVOLUTION_RED_SCALE), $(D_INLINECODE GL_POST_CONVOLUTION_GREEN_SCALE), $(D_INLINECODE GL_POST_CONVOLUTION_BLUE_SCALE), $(D_INLINECODE GL_POST_CONVOLUTION_ALPHA_SCALE), and $(D_INLINECODE GL_SEPARABLE_2D) are available only if $(D_INLINECODE ARB_imaging) is returned from $(D_INLINECODE glGet) when called with the argument $(D_INLINECODE GL_EXTENSIONS). When the $(D_INLINECODE ARB_multitexture) extension is supported, or the GL version is 1.3 or greater, the following parameters return the associated value for the active texture unit: $(D_INLINECODE GL_CURRENT_RASTER_TEXTURE_COORDS), $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_BINDING_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_BINDING_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_BINDING_3D), $(D_INLINECODE GL_TEXTURE_GEN_S), $(D_INLINECODE GL_TEXTURE_GEN_T), $(D_INLINECODE GL_TEXTURE_GEN_R), $(D_INLINECODE GL_TEXTURE_GEN_Q), $(D_INLINECODE GL_TEXTURE_MATRIX), and $(D_INLINECODE GL_TEXTURE_STACK_DEPTH). Likewise, the following parameters return the associated value for the active client texture unit: $(D_INLINECODE GL_TEXTURE_COORD_ARRAY), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_SIZE), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_STRIDE), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_TYPE).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveAttrib), $(D_INLINECODE glGetActiveUniform), $(D_INLINECODE glGetAttachedShaders), $(D_INLINECODE glGetAttribLocation), $(D_INLINECODE glGetBufferParameteriv), $(D_INLINECODE glGetBufferPointerv), $(D_INLINECODE glGetBufferSubData), $(D_INLINECODE glGetClipPlane), $(D_INLINECODE glGetColorTable), $(D_INLINECODE glGetColorTableParameter), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glGetConvolutionFilter), $(D_INLINECODE glGetConvolutionParameter), $(D_INLINECODE glGetError), $(D_INLINECODE glGetHistogram), $(D_INLINECODE glGetHistogramParameter), $(D_INLINECODE glGetLight), $(D_INLINECODE glGetMap), $(D_INLINECODE glGetMaterial), $(D_INLINECODE glGetMinmax), $(D_INLINECODE glGetMinmaxParameter), $(D_INLINECODE glGetPixelMap), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glGetPolygonStipple), $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetProgramInfoLog), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetSeparableFilter), $(D_INLINECODE glGetShader), $(D_INLINECODE glGetShaderInfoLog), $(D_INLINECODE glGetShaderSource), $(D_INLINECODE glGetString), $(D_INLINECODE glGetTexEnv), $(D_INLINECODE glGetTexGen), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glGetUniform), $(D_INLINECODE glGetUniformLocation), $(D_INLINECODE glGetVertexAttrib), $(D_INLINECODE glGetVertexAttribPointerv), $(D_INLINECODE glIsEnabled)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetBooleanv(GLenum pname, GLboolean* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetDoublev(GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetFloatv(GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetIntegerv(GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glWindowPos: man2/glWindowPos.xml
     + 
     + The GL maintains a 3D position in window coordinates.  This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy.  See $(D_INLINECODE glBitmap), $(D_INLINECODE glDrawPixels), and $(D_INLINECODE glCopyPixels). $(D_INLINECODE glWindowPos2) specifies the x and y coordinates, while z is implicitly set to 0. $(D_INLINECODE glWindowPos3) specifies all three coordinates. The w coordinate of the current raster position is always set to 1.0. $(D_INLINECODE glWindowPos) directly updates the x and y coordinates of the current raster position with the values specified.  That is, the values are neither transformed by the current modelview and projection matrices, nor by the viewport-to-window transform.  The z coordinate of the current raster position is updated in the following manner: z = n f n + z &times; f - n &it; if &it; z &lt;= 0 if &it; z &gt;= 1 otherwise where n is $(D_INLINECODE GL_DEPTH_RANGE) 's near value, and f is $(D_INLINECODE GL_DEPTH_RANGE) 's far value.  See $(D_INLINECODE glDepthRange). The specified coordinates are not clip-tested, causing the raster position to always be valid. The current raster position also includes some associated color data and texture coordinates.  If lighting is enabled, then $(D_INLINECODE GL_CURRENT_RASTER_COLOR) (in RGBA mode) or $(D_INLINECODE GL_CURRENT_RASTER_INDEX) (in color index mode) is set to the color produced by the lighting calculation (see $(D_INLINECODE glLight), $(D_INLINECODE glLightModel), and $(D_INLINECODE glShadeModel) ). If lighting is disabled, current color (in RGBA mode, state variable $(D_INLINECODE GL_CURRENT_COLOR) ) or color index (in color index mode, state variable $(D_INLINECODE GL_CURRENT_INDEX) ) is used to update the current raster color. $(D_INLINECODE GL_CURRENT_RASTER_SECONDARY_COLOR) (in RGBA mode) is likewise updated. Likewise, $(D_INLINECODE GL_CURRENT_RASTER_TEXTURE_COORDS) is updated as a function of $(D_INLINECODE GL_CURRENT_TEXTURE_COORDS), based on the texture matrix and the texture generation functions (see $(D_INLINECODE glTexGen) ).  The $(D_INLINECODE GL_CURRENT_RASTER_DISTANCE) is set to the $(D_INLINECODE GL_CURRENT_FOG_COORD).
     + 
     + $(D_INLINECODE glWindowPos) is available only if the GL version is 1.4 or greater. The raster position is modified by $(D_INLINECODE glRasterPos), $(D_INLINECODE glBitmap), and $(D_INLINECODE glWindowPos). Calling $(D_INLINECODE glDrawElements), or $(D_INLINECODE glDrawRangeElements) may leave the current color or index indeterminate. If $(D_INLINECODE glWindowPos) is executed while the current color or index is indeterminate, the current raster color or current raster index remains indeterminate. There are distinct raster texture coordinates for each texture unit. Each texture unit's current raster texture coordinates are updated by $(D_INLINECODE glWindowPos).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBitmap), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glRasterPos), $(D_INLINECODE glTexCoord), $(D_INLINECODE glTexGen), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2s(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2i(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2f(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2d(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3s(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3i(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos2dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glWindowPos3dv(const GLdouble* v) @system @nogc nothrow;

    /++
     + glGenLists: man2/glGenLists.xml
     + 
     + $(D_INLINECODE glGenLists) has one argument, $(D_INLINECODE range). It returns an integer such that $(D_INLINECODE range) contiguous empty display lists, named n, n + 1,..., n + range - 1, are created. If $(D_INLINECODE range) is 0, if there is no group of $(D_INLINECODE range) contiguous names available, or if any error is generated, no display lists are generated, and 0 is returned.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glNewList)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLuint glGenLists(GLsizei range) @system @nogc nothrow;

    /++
     + gluDeleteNurbsRenderer: man2/gluDeleteNurbsRenderer.xml
     + 
     + $(D_INLINECODE gluDeleteNurbsRenderer) destroys the NURBS object (which was created with $(D_INLINECODE gluNewNurbsRenderer) ) and frees any memory it uses. Once $(D_INLINECODE gluDeleteNurbsRenderer) has been called, $(D_INLINECODE nurb) cannot be used again.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewNurbsRenderer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluDeleteNurbsRenderer(GLUnurbs* nurb) @system @nogc nothrow;

    /++
     + glPrioritizeTextures: man2/glPrioritizeTextures.xml
     + 
     + $(D_INLINECODE glPrioritizeTextures) assigns the $(D_INLINECODE n) texture priorities given in $(D_INLINECODE priorities) to the $(D_INLINECODE n) textures named in $(D_INLINECODE textures). The GL establishes a ``working set'' of textures that are resident in texture memory. These textures may be bound to a texture target much more efficiently than textures that are not resident. By specifying a priority for each texture, $(D_INLINECODE glPrioritizeTextures) allows applications to guide the GL implementation in determining which textures should be resident. The priorities given in $(D_INLINECODE priorities) are clamped to the range 0 1 before they are assigned. 0 indicates the lowest priority; textures with priority 0 are least likely to be resident. 1 indicates the highest priority; textures with priority 1 are most likely to be resident. However, textures are not guaranteed to be resident until they are used. $(D_INLINECODE glPrioritizeTextures) silently ignores attempts to prioritize texture 0 or any texture name that does not correspond to an existing texture. $(D_INLINECODE glPrioritizeTextures) does not require that any of the textures named by $(D_INLINECODE textures) be bound to a texture target. $(D_INLINECODE glTexParameter) may also be used to set a texture's priority, but only if the texture is currently bound. This is the only way to set the priority of a default texture.
     + 
     + $(D_INLINECODE glPrioritizeTextures) is available only if the GL version is 1.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAreTexturesResident), $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glPrioritizeTextures(GLsizei n, const GLuint* textures, const GLclampf* priorities) @system @nogc nothrow;

    /++
     + glGetHistogramParameter: man2/glGetHistogramParameter.xml
     + 
     + $(D_INLINECODE glGetHistogramParameter) is used to query parameter values for the current histogram or for a proxy.  The histogram state information may be queried by calling $(D_INLINECODE glGetHistogramParameter) with a $(D_INLINECODE target) of $(D_INLINECODE GL_HISTOGRAM) (to obtain information for the current histogram table) or $(D_INLINECODE GL_PROXY_HISTOGRAM) (to obtain information from the most recent proxy request) and one of the following values for the $(D_INLINECODE pname) argument: $(B Parameter) $(B Description) $(D_INLINECODE GL_HISTOGRAM_WIDTH) Histogram table width $(D_INLINECODE GL_HISTOGRAM_FORMAT) Internal format $(D_INLINECODE GL_HISTOGRAM_RED_SIZE) Red component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_GREEN_SIZE) Green component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_BLUE_SIZE) Blue component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_ALPHA_SIZE) Alpha component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_LUMINANCE_SIZE) Luminance component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_SINK) Value of the parameter
     + 
     + $(D_INLINECODE glGetHistogramParameter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetHistogram), $(D_INLINECODE glHistogram)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glIsList: man2/glIsList.xml
     + 
     + $(D_INLINECODE glIsList) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE list) is the name of a display list and returns $(D_INLINECODE GL_FALSE) if it is not, or if an error occurs. A name returned by $(D_INLINECODE glGenLists), but not yet associated with a display list by calling $(D_INLINECODE glNewList), is not the name of a display list.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glGenLists), $(D_INLINECODE glNewList)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLboolean glIsList(GLuint list) @system @nogc nothrow;

    /++
     + glMap1: man2/glMap1.xml
     + 
     + Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent to further stages of GL processing just as if they had been presented using $(D_INLINECODE glVertex), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), and $(D_INLINECODE glColor) commands, except that the generated values do not update the current normal, texture coordinates, or color. All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators. These include almost all splines used in computer graphics: B-splines, Bezier curves, Hermite splines, and so on. Evaluators define curves based on Bernstein polynomials. Define p &af; u &Hat; as p &af; u &Hat; = &Sigma; i = 0 n B i n &af; u &Hat; &it; R i where R i is a control point and B i n &af; u &Hat; is the i th Bernstein polynomial of degree n ( $(D_INLINECODE order) = n + 1 ): B i n &af; u &Hat; = n i &it; u &Hat; i &it; 1 - u &Hat; n - i Recall that 0 0 == 1 and n 0 == 1 $(D_INLINECODE glMap1) is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with the map name, one of the nine predefined values for $(D_INLINECODE target) described below. $(D_INLINECODE glEvalCoord1) evaluates the one-dimensional maps that are enabled. When $(D_INLINECODE glEvalCoord1) presents a value u, the Bernstein functions are evaluated using u &Hat;, where u &Hat; = u - u1 u2 - u1 $(D_INLINECODE target) is a symbolic constant that indicates what kind of control points are provided in $(D_INLINECODE points), and what output is generated when the map is evaluated. It can assume one of nine predefined values: $(D_INLINECODE stride), $(D_INLINECODE order), and $(D_INLINECODE points) define the array addressing for accessing the control points. $(D_INLINECODE points) is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. $(D_INLINECODE order) is the number of control points in the array. $(D_INLINECODE stride) specifies how many float or double locations to advance the internal memory pointer to reach the next control point.
     + 
     + As is the case with all GL commands that accept pointers to data, it is as if the contents of $(D_INLINECODE points) were copied by $(D_INLINECODE glMap1) before $(D_INLINECODE glMap1) returns. Changes to the contents of $(D_INLINECODE points) have no effect after $(D_INLINECODE glMap1) is called.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glEnable), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glMap2), $(D_INLINECODE glMapGrid), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points) @system @nogc nothrow;

    /++
     + glUseProgram: man2/glUseProgram.xml
     + 
     + $(D_INLINECODE glUseProgram) installs the program object specified by $(D_INLINECODE program) as part of current rendering state. One or more executables are created in a program object by successfully attaching shader objects to it with $(D_INLINECODE glAttachShader), successfully compiling the shader objects with $(D_INLINECODE glCompileShader), and successfully linking the program object with $(D_INLINECODE glLinkProgram). A program object will contain an executable that will run on the vertex processor if it contains one or more shader objects of type $(D_INLINECODE GL_VERTEX_SHADER) that have been successfully compiled and linked. Similarly, a program object will contain an executable that will run on the fragment processor if it contains one or more shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER) that have been successfully compiled and linked. Successfully installing an executable on a programmable processor will cause the corresponding fixed functionality of OpenGL to be disabled. Specifically, if an executable is installed on the vertex processor, the OpenGL fixed functionality will be disabled as follows. $(OL $(LI The modelview matrix is not applied to vertex coordinates.) $(LI The projection matrix is not applied to vertex coordinates.) $(LI The texture matrices are not applied to texture coordinates.) $(LI Normals are not transformed to eye coordinates.) $(LI Normals are not rescaled or normalized.) $(LI Normalization of $(D_INLINECODE GL_AUTO_NORMAL) evaluated normals is not performed.) $(LI Texture coordinates are not generated automatically.) $(LI Per-vertex lighting is not performed.) $(LI Color material computations are not performed.) $(LI Color index lighting is not performed.) $(LI This list also applies when setting the current raster position.)) The executable that is installed on the vertex processor is expected to implement any or all of the desired functionality from the preceding list. Similarly, if an executable is installed on the fragment processor, the OpenGL fixed functionality will be disabled as follows. $(OL $(LI Texture environment and texture functions are not applied.) $(LI Texture application is not applied.) $(LI Color sum is not applied.) $(LI Fog is not applied.)) Again, the fragment shader that is installed is expected to implement any or all of the desired functionality from the preceding list. While a program object is in use, applications are free to modify attached shader objects, compile attached shader objects, attach additional shader objects, and detach or delete shader objects. None of these operations will affect the executables that are part of the current state. However, relinking the program object that is currently in use will install the program object as part of the current rendering state if the link operation was successful (see $(D_INLINECODE glLinkProgram) ). If the program object currently in use is relinked unsuccessfully, its link status will be set to $(D_INLINECODE GL_FALSE), but the executables and associated state will remain part of the current state until a subsequent call to $(D_INLINECODE glUseProgram) removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked. If $(D_INLINECODE program) contains shader objects of type $(D_INLINECODE GL_VERTEX_SHADER) but it does not contain shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER), an executable will be installed on the vertex processor, but fixed functionality will be used for fragment processing. Similarly, if $(D_INLINECODE program) contains shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER) but it does not contain shader objects of type $(D_INLINECODE GL_VERTEX_SHADER), an executable will be installed on the fragment processor, but fixed functionality will be used for vertex processing. If $(D_INLINECODE program) is 0, the programmable processors will be disabled, and fixed functionality will be used for both vertex and fragment processing.
     + 
     + $(D_INLINECODE glUseProgram) is available only if the GL version is 2.0 or greater. While a program object is in use, the state that controls the disabled fixed functionality may also be updated using the normal OpenGL calls. Like display lists and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well. Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE gllAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glValidateProgram), $(D_INLINECODE glVertexAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glUseProgram(GLuint program) @system @nogc nothrow;

    /++
     + gluBuild2DMipmapLevels: man2/gluBuild2DMipmapLevels.xml
     + 
     + $(D_INLINECODE gluBuild2DMipmapLevels) builds a subset of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). A series of mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max) is built by decimating $(D_INLINECODE data) in half along both dimensions until size 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding four texels in the larger mipmap level. (In the case of rectangular images, the decimation will ultimately reach an N &times; 1 or 1 &times; N configuration. Here, two texels are averaged instead.) $(D_INLINECODE glTexImage2D) is called to load these mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max). If $(D_INLINECODE max) is larger than the highest mipmap level for the texture of the specified size, then a GLU error code is returned (see $(D_INLINECODE gluErrorString) ) and nothing is loaded. For example, if $(D_INLINECODE level) is 2 and $(D_INLINECODE width) is 16 and $(D_INLINECODE height) is 8, the following levels are possible: 16 &times; 8, 8 &times; 4, 4 &times; 2, 2 &times; 1, 1 &times; 1. These correspond to levels 2 through 6 respectively.  If $(D_INLINECODE base) is 3 and $(D_INLINECODE max) is 5, then only mipmap levels 8 &times; 4, 4 &times; 2, and 2 &times; 1 are loaded. However, if $(D_INLINECODE max) is 7, then an error is returned and nothing is loaded since $(D_INLINECODE max) is larger than the highest mipmap level which is, in this case, 6. The highest mipmap level can be derived from the formula log 2 &af; max &af; width height &times; 2 level. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE format) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter.
     + 
     + $(D_INLINECODE gluBuild2DMipmapLevels) is only available if the GLU version is 1.3 or greater. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void* data) @system @nogc nothrow;

    /++
     + glTexEnv: man2/glTexEnv.xml
     + 
     + A texture environment specifies how texture values are interpreted when a fragment is textured.  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_FILTER_CONTROL), $(D_INLINECODE pname) must be $(D_INLINECODE GL_TEXTURE_LOD_BIAS).  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_ENV), $(D_INLINECODE pname) can be $(D_INLINECODE GL_TEXTURE_ENV_MODE), $(D_INLINECODE GL_TEXTURE_ENV_COLOR), $(D_INLINECODE GL_COMBINE_RGB), $(D_INLINECODE GL_COMBINE_ALPHA), $(D_INLINECODE GL_RGB_SCALE), $(D_INLINECODE GL_ALPHA_SCALE), $(D_INLINECODE GL_SRC0_RGB), $(D_INLINECODE GL_SRC1_RGB), $(D_INLINECODE GL_SRC2_RGB), $(D_INLINECODE GL_SRC0_ALPHA), $(D_INLINECODE GL_SRC1_ALPHA), or $(D_INLINECODE GL_SRC2_ALPHA). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_ENV_MODE), then $(D_INLINECODE params) is (or points to) the symbolic name of a texture function. Six texture functions may be specified: $(D_INLINECODE GL_ADD), $(D_INLINECODE GL_MODULATE), $(D_INLINECODE GL_DECAL), $(D_INLINECODE GL_BLEND), $(D_INLINECODE GL_REPLACE), or $(D_INLINECODE GL_COMBINE). The following table shows the correspondence of filtered texture values R t, G t, B t, A t, L t, I t to texture source components. C s and A s are used by the texture functions described below. Texture Base Internal Format C s A s $(D_INLINECODE GL_ALPHA) (0, 0, 0) A t $(D_INLINECODE GL_LUMINANCE) ( L t, L t, L t ) 1 $(D_INLINECODE GL_LUMINANCE_ALPHA) ( L t, L t, L t ) A t $(D_INLINECODE GL_INTENSITY) ( I t, I t, I t ) I t $(D_INLINECODE GL_RGB) ( R t, G t, B t ) 1 $(D_INLINECODE GL_RGBA) ( R t, G t, B t ) A t A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see $(D_INLINECODE glTexParameter) ) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the first five texture functions that can be chosen. C is a triple of color values (RGB) and A is the associated alpha value. RGBA values extracted from a texture image are in the range [0,1]. The subscript p refers to the color computed from the previous texture stage (or the incoming fragment if processing texture stage 0), the subscript s to the texture source color, the subscript c to the texture environment color, and the subscript v indicates a value produced by the texture function. Texture Base Internal Format $(D_INLINECODE Value) $(D_INLINECODE GL_REPLACE) Function $(D_INLINECODE GL_MODULATE) Function $(D_INLINECODE GL_DECAL) Function $(D_INLINECODE GL_BLEND) Function $(D_INLINECODE GL_ADD) Function $(D_INLINECODE GL_ALPHA) C v = C p C p undefined C p C p A v = A s A p &it; A s A v = A p &it; A s A p &it; A s $(D_INLINECODE GL_LUMINANCE) C v = C s C p &it; C s undefined C p &it; 1 - C s + C c &it; C s C p + C s (or 1) A v = A p A p A p A p $(D_INLINECODE GL_LUMINANCE_ALPHA) C v = C s C p &it; C s undefined C p &it; 1 - C s + C c &it; C s C p + C s (or 2) A v = A s A p &it; A s A p &it; A s A p &it; A s $(D_INLINECODE GL_INTENSITY) C v = C s C p &it; C s undefined C p &it; 1 - C s + C c &it; C s C p + C s A v = A s A p &it; A s A p &it; 1 - A s + A c &it; A s A p + A s $(D_INLINECODE GL_RGB) C v = C s C p &it; C s C s C p &it; 1 - C s + C c &it; C s C p + C s (or 3) A v = A p A p A p A p A p $(D_INLINECODE GL_RGBA) C v = C s C p &it; C s C p &it; 1 - A s + C s &it; A s C p &it; 1 - C s + C c &it; C s C p + C s (or 4) A v = A s A p &it; A s A p A p &it; A s A p &it; A s If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_ENV_MODE), and $(D_INLINECODE params) is $(D_INLINECODE GL_COMBINE), the form of the texture function depends on the values of $(D_INLINECODE GL_COMBINE_RGB) and $(D_INLINECODE GL_COMBINE_ALPHA). The following describes how the texture sources, as specified by $(D_INLINECODE GL_SRC0_RGB), $(D_INLINECODE GL_SRC1_RGB), $(D_INLINECODE GL_SRC2_RGB), $(D_INLINECODE GL_SRC0_ALPHA), $(D_INLINECODE GL_SRC1_ALPHA), and $(D_INLINECODE GL_SRC2_ALPHA), are combined to produce a final texture color. In the following tables, $(D_INLINECODE GL_SRC0_c) is represented by Arg0, $(D_INLINECODE GL_SRC1_c) is represented by Arg1, and $(D_INLINECODE GL_SRC2_c) is represented by Arg2. $(D_INLINECODE GL_COMBINE_RGB) accepts any of $(D_INLINECODE GL_REPLACE), $(D_INLINECODE GL_MODULATE), $(D_INLINECODE GL_ADD), $(D_INLINECODE GL_ADD_SIGNED), $(D_INLINECODE GL_INTERPOLATE), $(D_INLINECODE GL_SUBTRACT), $(D_INLINECODE GL_DOT3_RGB), or $(D_INLINECODE GL_DOT3_RGBA). $(B $(D_INLINECODE GL_COMBINE_RGB)) $(B Texture Function) $(D_INLINECODE GL_REPLACE) Arg0 $(D_INLINECODE GL_MODULATE) Arg0 &times; Arg1 $(D_INLINECODE GL_ADD) Arg0 + Arg1 $(D_INLINECODE GL_ADD_SIGNED) Arg0 + Arg1 - 0.5 $(D_INLINECODE GL_INTERPOLATE) Arg0 &times; Arg2 + Arg1 &times; 1 - Arg2 $(D_INLINECODE GL_SUBTRACT) Arg0 - Arg1 $(D_INLINECODE GL_DOT3_RGB) or $(D_INLINECODE GL_DOT3_RGBA) 4 &times; Arg0 r - 0.5 &times; Arg1 r - 0.5 + Arg0 g - 0.5 &times; Arg1 g - 0.5 + Arg0 b - 0.5 &times; Arg1 b - 0.5 The scalar results for $(D_INLINECODE GL_DOT3_RGB) and $(D_INLINECODE GL_DOT3_RGBA) are placed into each of the 3 (RGB) or 4 (RGBA) components on output. Likewise, $(D_INLINECODE GL_COMBINE_ALPHA) accepts any of $(D_INLINECODE GL_REPLACE), $(D_INLINECODE GL_MODULATE), $(D_INLINECODE GL_ADD), $(D_INLINECODE GL_ADD_SIGNED), $(D_INLINECODE GL_INTERPOLATE), or $(D_INLINECODE GL_SUBTRACT).  The following table describes how alpha values are combined: $(B $(D_INLINECODE GL_COMBINE_ALPHA)) $(B Texture Function) $(D_INLINECODE GL_REPLACE) Arg0 $(D_INLINECODE GL_MODULATE) Arg0 &times; Arg1 $(D_INLINECODE GL_ADD) Arg0 + Arg1 $(D_INLINECODE GL_ADD_SIGNED) Arg0 + Arg1 - 0.5 $(D_INLINECODE GL_INTERPOLATE) Arg0 &times; Arg2 + Arg1 &times; 1 - Arg2 $(D_INLINECODE GL_SUBTRACT) Arg0 - Arg1 In the following tables, the value C s represents the color sampled from the currently bound texture, C c represents the constant texture-environment color, C f represents the primary color of the incoming fragment, and C p represents the color computed from the previous texture stage or C f if processing texture stage 0.  Likewise, A s, A c, A f, and A p represent the respective alpha values. The following table describes the values assigned to Arg0, Arg1, and Arg2 based upon the RGB sources and operands: $(B $(D_INLINECODE GL_SRCn_RGB)) $(B $(D_INLINECODE GL_OPERANDn_RGB)) $(B Argument Value) $(D_INLINECODE GL_TEXTURE) $(D_INLINECODE GL_SRC_COLOR) C s $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C s $(D_INLINECODE GL_SRC_ALPHA) A s $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A s $(D_INLINECODE GL_TEXTUREn) $(D_INLINECODE GL_SRC_COLOR) C s $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C s $(D_INLINECODE GL_SRC_ALPHA) A s $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A s $(D_INLINECODE GL_CONSTANT) $(D_INLINECODE GL_SRC_COLOR) C c $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C c $(D_INLINECODE GL_SRC_ALPHA) A c $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A c $(D_INLINECODE GL_PRIMARY_COLOR) $(D_INLINECODE GL_SRC_COLOR) C f $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C f $(D_INLINECODE GL_SRC_ALPHA) A f $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A f $(D_INLINECODE GL_PREVIOUS) $(D_INLINECODE GL_SRC_COLOR) C p $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C p $(D_INLINECODE GL_SRC_ALPHA) A p $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A p For $(D_INLINECODE GL_TEXTUREn) sources, C s and A s represent the color and alpha, respectively, produced from texture stage n. The follow table describes the values assigned to Arg0, Arg1, and Arg2 based upon the alpha sources and operands: $(B $(D_INLINECODE GL_SRCn_ALPHA)) $(B $(D_INLINECODE GL_OPERANDn_ALPHA)) $(B Argument Value) $(D_INLINECODE GL_TEXTURE) $(D_INLINECODE GL_SRC_ALPHA) A s $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A s $(D_INLINECODE GL_TEXTUREn) $(D_INLINECODE GL_SRC_ALPHA) A s $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A s $(D_INLINECODE GL_CONSTANT) $(D_INLINECODE GL_SRC_ALPHA) A c $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A c $(D_INLINECODE GL_PRIMARY_COLOR) $(D_INLINECODE GL_SRC_ALPHA) A f $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A f $(D_INLINECODE GL_PREVIOUS) $(D_INLINECODE GL_SRC_ALPHA) A p $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A p The RGB and alpha results of the texture function are multipled by the values of $(D_INLINECODE GL_RGB_SCALE) and $(D_INLINECODE GL_ALPHA_SCALE), respectively, and clamped to the range 0 1. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_ENV_COLOR), $(D_INLINECODE params) is a pointer to an array that holds an RGBA color consisting of four values. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1] when they are specified. C c takes these four values. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_LOD_BIAS), the value specified is added to the texture level-of-detail parameter, that selects which mipmap, or mipmaps depending upon the selected $(D_INLINECODE GL_TEXTURE_MIN_FILTER), will be sampled. $(D_INLINECODE GL_TEXTURE_ENV_MODE) defaults to $(D_INLINECODE GL_MODULATE) and $(D_INLINECODE GL_TEXTURE_ENV_COLOR) defaults to (0, 0, 0, 0). If $(D_INLINECODE target) is $(D_INLINECODE GL_POINT_SPRITE) and $(D_INLINECODE pname) is $(D_INLINECODE GL_COORD_REPLACE), the boolean value specified is used to either enable or disable point sprite texture coordinate replacement. The default value is $(D_INLINECODE GL_FALSE).
     + 
     + $(D_INLINECODE GL_REPLACE) may only be used if the GL version is 1.1 or greater. $(D_INLINECODE GL_TEXTURE_FILTER_CONTROL) and $(D_INLINECODE GL_TEXTURE_LOD_BIAS) may only be used if the GL version is 1.4 or greater. $(D_INLINECODE GL_COMBINE) mode and its associated constants may only be used if the GL version is 1.3 or greater. $(D_INLINECODE GL_TEXTUREn) may only be used if the GL version is 1.4 or greater. Internal formats other than 1, 2, 3, or 4 may only be used if the GL version is 1.1 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexEnv) controls the texture environment for the current active texture unit, selected by $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_POINT_SPRITE) and $(D_INLINECODE GL_COORD_REPLACE) are available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexEnvf(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexEnvi(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexEnvfv(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexEnviv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;

    /++
     + glDepthMask: man2/glDepthMask.xml
     + 
     + $(D_INLINECODE glDepthMask) specifies whether the depth buffer is enabled for writing. If $(D_INLINECODE flag) is $(D_INLINECODE GL_FALSE), depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glIndexMask), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDepthMask(GLboolean flag) @system @nogc nothrow;

    /++
     + glRotate: man2/glRotate.xml
     + 
     + $(D_INLINECODE glRotate) produces a rotation of $(D_INLINECODE angle) degrees around the vector x y z. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by a rotation matrix with the product replacing the current matrix, as if $(D_INLINECODE glMultMatrix) were called with the following matrix as its argument: x 2 &af; 1 - c + c x &it; y &af; 1 - c - z &it; s x &it; z &af; 1 - c + y &it; s 0 y &it; x &af; 1 - c + z &it; s y 2 &af; 1 - c + c y &it; z &af; 1 - c - x &it; s 0 x &it; z &af; 1 - c - y &it; s y &it; z &af; 1 - c + x &it; s z 2 &af; 1 - c + c 0 0 0 0 1 Where c = cos &af; angle, s = sin &af; angle, and x y z = 1 (if not, the GL will normalize this vector). If the matrix mode is either $(D_INLINECODE GL_MODELVIEW) or $(D_INLINECODE GL_PROJECTION), all objects drawn after $(D_INLINECODE glRotate) is called are rotated. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the unrotated coordinate system.
     + 
     + This rotation follows the right-hand rule, so if the vector x y z points toward the user, the rotation will be counterclockwise.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glScale), $(D_INLINECODE glTranslate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;

    /++
     + glFinish: man2/glFinish.xml
     + 
     + $(D_INLINECODE glFinish) does not return until the effects of all previously called GL commands are complete. Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.
     + 
     + $(D_INLINECODE glFinish) requires a round trip to the server.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFlush)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFinish() @system @nogc nothrow;

    /++
     + glGetShaderInfoLog: man2/glGetShaderInfoLog.xml
     + 
     + $(D_INLINECODE glGetShaderInfoLog) returns the information log for the specified shader object. The information log for a shader object is modified when the shader is compiled. The string that is returned will be null terminated. $(D_INLINECODE glGetShaderInfoLog) returns in $(D_INLINECODE infoLog) as much of the information log as it can, up to a maximum of $(D_INLINECODE maxLength) characters. The number of characters actually returned, excluding the null termination character, is specified by $(D_INLINECODE length). If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The size of the buffer required to store the returned information log can be obtained by calling $(D_INLINECODE glGetShader) with the value $(D_INLINECODE GL_INFO_LOG_LENGTH). The information log for a shader object is a string that may contain diagnostic messages, warning messages, and other information about the last compile operation. When a shader object is created, its information log will be a string of length 0.
     + 
     + $(D_INLINECODE glGetShaderInfoLog) is available only if the GL version is 2.0 or greater. The information log for a shader object is the OpenGL implementer's primary mechanism for conveying information about the compilation process. Therefore, the information log can be helpful to application developers during the development process, even when compilation is successful. Application developers should not expect different OpenGL implementations to produce identical information logs.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glGetProgramInfoLog), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;

    /++
     + glConvolutionParameter: man2/glConvolutionParameter.xml
     + 
     + $(D_INLINECODE glConvolutionParameter) sets the value of a convolution parameter. $(D_INLINECODE target) selects the convolution filter to be affected: $(D_INLINECODE GL_CONVOLUTION_1D), $(D_INLINECODE GL_CONVOLUTION_2D), or $(D_INLINECODE GL_SEPARABLE_2D) for the 1D, 2D, or separable 2D filter, respectively. $(D_INLINECODE pname) selects the parameter to be changed. $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) affect the definition of the convolution filter kernel; see $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), and $(D_INLINECODE glSeparableFilter2D) for details. In these cases, $(D_INLINECODE params) v is an array of four values to be applied to red, green, blue, and alpha values, respectively. The initial value for $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) is (1, 1, 1, 1), and the initial value for $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) is (0, 0, 0, 0). A $(D_INLINECODE pname) value of $(D_INLINECODE GL_CONVOLUTION_BORDER_MODE) controls the convolution border mode. The accepted modes are:
     + 
     + $(D_INLINECODE glConvolutionParameter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS). In cases where errors can result from the specification of invalid image dimensions, it is the dimensions after convolution that are tested, not the dimensions of the source image. For example, $(D_INLINECODE glTexImage1D) requires power-of-two image size. When $(D_INLINECODE GL_REDUCE) border mode is in effect, the source image must be larger than the final power-of-two size by one less than the size of the 1D filter kernel.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glGetConvolutionParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionParameteri(GLenum target, GLenum pname, GLint params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;

    /++
     + gluQuadricNormals: man2/gluQuadricNormals.xml
     + 
     + $(D_INLINECODE gluQuadricNormals) specifies what kind of normals are desired for quadrics rendered with $(D_INLINECODE quad). The legal values are as follows:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricDrawStyle), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluQuadricNormals(GLUquadric* quad, GLenum normal) @system @nogc nothrow;

    /++
     + glPixelZoom: man2/glPixelZoom.xml
     + 
     + $(D_INLINECODE glPixelZoom) specifies values for the x and y zoom factors. During the execution of $(D_INLINECODE glDrawPixels) or $(D_INLINECODE glCopyPixels), if ( xr, yr ) is the current raster position, and a given element is in the m th row and n th column of the pixel rectangle, then pixels whose centers are in the rectangle with corners at ( xr + n &CenterDot; xfactor, yr + m &CenterDot; yfactor ) ( xr + n + 1 &CenterDot; xfactor, yr + m + 1 &CenterDot; yfactor ) are candidates for replacement. Any pixel whose center lies on the bottom or left edge of this rectangular region is also modified. Pixel zoom factors are not limited to positive values. Negative zoom factors reflect the resulting image about the current raster position.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDrawPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelZoom(GLfloat xfactor, GLfloat yfactor) @system @nogc nothrow;

    /++
     + glGetAttribLocation: man2/glGetAttribLocation.xml
     + 
     + $(D_INLINECODE glGetAttribLocation) queries the previously linked program object specified by $(D_INLINECODE program) for the attribute variable specified by $(D_INLINECODE name) and returns the index of the generic vertex attribute that is bound to that attribute variable. If $(D_INLINECODE name) is a matrix attribute variable, the index of the first column of the matrix is returned. If the named attribute variable is not an active attribute in the specified program object or if $(D_INLINECODE name) starts with the reserved prefix &quot;gl_&quot;, a value of -1 is returned. The association between an attribute variable name and a generic attribute index can be specified at any time by calling $(D_INLINECODE glBindAttribLocation). Attribute bindings do not go into effect until $(D_INLINECODE glLinkProgram) is called. After a program object has been linked successfully, the index values for attribute variables remain fixed until the next link command occurs. The attribute values can only be queried after a link if the link was successful. $(D_INLINECODE glGetAttribLocation) returns the binding that actually went into effect the last time $(D_INLINECODE glLinkProgram) was called for the specified program object. Attribute bindings that have been specified since the last link operation are not returned by $(D_INLINECODE glGetAttribLocation).
     + 
     + $(D_INLINECODE glGetAttribLocation) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLint glGetAttribLocation(GLuint program, const GLchar* name) @system @nogc nothrow;

    /++
     + glGetClipPlane: man2/glGetClipPlane.xml
     + 
     + $(D_INLINECODE glGetClipPlane) returns in $(D_INLINECODE equation) the four coefficients of the plane equation for $(D_INLINECODE plane).
     + 
     + It is always the case that $(D_INLINECODE GL_CLIP_PLANE) i = $(D_INLINECODE GL_CLIP_PLANE0) + i. If an error is generated, no change is made to the contents of $(D_INLINECODE equation).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClipPlane)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetClipPlane(GLenum plane, GLdouble* equation) @system @nogc nothrow;

    /++
     + glSeparableFilter2D: man2/glSeparableFilter2D.xml
     + 
     + $(D_INLINECODE glSeparableFilter2D) builds a two-dimensional separable convolution filter kernel from two arrays of pixels. The pixel arrays specified by ( $(D_INLINECODE width), $(D_INLINECODE format), $(D_INLINECODE type), $(D_INLINECODE row) ) and ( $(D_INLINECODE height), $(D_INLINECODE format), $(D_INLINECODE type), $(D_INLINECODE column) ) are processed just as if they had been passed to $(D_INLINECODE glDrawPixels), but processing stops after the final expansion to RGBA is completed. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a convolution filter is specified, $(D_INLINECODE row) and $(D_INLINECODE column) are treated as byte offsets into the buffer object's data store. Next, the R, G, B, and A components of all pixels in both arrays are scaled by the four separable 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four separable 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_SEPARABLE_2D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. They form two one-dimensional filter kernel images. The row image is indexed by coordinate starting at zero and increasing from left to right. Each location in the row image is derived from element of $(D_INLINECODE row). The column image is indexed by coordinate starting at zero and increasing from bottom to top. Each location in the column image is derived from element of $(D_INLINECODE column). Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glSeparableFilter2D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* row, const GLvoid* column) @system @nogc nothrow;

    /++
     + glFrustum: man2/glFrustum.xml
     + 
     + $(D_INLINECODE glFrustum) describes a perspective matrix that produces a perspective projection. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by this matrix and the result replaces the current matrix, as if $(D_INLINECODE glMultMatrix) were called with the following matrix as its argument: 2 &it; nearVal right - left 0 A 0 0 2 &it; nearVal top - bottom B 0 0 0 C D 0 0 -1 0 A = right + left right - left B = top + bottom top - bottom C = - farVal + nearVal farVal - nearVal D = - 2 &it; farVal &it; nearVal farVal - nearVal Typically, the matrix mode is $(D_INLINECODE GL_PROJECTION), and left bottom - nearVal and right top - nearVal specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, assuming that the eye is located at (0, 0, 0). - farVal specifies the location of the far clipping plane. Both $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) must be positive. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the current matrix stack.
     + 
     + Depth buffer precision is affected by the values specified for $(D_INLINECODE nearVal) and $(D_INLINECODE farVal). The greater the ratio of $(D_INLINECODE farVal) to $(D_INLINECODE nearVal) is, the less effective the depth buffer will be at distinguishing between surfaces that are near each other. If r = farVal nearVal roughly log 2 &af; r bits of depth buffer precision are lost. Because r approaches infinity as $(D_INLINECODE nearVal) approaches 0, $(D_INLINECODE nearVal) must never be set to 0.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glOrtho), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal) @system @nogc nothrow;

    /++
     + glNewList: man2/glNewList.xml
     + 
     + Display lists are groups of GL commands that have been stored for subsequent execution. Display lists are created with $(D_INLINECODE glNewList). All subsequent commands are placed in the display list, in the order issued, until $(D_INLINECODE glEndList) is called. $(D_INLINECODE glNewList) has two arguments. The first argument, $(D_INLINECODE list), is a positive integer that becomes the unique name for the display list. Names can be created and reserved with $(D_INLINECODE glGenLists) and tested for uniqueness with $(D_INLINECODE glIsList). The second argument, $(D_INLINECODE mode), is a symbolic constant that can assume one of two values: Certain commands are not compiled into the display list but are executed immediately, regardless of the display-list mode. These commands are $(D_INLINECODE glAreTexturesResident), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glFinish), $(D_INLINECODE glFlush), $(D_INLINECODE glGenLists), $(D_INLINECODE glGenTextures), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glIsList), $(D_INLINECODE glIsTexture), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glReadPixels), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer), and all of the $(D_INLINECODE glGet) commands. Similarly, $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), and $(D_INLINECODE glTexImage3D) are executed immediately and not compiled into the display list when their first argument is $(D_INLINECODE GL_PROXY_TEXTURE_1D), $(D_INLINECODE GL_PROXY_TEXTURE_1D), or $(D_INLINECODE GL_PROXY_TEXTURE_3D), respectively. When the $(D_INLINECODE ARB_imaging) extension is supported, $(D_INLINECODE glHistogram) executes immediately when its argument is $(D_INLINECODE GL_PROXY_HISTOGRAM).  Similarly, $(D_INLINECODE glColorTable) executes immediately when its first argument is $(D_INLINECODE GL_PROXY_COLOR_TABLE), $(D_INLINECODE GL_PROXY_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE). For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glClientActiveTexture) is not compiled into display lists, but executed immediately. When $(D_INLINECODE glEndList) is encountered, the display-list definition is completed by associating the list with the unique name $(D_INLINECODE list) (specified in the $(D_INLINECODE glNewList) command). If a display list with name $(D_INLINECODE list) already exists, it is replaced only when $(D_INLINECODE glEndList) is called.
     + 
     + $(D_INLINECODE glCallList) and $(D_INLINECODE glCallLists) can be entered into display lists. Commands in the display list or lists executed by $(D_INLINECODE glCallList) or $(D_INLINECODE glCallLists) are not included in the display list being created, even if the list creation mode is $(D_INLINECODE GL_COMPILE_AND_EXECUTE). A display list is just a group of commands and arguments, so errors generated by commands in a display list must be generated when the list is executed. If the list is created in $(D_INLINECODE GL_COMPILE) mode, errors are not generated until the list is executed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glGenLists)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNewList(GLuint list, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEndList() @system @nogc nothrow;

    /++
     + glClearAccum: man2/glClearAccum.xml
     + 
     + $(D_INLINECODE glClearAccum) specifies the red, green, blue, and alpha values used by $(D_INLINECODE glClear) to clear the accumulation buffer. Values specified by $(D_INLINECODE glClearAccum) are clamped to the range -1 1.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAccum), $(D_INLINECODE glClear)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;

    /++
     + glLineWidth: man2/glLineWidth.xml
     + 
     + $(D_INLINECODE glLineWidth) specifies the rasterized width of both aliased and antialiased lines. Using a line width other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and disable line antialiasing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_LINE_SMOOTH). Line antialiasing is initially disabled. If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer. (If the rounding results in the value 0, it is as if the line width were 1.) If &Delta; x &gt;= &Delta; y, pixels are filled in each column that is rasterized, where is the rounded value of $(D_INLINECODE width). Otherwise, pixels are filled in each row that is rasterized. If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization step. Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported width is used. Only width 1 is guaranteed to be supported; others depend on the implementation.  Likewise, there is a range for aliased line widths as well. To query the range of supported widths and the size difference between supported widths within the range, call $(D_INLINECODE glGet) with arguments $(D_INLINECODE GL_ALIASED_LINE_WIDTH_RANGE), $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_RANGE), and $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_GRANULARITY).
     + 
     + The line width specified by $(D_INLINECODE glLineWidth) is always returned when $(D_INLINECODE GL_LINE_WIDTH) is queried. Clamping and rounding for aliased and antialiased lines have no effect on the specified value. Nonantialiased line width may be clamped to an implementation-dependent maximum.  Call $(D_INLINECODE glGet) with $(D_INLINECODE GL_ALIASED_LINE_WIDTH_RANGE) to determine the maximum width. In OpenGL 1.2, the tokens $(D_INLINECODE GL_LINE_WIDTH_RANGE) and $(D_INLINECODE GL_LINE_WIDTH_GRANULARITY) were replaced by $(D_INLINECODE GL_ALIASED_LINE_WIDTH_RANGE), $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_RANGE), and $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_GRANULARITY).  The old names are retained for backward compatibility, but should not be used in new code.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLineWidth(GLfloat width) @system @nogc nothrow;

    /++
     + glNormalPointer: man2/glNormalPointer.xml
     + 
     + $(D_INLINECODE glNormalPointer) specifies the location and data format of an array of normals to use when rendering. $(D_INLINECODE type) specifies the data type of each normal coordinate, and $(D_INLINECODE stride) specifies the byte stride from one normal to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see $(D_INLINECODE glInterleavedArrays).) If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a normal array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as normal vertex array client-side state ( $(D_INLINECODE GL_NORMAL_ARRAY_BUFFER_BINDING) ). When a normal array is specified, $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the normal array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_NORMAL_ARRAY). If enabled, the normal array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glNormalPointer) is available only if the GL version is 1.1 or greater. The normal array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glNormalPointer) is not allowed between $(D_INLINECODE glBegin) and the corresponding $(D_INLINECODE glEnd), but an error may or may not be generated. If an error is not generated, the operation is undefined. $(D_INLINECODE glNormalPointer) is typically implemented on the client side. Normal array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormal), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glNormalPointer(GLenum type, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + glClearIndex: man2/glClearIndex.xml
     + 
     + $(D_INLINECODE glClearIndex) specifies the index used by $(D_INLINECODE glClear) to clear the color index buffers. $(D_INLINECODE c) is not clamped. Rather, $(D_INLINECODE c) is converted to a fixed-point value with unspecified precision to the right of the binary point. The integer part of this value is then masked with 2 m - 1, where m is the number of bits in a color index stored in the frame buffer.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearIndex(GLfloat c) @system @nogc nothrow;

    /++
     + glBindBuffer: man2/glBindBuffer.xml
     + 
     + $(D_INLINECODE glBindBuffer) lets you create or use a named buffer object. Calling $(D_INLINECODE glBindBuffer) with $(D_INLINECODE target) set to $(D_INLINECODE GL_ARRAY_BUFFER), $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER), $(D_INLINECODE GL_PIXEL_PACK_BUFFER) or $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) and $(D_INLINECODE buffer) set to the name of the new buffer object binds the buffer object name to the target. When a buffer object is bound to a target, the previous binding for that target is automatically broken. Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, $(D_INLINECODE buffer) set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target. Buffer object names and the corresponding buffer object contents are local to the shared display-list space (see $(D_INLINECODE glXCreateContext) ) of the current GL rendering context; two rendering contexts share buffer object names only if they also share display lists. You may use $(D_INLINECODE glGenBuffers) to generate a set of new buffer object names. The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with $(D_INLINECODE GL_READ_WRITE) access and $(D_INLINECODE GL_STATIC_DRAW) usage. While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an $(D_INLINECODE GL_INVALID_OPERATION) error. When vertex array pointer state is changed, for example by a call to $(D_INLINECODE glNormalPointer), the current buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is copied into the corresponding client state for the vertex array type being changed, for example $(D_INLINECODE GL_NORMAL_ARRAY_BUFFER_BINDING). While a non-zero buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target, the vertex array pointer parameter that is traditionally interpreted as a pointer to client-side memory is instead interpreted as an offset within the buffer object measured in basic machine units. While a non-zero buffer object is bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) target, the indices parameter of $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glMultiDrawElements) that is traditionally interpreted as a pointer to client-side memory is instead interpreted as an offset within the buffer object measured in basic machine units. While a non-zero buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target, the following commands are affected: $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glGetConvolutionFilter), $(D_INLINECODE glGetHistogram), $(D_INLINECODE glGetMinmax), $(D_INLINECODE glGetPixelMap), $(D_INLINECODE glGetPolygonStipple), $(D_INLINECODE glGetSeparableFilter), $(D_INLINECODE glGetTexImage), and $(D_INLINECODE glReadPixels). The pointer parameter that is traditionally interpreted as a pointer to client-side memory where the pixels are to be packed is instead interpreted as an offset within the buffer object measured in basic machine units. While a non-zero buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target, the following commands are affected: $(D_INLINECODE glBitmap), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glColorTable), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPolygonStipple), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D). The pointer parameter that is traditionally interpreted as a pointer to client-side memory from which the pixels are to be unpacked is instead interpreted as an offset within the buffer object measured in basic machine units. A buffer object binding created with $(D_INLINECODE glBindBuffer) remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with $(D_INLINECODE glDeleteBuffers). Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.
     + 
     + $(D_INLINECODE glBindBuffer) is available only if the GL version is 1.5 or greater. $(D_INLINECODE GL_PIXEL_PACK_BUFFER) and $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) are available only if the GL version is 2.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGenBuffers), $(D_INLINECODE glGet), $(D_INLINECODE glIsBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glBindBuffer(GLenum target, GLuint buffer) @system @nogc nothrow;

    /++
     + glGetTexParameter: man2/glGetTexParameter.xml
     + 
     + $(D_INLINECODE glGetTexParameter) returns in $(D_INLINECODE params) the value or values of the texture parameter specified as $(D_INLINECODE pname). $(D_INLINECODE target) defines the target texture, either $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP), to specify one-, two-, or three-dimensional or cube-mapped texturing. $(D_INLINECODE pname) accepts the same symbols as $(D_INLINECODE glTexParameter), with the same interpretations:
     + 
     + $(D_INLINECODE GL_TEXTURE_PRIORITY) and $(D_INLINECODE GL_TEXTURE_RESIDENT) are available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_TEXTURE_BASE_LEVEL), $(D_INLINECODE GL_TEXTURE_MAX_LEVEL), and $(D_INLINECODE GL_TEXTURE_WRAP_R) are available only if the GL version is 1.2 or greater. $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC), and $(D_INLINECODE GL_GENERATE_MIPMAP) is available only if the GL version is 1.4 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAreTexturesResident), $(D_INLINECODE glPrioritizeTextures), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetString: man2/glGetString.xml
     + 
     + $(D_INLINECODE glGetString) returns a pointer to a static string describing some aspect of the current GL connection. $(D_INLINECODE name) can be one of the following: Because the GL does not include queries for the performance characteristics of an implementation, some applications are written to recognize known platforms and modify their GL usage based on known performance characteristics of these platforms. Strings $(D_INLINECODE GL_VENDOR) and $(D_INLINECODE GL_RENDERER) together uniquely specify a platform. They do not change from release to release and should be used by platform-recognition algorithms. Some applications want to make use of features that are not part of the standard GL. These features may be implemented as extensions to the standard GL. The $(D_INLINECODE GL_EXTENSIONS) string is a space-separated list of supported GL extensions. (Extension names never contain a space character.) The $(D_INLINECODE GL_VERSION) and $(D_INLINECODE GL_SHADING_LANGUAGE_VERSION) strings begin with a version number. The version number uses one of these forms: Vendor-specific information may follow the version number. Its format depends on the implementation, but a space always separates the version number and the vendor-specific information. All strings are null-terminated.
     + 
     + If an error is generated, $(D_INLINECODE glGetString) returns 0. The client and server may support different versions or extensions. $(D_INLINECODE glGetString) always returns a compatible version number or list of extensions. The release number always describes the server. $(D_INLINECODE GL_SHADING_LANGUAGE_VERSION) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    const(GLubyte)* glGetString(GLenum name) @system @nogc nothrow;

    /++
     + gluPwlCurve: man2/gluPwlCurve.xml
     + 
     + $(D_INLINECODE gluPwlCurve) describes a piecewise linear trimming curve for a NURBS surface. A piecewise linear curve consists of a list of coordinates of points in the parameter space for the NURBS surface to be trimmed. These points are connected with line segments to form a curve. If the curve is an approximation to a curve that is not piecewise linear, the points should be close enough in parameter space that the resulting path appears curved at the resolution used in the application. If $(D_INLINECODE type) is $(D_INLINECODE GLU_MAP1_TRIM_2), then it describes a curve in two-dimensional ( and ) parameter space. If it is $(D_INLINECODE GLU_MAP1_TRIM_3), then it describes a curve in two-dimensional homogeneous (,, and ) parameter space. See the $(D_INLINECODE gluBeginTrim) reference page for more information about trimming curves.
     + 
     + To describe a trim curve that closely follows the contours of a NURBS surface, call $(D_INLINECODE gluNurbsCurve).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginCurve), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCurve)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluPwlCurve(GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type) @system @nogc nothrow;

    /++
     + glCopyTexSubImage2D: man2/glCopyTexSubImage2D.xml
     + 
     + $(D_INLINECODE glCopyTexSubImage2D) replaces a rectangular portion of a two-dimensional texture image or cube-map texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glTexSubImage2D) ). The screen-aligned pixel rectangle with lower left corner at x y and with width $(D_INLINECODE width) and height $(D_INLINECODE height) replaces the portion of the texture array with x indices $(D_INLINECODE xoffset) through xoffset + width - 1, inclusive, and y indices $(D_INLINECODE yoffset) through yoffset + height - 1, inclusive, at the mipmap level specified by $(D_INLINECODE level). The pixels in the rectangle are processed exactly as if $(D_INLINECODE glCopyPixels) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect. If any of the pixels within the specified rectangle of the current $(D_INLINECODE GL_READ_BUFFER) are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the,,, or parameters of the specified texture array or to texel values outside the specified subregion.
     + 
     + $(D_INLINECODE glCopyTexSubImage2D) is available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP) are available only if the GL version is 1.3 or greater. Texturing has no effect in color index mode. $(D_INLINECODE glPixelStore) and $(D_INLINECODE glPixelTransfer) modes affect texture images in exactly the way they affect $(D_INLINECODE glDrawPixels). When the $(D_INLINECODE ARB_imaging) extension is supported, the RGBA components read from the framebuffer may be processed by the imaging pipeline.  See $(D_INLINECODE glTexImage1D) for specific details.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + gluProject: man2/gluProject.xml
     + 
     + $(D_INLINECODE gluProject) transforms the specified object coordinates into window coordinates using $(D_INLINECODE model), $(D_INLINECODE proj), and $(D_INLINECODE view). The result is stored in $(D_INLINECODE winX), $(D_INLINECODE winY), and $(D_INLINECODE winZ). A return value of $(D_INLINECODE GLU_TRUE) indicates success, a return value of $(D_INLINECODE GLU_FALSE) indicates failure. To compute the coordinates, let v = objX objY objZ 1.0 represented as a matrix with 4 rows and 1 column. Then $(D_INLINECODE gluProject) computes v &Prime; as follows: v &Prime; = P &times; M &times; v where P is the current projection matrix $(D_INLINECODE proj) and M is the current modelview matrix $(D_INLINECODE model) (both represented as 4 &times; 4 matrices in column-major order). The window coordinates are then computed as follows: winX = view &af; 0 + view &af; 2 &times; v &Prime; &af; 0 + 1 2 winY = view &af; 1 + view &af; 3 &times; v &Prime; &af; 1 + 1 2 winZ = v &Prime; &af; 2 + 1 2
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluUnProject), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble* model, const GLdouble* proj, const GLint* view, GLdouble* winX, GLdouble* winY, GLdouble* winZ) @system @nogc nothrow;

    /++
     + glColorTableParameter: man2/glColorTableParameter.xml
     + 
     + $(D_INLINECODE glColorTableParameter) is used to specify the scale factors and bias terms applied to color components when they are loaded into a color table. $(D_INLINECODE target) indicates which color table the scale and bias terms apply to; it must be set to $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE). $(D_INLINECODE pname) must be $(D_INLINECODE GL_COLOR_TABLE_SCALE) to set the scale factors. In this case, $(D_INLINECODE params) points to an array of four values, which are the scale factors for red, green, blue, and alpha, in that order. $(D_INLINECODE pname) must be $(D_INLINECODE GL_COLOR_TABLE_BIAS) to set the bias terms. In this case, $(D_INLINECODE params) points to an array of four values, which are the bias terms for red, green, blue, and alpha, in that order. The color tables themselves are specified by calling $(D_INLINECODE glColorTable).
     + 
     + $(D_INLINECODE glColorTableParameter) is available only if $(D_INLINECODE ARB_imaging) is returned from calling $(D_INLINECODE glGetString) with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glColorTableParameteriv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;

    /++
     + glBitmap: man2/glBitmap.xml
     + 
     + A bitmap is a binary image. When drawn, the bitmap is positioned relative to the current raster position, and frame buffer pixels corresponding to 1's in the bitmap are written using the current raster color or index. Frame buffer pixels corresponding to 0's in the bitmap are not modified. $(D_INLINECODE glBitmap) takes seven arguments. The first pair specifies the width and height of the bitmap image. The second pair specifies the location of the bitmap origin relative to the lower left corner of the bitmap image. The third pair of arguments specifies and offsets to be added to the current raster position after the bitmap has been drawn. The final argument is a pointer to the bitmap image itself. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a bitmap image is specified, $(D_INLINECODE bitmap) is treated as a byte offset into the buffer object's data store. The bitmap image is interpreted like image data for the $(D_INLINECODE glDrawPixels) command, with $(D_INLINECODE width) and $(D_INLINECODE height) corresponding to the width and height arguments of that command, and with set to $(D_INLINECODE GL_BITMAP) and set to $(D_INLINECODE GL_COLOR_INDEX). Modes specified using $(D_INLINECODE glPixelStore) affect the interpretation of bitmap image data; modes specified using $(D_INLINECODE glPixelTransfer) do not. If the current raster position is invalid, $(D_INLINECODE glBitmap) is ignored. Otherwise, the lower left corner of the bitmap image is positioned at the window coordinates x w = x r - x o y w = y r - y o where x r y r is the raster position and x o y o is the bitmap origin. Fragments are then generated for each pixel corresponding to a 1 (one) in the bitmap image. These fragments are generated using the current raster coordinate, color or color index, and current raster texture coordinates. They are then treated just as if they had been generated by a point, line, or polygon, including texture mapping, fogging, and all per-fragment operations such as alpha and depth testing. After the bitmap has been drawn, the and coordinates of the current raster position are offset by $(D_INLINECODE xmove) and $(D_INLINECODE ymove). No change is made to the coordinate of the current raster position, or to the current raster color, texture coordinates, or index.
     + 
     + To set a valid raster position outside the viewport, first set a valid raster position inside the viewport, then call $(D_INLINECODE glBitmap) with null
     +  as the
     +  $(D_INLINECODE bitmap) parameter and with $(D_INLINECODE xmove) and $(D_INLINECODE ymove) set to the offsets of the new raster position. This technique is useful when panning an image around the viewport.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glRasterPos), $(D_INLINECODE glWindowPos)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const(GLubyte)* bitmap) @system @nogc nothrow;

    /++
     + glVertexAttribPointer: man2/glVertexAttribPointer.xml
     + 
     + $(D_INLINECODE glVertexAttribPointer) specifies the location and data format of the array of generic vertex attributes at index $(D_INLINECODE index) to use when rendering. $(D_INLINECODE size) specifies the number of components per attribute and must be 1, 2, 3, or 4. $(D_INLINECODE type) specifies the data type of each component, and $(D_INLINECODE stride) specifies the byte stride from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. If set to $(D_INLINECODE GL_TRUE), $(D_INLINECODE normalized) indicates that values stored in an integer format are to be mapped to the range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are accessed and converted to floating point. Otherwise, values will be converted to floats directly without normalization. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a generic vertex attribute array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as generic vertex attribute array client-side state ( $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING) ) for index $(D_INLINECODE index). When a generic vertex attribute array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE normalized), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable a generic vertex attribute array, call $(D_INLINECODE glEnableVertexAttribArray) and $(D_INLINECODE glDisableVertexAttribArray) with $(D_INLINECODE index). If enabled, the generic vertex attribute array is used when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glDrawRangeElements) is called.
     + 
     + $(D_INLINECODE glVertexAttribPointer) is available only if the GL version is 2.0 or greater. Each generic vertex attribute array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glVertexAttribPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glVertexAttribPointer) is typically implemented on the client side. Generic vertex attribute array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableVertexAttribArray), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + glGetShaderSource: man2/glGetShaderSource.xml
     + 
     + $(D_INLINECODE glGetShaderSource) returns the concatenation of the source code strings from the shader object specified by $(D_INLINECODE shader). The source code strings for a shader object are the result of a previous call to $(D_INLINECODE glShaderSource). The string returned by the function will be null terminated. $(D_INLINECODE glGetShaderSource) returns in $(D_INLINECODE source) as much of the source code string as it can, up to a maximum of $(D_INLINECODE bufSize) characters. The number of characters actually returned, excluding the null termination character, is specified by $(D_INLINECODE length). If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The size of the buffer required to store the returned source code string can be obtained by calling $(D_INLINECODE glGetShader) with the value $(D_INLINECODE GL_SHADER_SOURCE_LENGTH).
     + 
     + $(D_INLINECODE glGetShaderSource) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source) @system @nogc nothrow;

    /++
     + glLoadName: man2/glLoadName.xml
     + 
     + The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers and is initially empty. $(D_INLINECODE glLoadName) causes $(D_INLINECODE name) to replace the value on the top of the name stack. The name stack is always empty while the render mode is not $(D_INLINECODE GL_SELECT). Calls to $(D_INLINECODE glLoadName) while the render mode is not $(D_INLINECODE GL_SELECT) are ignored.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInitNames), $(D_INLINECODE glPushName), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLoadName(GLuint name) @system @nogc nothrow;

    /++
     + glGetSeparableFilter: man2/glGetSeparableFilter.xml
     + 
     + $(D_INLINECODE glGetSeparableFilter) returns the two one-dimensional filter kernel images for the current separable 2D convolution filter. The row image is placed in $(D_INLINECODE row) and the column image is placed in $(D_INLINECODE column) according to the specifications in $(D_INLINECODE format) and $(D_INLINECODE type). (In the current implementation, $(D_INLINECODE span) is not affected in any way.) No pixel transfer operations are performed on the images, but the relevant pixel storage modes are applied. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a separable convolution filter is requested, $(D_INLINECODE row), $(D_INLINECODE column), and $(D_INLINECODE span) are treated as a byte offset into the buffer object's data store. Color components that are present in $(D_INLINECODE format) but not included in the internal format of the filters are returned as zero. The assignments of internal color components to the components of $(D_INLINECODE format) are as follows: $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red Intensity Red
     + 
     + $(D_INLINECODE glGetSeparableFilter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS). Non-separable 2D filters must be retrieved with $(D_INLINECODE glGetConvolutionFilter).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetConvolutionFilter), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glSeparableFilter2D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid* row, GLvoid* column, GLvoid* span) @system @nogc nothrow;

    /++
     + glGetTexImage: man2/glGetTexImage.xml
     + 
     + $(D_INLINECODE glGetTexImage) returns a texture image into $(D_INLINECODE img). $(D_INLINECODE target) specifies whether the desired texture image is one specified by $(D_INLINECODE glTexImage1D) ( $(D_INLINECODE GL_TEXTURE_1D) ), $(D_INLINECODE glTexImage2D) ( $(D_INLINECODE GL_TEXTURE_2D) or any of $(D_INLINECODE GL_TEXTURE_CUBE_MAP_*) ), or $(D_INLINECODE glTexImage3D) ( $(D_INLINECODE GL_TEXTURE_3D) ). $(D_INLINECODE level) specifies the level-of-detail number of the desired image. $(D_INLINECODE format) and $(D_INLINECODE type) specify the format and type of the desired image array. See the reference pages $(D_INLINECODE glTexImage1D) and $(D_INLINECODE glDrawPixels) for a description of the acceptable values for the $(D_INLINECODE format) and $(D_INLINECODE type) parameters, respectively. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is requested, $(D_INLINECODE img) is treated as a byte offset into the buffer object's data store. To understand the operation of $(D_INLINECODE glGetTexImage), consider the selected internal four-component texture image to be an RGBA color buffer the size of the image. The semantics of $(D_INLINECODE glGetTexImage) are then identical to those of $(D_INLINECODE glReadPixels), with the exception that no pixel transfer operations are performed, when called with the same $(D_INLINECODE format) and $(D_INLINECODE type), with and set to 0, set to the width of the texture image (including border if one was specified), and set to 1 for 1D images, or to the height of the texture image (including border if one was specified) for 2D images. Because the internal texture image is an RGBA image, pixel formats $(D_INLINECODE GL_COLOR_INDEX), $(D_INLINECODE GL_STENCIL_INDEX), and $(D_INLINECODE GL_DEPTH_COMPONENT) are not accepted, and pixel type $(D_INLINECODE GL_BITMAP) is not accepted. If the selected texture image does not contain four components, the following mappings are applied. Single-component textures are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to 1. To determine the required size of $(D_INLINECODE img), use $(D_INLINECODE glGetTexLevelParameter) to determine the dimensions of the internal texture image, then scale the required number of pixels by the storage required for each pixel, based on $(D_INLINECODE format) and $(D_INLINECODE type). Be sure to take the pixel storage parameters into account, especially $(D_INLINECODE GL_PACK_ALIGNMENT).
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE img). The types $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), and the formats $(D_INLINECODE GL_BGR), and $(D_INLINECODE GL_BGRA) are available only if the GL version is 1.2 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glGetTexImage) returns the texture image for the active texture unit.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid* img) @system @nogc nothrow;

    /++
     + glIsBuffer: man2/glIsBuffer.xml
     + 
     + $(D_INLINECODE glIsBuffer) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE buffer) is currently the name of a buffer object. If $(D_INLINECODE buffer) is zero, or is a non-zero value that is not currently the name of a buffer object, or if an error occurs, $(D_INLINECODE glIsBuffer) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenBuffers), but not yet associated with a buffer object by calling $(D_INLINECODE glBindBuffer), is not the name of a buffer object.
     + 
     + $(D_INLINECODE glIsBuffer) is available only if the GL version is 1.5 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGenBuffers), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    GLboolean glIsBuffer(GLuint buffer) @system @nogc nothrow;

    /++
     + glColor: man2/glColor.xml
     + 
     + The GL stores both a current single-valued color index and a current four-valued RGBA color. $(D_INLINECODE glColor) sets a new four-valued RGBA color. $(D_INLINECODE glColor) has two major variants: $(D_INLINECODE glColor3) and $(D_INLINECODE glColor4). $(D_INLINECODE glColor3) variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. $(D_INLINECODE glColor4) variants specify all four color components explicitly. $(D_INLINECODE glColor3b), $(D_INLINECODE glColor4b), $(D_INLINECODE glColor3s), $(D_INLINECODE glColor4s), $(D_INLINECODE glColor3i), and $(D_INLINECODE glColor4i) take three or four signed byte, short, or long integers as arguments. When $(B v) is appended to the name, the color commands can take a pointer to an array of such values. Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly. Neither floating-point nor signed integer values are clamped to the range 0 1 before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     + 
     + The initial value for the current color is (1, 1, 1, 1). The current color can be updated at any time. In particular, $(D_INLINECODE glColor) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorPointer), $(D_INLINECODE glIndex), $(D_INLINECODE glSecondaryColor)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3b(GLbyte red, GLbyte green, GLbyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3s(GLshort red, GLshort green, GLshort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3i(GLint red, GLint green, GLint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3f(GLfloat red, GLfloat green, GLfloat blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3d(GLdouble red, GLdouble green, GLdouble blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3ub(GLubyte red, GLubyte green, GLubyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3us(GLushort red, GLushort green, GLushort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3ui(GLuint red, GLuint green, GLuint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4i(GLint red, GLint green, GLint blue, GLint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3bv(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3ubv(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3usv(const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor3uiv(const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4bv(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4ubv(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4usv(const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColor4uiv(const GLuint* v) @system @nogc nothrow;

    /++
     + glAttachShader: man2/glAttachShader.xml
     + 
     + In order to create an executable, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. $(D_INLINECODE glAttachShader) attaches the shader object specified by $(D_INLINECODE shader) to the program object specified by $(D_INLINECODE program). This indicates that $(D_INLINECODE shader) will be included in link operations that will be performed on $(D_INLINECODE program). All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. It is permissible to attach multiple shader objects of the same type because each may contain a portion of the complete shader. It is also permissible to attach a shader object to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until $(D_INLINECODE glDetachShader) is called to detach it from all program objects to which it is attached.
     + 
     + $(D_INLINECODE glAttachShader) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glAttachShader(GLuint program, GLuint shader) @system @nogc nothrow;

    /++
     + glScale: man2/glScale.xml
     + 
     + $(D_INLINECODE glScale) produces a nonuniform scaling along the,, and axes. The three parameters indicate the desired scale factor along each of the three axes. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by this scale matrix, and the product replaces the current matrix as if $(D_INLINECODE glMultMatrix) were called with the following matrix as its argument: x 0 0 0 0 y 0 0 0 0 z 0 0 0 0 1 If the matrix mode is either $(D_INLINECODE GL_MODELVIEW) or $(D_INLINECODE GL_PROJECTION), all objects drawn after $(D_INLINECODE glScale) is called are scaled. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the unscaled coordinate system.
     + 
     + If scale factors other than 1 are applied to the modelview matrix and lighting is enabled, lighting often appears wrong. In that case, enable automatic normalization of normals by calling $(D_INLINECODE glEnable) with the argument $(D_INLINECODE GL_NORMALIZE).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glRotate), $(D_INLINECODE glTranslate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glScaled(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glScalef(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;

    /++
     + glCallList: man2/glCallList.xml
     + 
     + $(D_INLINECODE glCallList) causes the named display list to be executed. The commands saved in the display list are executed in order, just as if they were called without using a display list. If $(D_INLINECODE list) has not been defined as a display list, $(D_INLINECODE glCallList) is ignored. $(D_INLINECODE glCallList) can appear inside a display list. To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution. This limit is at least 64, and it depends on the implementation. GL state is not saved and restored across a call to $(D_INLINECODE glCallList). Thus, changes made to GL state during the execution of a display list remain after execution of the display list is completed. Use $(D_INLINECODE glPushAttrib), $(D_INLINECODE glPopAttrib), $(D_INLINECODE glPushMatrix), and $(D_INLINECODE glPopMatrix) to preserve GL state across $(D_INLINECODE glCallList) calls.
     + 
     + Display lists can be executed between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd), as long as the display list includes only commands that are allowed in this interval.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallLists), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glGenLists), $(D_INLINECODE glNewList), $(D_INLINECODE glPushAttrib), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glCallList(GLuint list) @system @nogc nothrow;

    /++
     + glFlush: man2/glFlush.xml
     + 
     + Different GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. $(D_INLINECODE glFlush) empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in finite time. Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call $(D_INLINECODE glFlush) whenever they count on having all of their previously issued commands completed. For example, call $(D_INLINECODE glFlush) before waiting for user input that depends on the generated image.
     + 
     + $(D_INLINECODE glFlush) can return at any time. It does not wait until the execution of all previously issued GL commands is complete.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFinish)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFlush() @system @nogc nothrow;

    /++
     + glLoadIdentity: man2/glLoadIdentity.xml
     + 
     + $(D_INLINECODE glLoadIdentity) replaces the current matrix with the identity matrix. It is semantically equivalent to calling $(D_INLINECODE glLoadMatrix) with the identity matrix 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 but in some cases it is more efficient.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLoadIdentity() @system @nogc nothrow;

    /++
     + glFrontFace: man2/glFrontFace.xml
     + 
     + In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing polygons, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_CULL_FACE). The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. $(D_INLINECODE glFrontFace) specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing $(D_INLINECODE GL_CCW) to $(D_INLINECODE mode) selects counterclockwise polygons as front-facing; $(D_INLINECODE GL_CW) selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCullFace), $(D_INLINECODE glLightModel)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFrontFace(GLenum mode) @system @nogc nothrow;

    /++
     + gluNewNurbsRenderer: man2/gluNewNurbsRenderer.xml
     + 
     + $(D_INLINECODE gluNewNurbsRenderer) creates and returns a pointer to a new NURBS object. This object must be referred to when calling NURBS rendering and control functions. A return value of 0 means that there is not enough memory to allocate the object.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginCurve), $(D_INLINECODE gluBeginSurface), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluDeleteNurbsRenderer), $(D_INLINECODE gluNurbsCallback), $(D_INLINECODE gluNurbsProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLUnurbs* gluNewNurbsRenderer() @system @nogc nothrow;

    /++
     + glGetBufferParameteriv: man2/glGetBufferParameteriv.xml
     + 
     + $(D_INLINECODE glGetBufferParameteriv) returns in $(D_INLINECODE data) a selected parameter of the buffer object specified by $(D_INLINECODE target). $(D_INLINECODE value) names a specific buffer object parameter, as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE data). $(D_INLINECODE glGetBufferParameteriv) is available only if the GL version is 1.5 or greater. Targets $(D_INLINECODE GL_PIXEL_PACK_BUFFER) and $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) are available only if the GL version is 2.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetBufferParameteriv(GLenum target, GLenum value, GLint* data) @system @nogc nothrow;

    /++
     + glGetQueryiv: man2/glGetQueryiv.xml
     + 
     + $(D_INLINECODE glGetQueryiv) returns in $(D_INLINECODE params) a selected parameter of the query object target specified by $(D_INLINECODE target). $(D_INLINECODE pname) names a specific query object target parameter.  When $(D_INLINECODE target) is $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE pname) can be as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE glGetQueryiv) is available only if the GL version is 1.5 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetQueryiv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glClearStencil: man2/glClearStencil.xml
     + 
     + $(D_INLINECODE glClearStencil) specifies the index used by $(D_INLINECODE glClear) to clear the stencil buffer. $(D_INLINECODE s) is masked with 2 m - 1, where m is the number of bits in the stencil buffer.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearStencil(GLint s) @system @nogc nothrow;

    /++
     + glIsProgram: man2/glIsProgram.xml
     + 
     + $(D_INLINECODE glIsProgram) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE program) is the name of a program object previously created with $(D_INLINECODE glCreateProgram) and not yet deleted with $(D_INLINECODE glDeleteProgram). If $(D_INLINECODE program) is zero or a non-zero value that is not the name of a program object, or if an error occurs, $(D_INLINECODE glIsProgram) returns $(D_INLINECODE GL_FALSE).
     + 
     + $(D_INLINECODE glIsProgram) is available only if the GL version is 2.0 or greater. No error is generated if $(D_INLINECODE program) is not a valid program object name. A program object marked for deletion with $(D_INLINECODE glDeleteProgram) but still in use as part of current rendering state is still considered a program object and $(D_INLINECODE glIsProgram) will return $(D_INLINECODE GL_TRUE).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    GLboolean glIsProgram(GLuint program) @system @nogc nothrow;

    /++
     + glGetColorTableParameter: man2/glGetColorTableParameter.xml
     + 
     + Returns parameters specific to color table $(D_INLINECODE target). When $(D_INLINECODE pname) is set to $(D_INLINECODE GL_COLOR_TABLE_SCALE) or $(D_INLINECODE GL_COLOR_TABLE_BIAS), $(D_INLINECODE glGetColorTableParameter) returns the color table scale or bias parameters for the table specified by $(D_INLINECODE target). For these queries, $(D_INLINECODE target) must be set to $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE) and $(D_INLINECODE params) points to an array of four elements, which receive the scale or bias factors for red, green, blue, and alpha, in that order. $(D_INLINECODE glGetColorTableParameter) can also be used to retrieve the format and size parameters for a color table. For these queries, set $(D_INLINECODE target) to either the color table target or the proxy color table target. The format and size parameters are set by $(D_INLINECODE glColorTable). The following table lists the format and size parameters that may be queried. For each symbolic constant listed below for $(D_INLINECODE pname), $(D_INLINECODE params) must point to an array of the given length and receive the values indicated. $(B Parameter) $(B N) $(B Meaning) $(D_INLINECODE GL_COLOR_TABLE_FORMAT) 1 Internal format (e.g., $(D_INLINECODE GL_RGBA) ) $(D_INLINECODE GL_COLOR_TABLE_WIDTH) 1 Number of elements in table $(D_INLINECODE GL_COLOR_TABLE_RED_SIZE) 1 Size of red component, in bits $(D_INLINECODE GL_COLOR_TABLE_GREEN_SIZE) 1 Size of green component $(D_INLINECODE GL_COLOR_TABLE_BLUE_SIZE) 1 Size of blue component $(D_INLINECODE GL_COLOR_TABLE_ALPHA_SIZE) 1 Size of alpha component $(D_INLINECODE GL_COLOR_TABLE_LUMINANCE_SIZE) 1 Size of luminance component $(D_INLINECODE GL_COLOR_TABLE_INTENSITY_SIZE) 1 Size of intensity component
     + 
     + $(D_INLINECODE glGetColorTableParameter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glTexParameter), $(D_INLINECODE glColorTableParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + gluCheckExtension: man2/gluCheckExtension.xml
     + 
     + $(D_INLINECODE gluCheckExtension) returns $(D_INLINECODE GLU_TRUE) if $(D_INLINECODE extName) is supported otherwise $(D_INLINECODE GLU_FALSE) is returned. This is used to check for the presence for OpenGL, GLU, or GLX extension names by passing the extension strings returned by $(D_INLINECODE glGetString), $(D_INLINECODE gluGetString), $(D_INLINECODE glXGetClientString), $(D_INLINECODE glXQueryExtensionsString), or $(D_INLINECODE glXQueryServerString), respectively, as $(D_INLINECODE extString).
     + 
     + Cases where one extension name is a substring of another are correctly handled. There may or may not be leading or trailing blanks in $(D_INLINECODE extString). Extension names should not contain embedded spaces. All strings are null-terminated.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluGetString), $(D_INLINECODE glGetString), $(D_INLINECODE glXGetClientString), $(D_INLINECODE glXQueryExtensionsString), $(D_INLINECODE glXQueryServerString)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLboolean gluCheckExtension(const(GLubyte)* extName, const(GLubyte)* extString) @system @nogc nothrow;

    /++
     + glFog: man2/glFog.xml
     + 
     + Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer clear operations. To enable and disable fog, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_FOG). $(D_INLINECODE glFog) assigns the value or values in $(D_INLINECODE params) to the fog parameter specified by $(D_INLINECODE pname). The following values are accepted for $(D_INLINECODE pname) : Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor f. Factor f is computed in one of three ways, depending on the fog mode. Let c be either the distance in eye coordinate from the origin (in the case that the $(D_INLINECODE GL_FOG_COORD_SRC) is $(D_INLINECODE GL_FRAGMENT_DEPTH) ) or the current fog coordinate (in the case that $(D_INLINECODE GL_FOG_COORD_SRC) is $(D_INLINECODE GL_FOG_COORD) ). The equation for $(D_INLINECODE GL_LINEAR) fog is f = end - c end - start The equation for $(D_INLINECODE GL_EXP) fog is f = e - density &CenterDot; c The equation for $(D_INLINECODE GL_EXP2) fog is f = e - density &CenterDot; c 2 Regardless of the fog mode, f is clamped to the range 0 1 after it is computed. Then, if the GL is in RGBA color mode, the fragment's red, green, and blue colors, represented by C r, are replaced by C r &Prime; = f &times; C r + 1 - f &times; C f Fog does not affect a fragment's alpha component. In color index mode, the fragment's color index i r is replaced by i r &Prime; = i r + 1 - f &times; i f
     + 
     + $(D_INLINECODE GL_FOG_COORD_SRC) is available only if the GL version is 1.4 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFogf(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFogi(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFogfv(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glFogiv(GLenum pname, const GLint* params) @system @nogc nothrow;

    /++
     + gluNextContour: man2/gluNextContour.xml
     + 
     + $(D_INLINECODE gluNextContour) is used in describing polygons with multiple contours. After the first contour has been described through a series of $(D_INLINECODE gluTessVertex) calls, a $(D_INLINECODE gluNextContour) call indicates that the previous contour is complete and that the next contour is about to begin. Another series of $(D_INLINECODE gluTessVertex) calls is then used to describe the new contour. This process can be repeated until all contours have been described. $(D_INLINECODE type) defines what type of contour follows. The legal contour types are as follows: If one contour is of type $(D_INLINECODE GLU_CCW) or $(D_INLINECODE GLU_CW), then all contours must be of the same type (if they are not, then all $(D_INLINECODE GLU_CCW) and $(D_INLINECODE GLU_CW) contours will be changed to $(D_INLINECODE GLU_UNKNOWN) ). Note that there is no real difference between the $(D_INLINECODE GLU_CCW) and $(D_INLINECODE GLU_CW) contour types. Before the first contour is described, $(D_INLINECODE gluNextContour) can be called to define the type of the first contour. If $(D_INLINECODE gluNextContour) is not called before the first contour, then the first contour is marked $(D_INLINECODE GLU_EXTERIOR). This command is obsolete and is provided for backward compatibility only. Calls to $(D_INLINECODE gluNextContour) are mapped to $(D_INLINECODE gluTessEndContour) followed by $(D_INLINECODE gluTessBeginContour).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginPolygon), $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluNextContour(GLUtesselator* tess, GLenum type) @system @nogc nothrow;

    /++
     + gluDisk: man2/gluDisk.xml
     + 
     + $(D_INLINECODE gluDisk) renders a disk on the = 0 plane. The disk has a radius of $(D_INLINECODE outer) and contains a concentric circular hole with a radius of $(D_INLINECODE inner). If $(D_INLINECODE inner) is 0, then no hole is generated. The disk is subdivided around the axis into slices (like pizza slices) and also about the axis into rings (as specified by $(D_INLINECODE slices) and $(D_INLINECODE loops), respectively). With respect to orientation, the + side of the disk is considered to be ``outside'' (see $(D_INLINECODE gluQuadricOrientation) ). This means that if the orientation is set to $(D_INLINECODE GLU_OUTSIDE), then any normals generated point along the + axis. Otherwise, they point along the \- axis. If texturing has been turned on (with $(D_INLINECODE gluQuadricTexture) ), texture coordinates are generated linearly such that where r = outer, the value at (, 0, 0) is (1, 0.5), at (0,, 0) it is (0.5, 1), at (\-, 0, 0) it is (0, 0.5), and at (0, \-, 0) it is (0.5, 0).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluCylinder), $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluPartialDisk), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture), $(D_INLINECODE gluSphere)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluDisk(GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops) @system @nogc nothrow;

    /++
     + glClearColor: man2/glClearColor.xml
     + 
     + $(D_INLINECODE glClearColor) specifies the red, green, blue, and alpha values used by $(D_INLINECODE glClear) to clear the color buffers. Values specified by $(D_INLINECODE glClearColor) are clamped to the range 0 1.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) @system @nogc nothrow;

    /++
     + glStencilOpSeparate: man2/glStencilOpSeparate.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST); to control it, call $(D_INLINECODE glStencilFunc) or $(D_INLINECODE glStencilFuncSeparate). There can be two separate sets of $(D_INLINECODE sfail), $(D_INLINECODE dpfail), and $(D_INLINECODE dppass) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilOp) sets both front and back stencil state to the same values, as if $(D_INLINECODE glStencilOpSeparate) were called with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK). $(D_INLINECODE glStencilOpSeparate) takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and $(D_INLINECODE sfail) specifies what happens to the stencil buffer contents. The following eight actions are possible. Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n - 1, where n is the value returned by querying $(D_INLINECODE GL_STENCIL_BITS). The other two arguments to $(D_INLINECODE glStencilOpSeparate) specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed ( $(D_INLINECODE dppass) ) or fail ( $(D_INLINECODE dpfail) ) (see $(D_INLINECODE glDepthFunc) ). The actions are specified using the same eight symbolic constants as $(D_INLINECODE sfail). Note that $(D_INLINECODE dpfail) is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, $(D_INLINECODE sfail) and $(D_INLINECODE dppass) specify stencil action when the stencil test fails and passes, respectively.
     + 
     + $(D_INLINECODE glStencilOpSeparate) is available only if the GL version is 2.0 or greater. Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) @system @nogc nothrow;

    /++
     + glBlendEquationSeparate: man2/glBlendEquationSeparate.xml
     + 
     + The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color).  This function specifies one blend equation for the RGB-color components and one blend equation for the alpha component. The blend equations use the source and destination blend factors specified by either $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate). See $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate) for a description of the various blend factors. In the equations that follow, source and destination color components are referred to as R s G s B s A s and R d G d B d A d, respectively. The result color is referred to as R r G r B r A r. The source and destination blend factors are denoted s R s G s B s A and d R d G d B d A, respectively. For these equations all color components are understood to have values in the range 0 1. $(B Mode) $(B RGB Components) $(B Alpha Component) $(D_INLINECODE GL_FUNC_ADD) Rr = R s &it; s R + R d &it; d R Gr = G s &it; s G + G d &it; d G Br = B s &it; s B + B d &it; d B Ar = A s &it; s A + A d &it; d A $(D_INLINECODE GL_FUNC_SUBTRACT) Rr = R s &it; s R - R d &it; d R Gr = G s &it; s G - G d &it; d G Br = B s &it; s B - B d &it; d B Ar = A s &it; s A - A d &it; d A $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT) Rr = R d &it; d R - R s &it; s R Gr = G d &it; d G - G s &it; s G Br = B d &it; d B - B s &it; s B Ar = A d &it; d A - A s &it; s A $(D_INLINECODE GL_MIN) Rr = min &af; R s R d Gr = min &af; G s G d Br = min &af; B s B d Ar = min &af; A s A d $(D_INLINECODE GL_MAX) Rr = max &af; R s R d Gr = max &af; G s G d Br = max &af; B s B d Ar = max &af; A s A d The results of these equations are clamped to the range 0 1. The $(D_INLINECODE GL_MIN) and $(D_INLINECODE GL_MAX) equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The $(D_INLINECODE GL_FUNC_ADD) equation is useful for antialiasing and transparency, among other things. Initially, both the RGB blend equation and the alpha blend equation are set to $(D_INLINECODE GL_FUNC_ADD).
     + 
     + $(D_INLINECODE glBlendEquationSeparate) is available only if the GL version is 2.0 or greater. The $(D_INLINECODE GL_MIN), and $(D_INLINECODE GL_MAX) equations do not use the source or destination factors, only the source and destination colors.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetString), $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glBlendFuncSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;

    /++
     + glAlphaFunc: man2/glAlphaFunc.xml
     + 
     + The alpha test discards fragments depending on the outcome of a comparison between an incoming fragment's alpha value and a constant reference value. $(D_INLINECODE glAlphaFunc) specifies the reference value and the comparison function. The comparison is performed only if alpha testing is enabled. By default, it is not enabled. (See $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) of $(D_INLINECODE GL_ALPHA_TEST).) $(D_INLINECODE func) and $(D_INLINECODE ref) specify the conditions under which the pixel is drawn. The incoming alpha value is compared to $(D_INLINECODE ref) using the function specified by $(D_INLINECODE func). If the value passes the comparison, the incoming fragment is drawn if it also passes subsequent stencil and depth buffer tests. If the value fails the comparison, no change is made to the frame buffer at that pixel location. The comparison functions are as follows: $(D_INLINECODE glAlphaFunc) operates on all pixel write operations, including those resulting from the scan conversion of points, lines, polygons, and bitmaps, and from pixel draw and copy operations. $(D_INLINECODE glAlphaFunc) does not affect screen clear operations.
     + 
     + Alpha testing is performed only in RGBA mode.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glClear), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glStencilFunc)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glAlphaFunc(GLenum func, GLclampf ref_) @system @nogc nothrow;

    /++
     + glGenQueries: man2/glGenQueries.xml
     + 
     + $(D_INLINECODE glGenQueries) returns $(D_INLINECODE n) query object names in $(D_INLINECODE ids). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenQueries). Query object names returned by a call to $(D_INLINECODE glGenQueries) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteQueries). No query objects are associated with the returned query object names until they are first used by calling $(D_INLINECODE glBeginQuery).
     + 
     + $(D_INLINECODE glGenQueries) is available only if the GL version is 1.5 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGenQueries(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glNormal: man2/glNormal.xml
     + 
     + The current normal is set to the given coordinates whenever $(D_INLINECODE glNormal) is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to -1.0. Normals specified with $(D_INLINECODE glNormal) need not have unit length. If $(D_INLINECODE GL_NORMALIZE) is enabled, then normals of any length specified with $(D_INLINECODE glNormal) are normalized after transformation. If $(D_INLINECODE GL_RESCALE_NORMAL) is enabled, normals are scaled by a scaling factor derived from the modelview matrix. $(D_INLINECODE GL_RESCALE_NORMAL) requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with either $(D_INLINECODE GL_NORMALIZE) or $(D_INLINECODE GL_RESCALE_NORMAL). Normalization is initially disabled.
     + 
     + The current normal can be updated at any time. In particular, $(D_INLINECODE glNormal) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glIndex), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3i(GLint nx, GLint ny, GLint nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3s(GLshort nx, GLshort ny, GLshort nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3bv(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glNormal3sv(const GLshort* v) @system @nogc nothrow;

    /++
     + glPixelTransfer: man2/glPixelTransfer.xml
     + 
     + $(D_INLINECODE glPixelTransfer) sets pixel transfer modes that affect the operation of subsequent $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D) commands. Additionally, if the $(D_INLINECODE ARB_imaging) subset is supported, the routines $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glHistogram), $(D_INLINECODE glMinmax), and $(D_INLINECODE glSeparableFilter2D) are also affected. The algorithms that are specified by pixel transfer modes operate on pixels after they are read from the frame buffer ( $(D_INLINECODE glCopyPixels) $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), and $(D_INLINECODE glReadPixels) ), or unpacked from client memory ( $(D_INLINECODE glDrawPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D) ). Pixel transfer operations happen in the same order, and in the same manner, regardless of the command that resulted in the pixel operation. Pixel storage modes (see $(D_INLINECODE glPixelStore) ) control the unpacking of pixels being read from client memory and the packing of pixels being written back into client memory. Pixel transfer operations handle four fundamental pixel types:,,, and. pixels consist of four floating-point values with unspecified mantissa and exponent sizes, scaled such that 0 represents zero intensity and 1 represents full intensity. comprise a single fixed-point value, with unspecified precision to the right of the binary point. pixels comprise a single floating-point value, with unspecified mantissa and exponent sizes, scaled such that 0.0 represents the minimum depth buffer value, and 1.0 represents the maximum depth buffer value. Finally, pixels comprise a single fixed-point value, with unspecified precision to the right of the binary point. The pixel transfer operations performed on the four basic pixel types are as follows: The following table gives the type, initial value, and range of valid values for each of the pixel transfer parameters that are set with $(D_INLINECODE glPixelTransfer). $(B $(D_INLINECODE pname)) $(B Type) $(B Initial Value) $(B Valid Range) $(D_INLINECODE GL_MAP_COLOR) boolean false true/false $(D_INLINECODE GL_MAP_STENCIL) boolean false true/false $(D_INLINECODE GL_INDEX_SHIFT) integer 0 -&#8734;&#8734; $(D_INLINECODE GL_INDEX_OFFSET) integer 0 -&#8734;&#8734; $(D_INLINECODE GL_RED_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_GREEN_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_BLUE_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_ALPHA_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_DEPTH_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_RED_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_GREEN_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_BLUE_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_ALPHA_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_DEPTH_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_RED_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_GREEN_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_BLUE_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_ALPHA_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_RED_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_GREEN_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_BLUE_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_ALPHA_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_RED_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_GREEN_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_BLUE_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_ALPHA_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_RED_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_GREEN_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_BLUE_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_ALPHA_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE glPixelTransferf) can be used to set any pixel transfer parameter. If the parameter type is boolean, 0 implies false and any other value implies true. If $(D_INLINECODE pname) is an integer parameter, $(D_INLINECODE param) is rounded to the nearest integer. Likewise, $(D_INLINECODE glPixelTransferi) can be used to set any of the pixel transfer parameters. Boolean parameters are set to false if $(D_INLINECODE param) is 0 and to true otherwise. $(D_INLINECODE param) is converted to floating point before being assigned to real-valued parameters.
     + 
     + If a $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), or $(D_INLINECODE glTexSubImage3D) command is placed in a display list (see $(D_INLINECODE glNewList) and $(D_INLINECODE glCallList) ), the pixel transfer mode settings in effect when the display list is are the ones that are used. They may be different from the settings when the command was compiled into the display list.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glNewList), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelZoom), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelTransferf(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPixelTransferi(GLenum pname, GLint param) @system @nogc nothrow;

    /++
     + gluBuild3DMipmapLevels: man2/gluBuild3DMipmapLevels.xml
     + 
     + $(D_INLINECODE gluBuild3DMipmapLevels) builds a subset of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). A series of mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max) is built by decimating $(D_INLINECODE data) in half along both dimensions until size 1 &times; 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding eight texels in the larger mipmap level. (If exactly one of the dimensions is 1, four texels are averaged.  If exactly two of the dimensions are 1, two texels are averaged.) $(D_INLINECODE glTexImage3D) is called to load these mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max). If $(D_INLINECODE max) is larger than the highest mipmap level for the texture of the specified size, then a GLU error code is returned (see $(D_INLINECODE gluErrorString) ) and nothing is loaded. For example, if $(D_INLINECODE level) is 2 and $(D_INLINECODE width) is 16, $(D_INLINECODE height) is 8 and $(D_INLINECODE depth) is 4, the following levels are possible: 16 &times; 8 &times; 4, 8 &times; 4 &times; 2, 4 &times; 2 &times; 1, 2 &times; 1 &times; 1, 1 &times; 1 &times; 1. These correspond to levels 2 through 6 respectively.  If $(D_INLINECODE base) is 3 and $(D_INLINECODE max) is 5, then only mipmap levels 8 &times; 4 &times; 2, 4 &times; 2 &times; 1, and 2 &times; 1 &times; 1 are loaded. However, if $(D_INLINECODE max) is 7, then an error is returned and nothing is loaded, since $(D_INLINECODE max) is larger than the highest mipmap level which is, in this case, 6. The highest mipmap level can be derived from the formula log 2 &af; max &af; width height depth &times; 2 level. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE format) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter.
     + 
     + $(D_INLINECODE gluBuild3DMipmapLevels) is only available if the GLU version is 1.3 or greater. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void* data) @system @nogc nothrow;

    /++
     + glDrawRangeElements: man2/glDrawRangeElements.xml
     + 
     + $(D_INLINECODE glDrawRangeElements) is a restricted form of $(D_INLINECODE glDrawElements). $(D_INLINECODE mode), $(D_INLINECODE start), $(D_INLINECODE end), and $(D_INLINECODE count) match the corresponding arguments to $(D_INLINECODE glDrawElements), with the additional constraint that all values in the arrays $(D_INLINECODE count) must lie between $(D_INLINECODE start) and $(D_INLINECODE end), inclusive. Implementations denote recommended maximum amounts of vertex and index data, which may be queried by calling $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_ELEMENTS_VERTICES) and $(D_INLINECODE GL_MAX_ELEMENTS_INDICES). If end - start + 1 is greater than the value of $(D_INLINECODE GL_MAX_ELEMENTS_VERTICES), or if $(D_INLINECODE count) is greater than the value of $(D_INLINECODE GL_MAX_ELEMENTS_INDICES), then the call may operate at reduced performance.  There is no requirement that all vertices in the range start end be referenced.  However, the implementation may partially process unused vertices, reducing performance from what could be achieved with an optimal index set. When $(D_INLINECODE glDrawRangeElements) is called, it uses $(D_INLINECODE count) sequential elements from an enabled array, starting at $(D_INLINECODE start) to construct a sequence of geometric primitives. $(D_INLINECODE mode) specifies what kind of primitives are constructed, and how the array elements construct these primitives. If more than one array is enabled, each is used. If $(D_INLINECODE GL_VERTEX_ARRAY) is not enabled, no geometric primitives are constructed. Vertex attributes that are modified by $(D_INLINECODE glDrawRangeElements) have an unspecified value after $(D_INLINECODE glDrawRangeElements) returns. For example, if $(D_INLINECODE GL_COLOR_ARRAY) is enabled, the value of the current color is undefined after $(D_INLINECODE glDrawRangeElements) executes. Attributes that aren't modified maintain their previous values.
     + 
     + $(D_INLINECODE glDrawRangeElements) is available only if the GL version is 1.2 or greater. $(D_INLINECODE glDrawRangeElements) is included in display lists. If $(D_INLINECODE glDrawRangeElements) is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices) @system @nogc nothrow;

    /++
     + glVertex: man2/glVertex.xml
     + 
     + $(D_INLINECODE glVertex) commands are used within $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) pairs to specify point, line, and polygon vertices.  The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when $(D_INLINECODE glVertex) is called. When only x and y are specified, z defaults to 0 and w defaults to 1.  When x, y, and z are specified, w defaults to 1.
     + 
     + Invoking $(D_INLINECODE glVertex) outside of a $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) pair results in undefined behavior.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glCallList), $(D_INLINECODE glColor), $(D_INLINECODE glEdgeFlag), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glFogCoord), $(D_INLINECODE glIndex), $(D_INLINECODE glMaterial), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glNormal), $(D_INLINECODE glRect), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2s(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2i(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2f(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2d(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3s(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3i(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3f(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3d(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4i(GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex2dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glVertex4dv(const GLdouble* v) @system @nogc nothrow;

    /++
     + gluNurbsCallback: man2/gluNurbsCallback.xml
     + 
     + $(D_INLINECODE gluNurbsCallback) is used to define a callback to be used by a NURBS object. If the specified callback is already defined, then it is replaced.  If $(D_INLINECODE CallBackFunc) is null, then this callback will not get
     +  invoked and the related data, if any, will be lost.
     +  Except the error callback, these callbacks are used by NURBS tessellator (when $(D_INLINECODE GLU_NURBS_MODE) is set to be $(D_INLINECODE GLU_NURBS_TESSELLATOR) ) to return back the OpenGL polygon primitives resulting from the tessellation. Note that there are two versions of each callback: one with a user data pointer and one without. If both versions for a particular callback are specified then the callback with the user data pointer will be used. Note that ``userData'' is a copy of the pointer that was specified at the last call to $(D_INLINECODE gluNurbsCallbackData). The error callback function is effective no matter which value that $(D_INLINECODE GLU_NURBS_MODE) is set to. All other callback functions are effective only when $(D_INLINECODE GLU_NURBS_MODE) is set to $(D_INLINECODE GLU_NURBS_TESSELLATOR). The legal callbacks are as follows:
     + 
     + $(D_INLINECODE gluNurbsCallback) is available only if the GLU version is 1.2 or greater. GLU version 1.2 supports only the $(D_INLINECODE GLU_ERROR) parameter for $(D_INLINECODE which). The $(D_INLINECODE GLU_ERROR) value is deprecated in GLU version 1.3 in favor of $(D_INLINECODE GLU_NURBS_ERROR).  All other accepted values for $(D_INLINECODE CallBackFunc) are available only if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluErrorString), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCallbackData), $(D_INLINECODE gluNurbsProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluNurbsCallback(GLUnurbs* nurb, GLenum which, _GLUfuncptr CallBackFunc) @system @nogc nothrow;

    /++
     + glMultiDrawElements: man2/glMultiDrawElements.xml
     + 
     + $(D_INLINECODE glMultiDrawElements) specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glMultiDrawElements). $(D_INLINECODE glMultiDrawElements) is identical in operation to $(D_INLINECODE glDrawElements) except that $(D_INLINECODE primcount) separate lists of elements are specified. Vertex attributes that are modified by $(D_INLINECODE glMultiDrawElements) have an unspecified value after $(D_INLINECODE glMultiDrawElements) returns. For example, if $(D_INLINECODE GL_COLOR_ARRAY) is enabled, the value of the current color is undefined after $(D_INLINECODE glMultiDrawElements) executes. Attributes that aren't modified maintain their previous values.
     + 
     + $(D_INLINECODE glMultiDrawElements) is available only if the GL version is 1.4 or greater. $(D_INLINECODE glMultiDrawElements) is included in display lists. If $(D_INLINECODE glMultiDrawElements) is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glMultiDrawElements(GLenum mode, const GLsizei* count, GLenum type, const GLvoid** indices, GLsizei primcount) @system @nogc nothrow;

    /++
     + glGetShader: man2/glGetShader.xml
     + 
     + $(D_INLINECODE glGetShader) returns in $(D_INLINECODE params) the value of a parameter for a specific shader object. The following parameters are defined:
     + 
     + $(D_INLINECODE glGetShader) is available only if the GL version is 2.0 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glGetProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetShaderiv(GLuint shader, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glConvolutionFilter1D: man2/glConvolutionFilter1D.xml
     + 
     + $(D_INLINECODE glConvolutionFilter1D) builds a one-dimensional convolution filter kernel from an array of pixels. The pixel array specified by $(D_INLINECODE width), $(D_INLINECODE format), $(D_INLINECODE type), and $(D_INLINECODE data) is extracted from memory and processed just as if $(D_INLINECODE glDrawPixels) were called, but processing stops after the final expansion to RGBA is completed. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a convolution filter is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The R, G, B, and A components of each pixel are next scaled by the four 1D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four 1D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_CONVOLUTION_1D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. They form a one-dimensional filter kernel image indexed with coordinate such that starts at 0 and increases from left to right. Kernel location is derived from the th pixel, counting from 0. Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glConvolutionFilter1D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glPointSize: man2/glPointSize.xml
     + 
     + $(D_INLINECODE glPointSize) specifies the rasterized diameter of both aliased and antialiased points.  Using a point size other than 1 has different effects, depending on whether point antialiasing is enabled.  To enable and disable point antialiasing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_POINT_SMOOTH). Point antialiasing is initially disabled. The specified point size is multiplied with a distance attenuation factor and clamped to the specified point size range, and further clamped to the implementation-dependent point size range to produce the derived point size using pointSize = clamp &it; size &times; 1 a + b &times; d + c &times; d 2 where d is the eye-coordinate distance from the eye to the vertex, and a, b, and c are the distance attenuation coefficients (see $(D_INLINECODE glPointParameter) ). If multisampling is disabled, the computed point size is used as the point's width. If multisampling is enabled, the point may be faded by modifying the point alpha value (see $(D_INLINECODE glSampleCoverage) ) instead of allowing the point width to go below a given threshold (see $(D_INLINECODE glPointParameter) ).  In this case, the width is further modified in the following manner: pointWidth = pointSize threshold &it; pointSize &gt;= threshold otherwise The point alpha value is modified by computing: pointAlpha = 1 pointSize threshold 2 &it; pointSize &gt;= threshold otherwise If point antialiasing is disabled, the actual size is determined by rounding the supplied size to the nearest integer.  (If the rounding results in the value 0, it is as if the point size were 1.)  If the rounded size is odd, then the center point ( x, y ) of the pixel fragment that represents the point is computed as x w +.5 y w +.5 where w subscripts indicate window coordinates.  All pixels that lie within the square grid of the rounded size centered at ( x, y ) make up the fragment.  If the size is even, the center point is x w +.5 y w +.5 and the rasterized fragment's centers are the half-integer window coordinates within the square of the rounded size centered at x y. All pixel fragments produced in rasterizing a nonantialiased point are assigned the same associated data, that of the vertex corresponding to the point. If antialiasing is enabled, then point rasterization produces a fragment for each pixel square that intersects the region lying within the circle having diameter equal to the current point size and centered at the point's x w y w. The coverage value for each fragment is the window coordinate area of the intersection of the circular region with the corresponding pixel square.  This value is saved and used in the final rasterization step.  The data associated with each fragment is the data associated with the point being rasterized. Not all sizes are supported when point antialiasing is enabled.  If an unsupported size is requested, the nearest supported size is used.  Only size 1 is guaranteed to be supported; others depend on the implementation. To query the range of supported sizes and the size difference between supported sizes within the range, call $(D_INLINECODE glGet) with arguments $(D_INLINECODE GL_SMOOTH_POINT_SIZE_RANGE) and $(D_INLINECODE GL_SMOOTH_POINT_SIZE_GRANULARITY). For aliased points, query the supported ranges and granularity with $(D_INLINECODE glGet) with arguments $(D_INLINECODE GL_ALIASED_POINT_SIZE_RANGE).
     + 
     + The point size specified by $(D_INLINECODE glPointSize) is always returned when $(D_INLINECODE GL_POINT_SIZE) is queried.  Clamping and rounding for aliased and antialiased points have no effect on the specified value. A non-antialiased point size may be clamped to an implementation-dependent maximum.  Although this maximum cannot be queried, it must be no less than the maximum value for antialiased points, rounded to the nearest integer value. $(D_INLINECODE GL_POINT_SIZE_RANGE) and $(D_INLINECODE GL_POINT_SIZE_GRANULARITY) are deprecated in GL versions 1.2 and greater.  Their functionality has been replaced by $(D_INLINECODE GL_SMOOTH_POINT_SIZE_RANGE) and $(D_INLINECODE GL_SMOOTH_POINT_SIZE_GRANULARITY).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glPointParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPointSize(GLfloat size) @system @nogc nothrow;

    /++
     + gluNurbsSurface: man2/gluNurbsSurface.xml
     + 
     + Use $(D_INLINECODE gluNurbsSurface) within a NURBS (Non-Uniform Rational B-Spline) surface definition to describe the shape of a NURBS surface (before any trimming). To mark the beginning of a NURBS surface definition, use the $(D_INLINECODE gluBeginSurface) command. To mark the end of a NURBS surface definition, use the $(D_INLINECODE gluEndSurface) command. Call $(D_INLINECODE gluNurbsSurface) within a NURBS surface definition only. Positional, texture, and color coordinates are associated with a surface by presenting each as a separate $(D_INLINECODE gluNurbsSurface) between a $(D_INLINECODE gluBeginSurface) / $(D_INLINECODE gluEndSurface) pair. No more than one call to $(D_INLINECODE gluNurbsSurface) for each of color, position, and texture data can be made within a single $(D_INLINECODE gluBeginSurface) / $(D_INLINECODE gluEndSurface) pair. Exactly one call must be made to describe the position of the surface (a $(D_INLINECODE type) of $(D_INLINECODE GLU_MAP2_VERTEX_3) or $(D_INLINECODE GLU_MAP2_VERTEX_4) ). A NURBS surface can be trimmed by using the commands $(D_INLINECODE gluNurbsCurve) and $(D_INLINECODE gluPwlCurve) between calls to $(D_INLINECODE gluBeginTrim) and $(D_INLINECODE gluEndTrim). Note that a $(D_INLINECODE gluNurbsSurface) with $(D_INLINECODE sKnotCount) knots in the direction and $(D_INLINECODE tKnotCount) knots in the direction with orders $(D_INLINECODE sOrder) and $(D_INLINECODE tOrder) must have ( $(D_INLINECODE sKnotCount) - $(D_INLINECODE sOrder) ) times ( $(D_INLINECODE tKnotCount) - $(D_INLINECODE tOrder) ) control points.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginSurface), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCurve), $(D_INLINECODE gluPwlCurve)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluNurbsSurface(GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type) @system @nogc nothrow;

    /++
     + glMultMatrix: man2/glMultMatrix.xml
     + 
     + $(D_INLINECODE glMultMatrix) multiplies the current matrix with the one specified using $(D_INLINECODE m), and replaces the current matrix with the product. The current matrix is determined by the current matrix mode (see $(D_INLINECODE glMatrixMode) ). It is either the projection matrix, modelview matrix, or the texture matrix.
     + 
     + While the elements of the matrix may be specified with single or double precision, the GL may store or operate on these values in less-than-single precision. In many computer languages, 4 &times; 4 arrays are represented in row-major order. The transformations just described represent these matrices in column-major order. The order of the multiplication is important. For example, if the current transformation is a rotation, and $(D_INLINECODE glMultMatrix) is called with a translation matrix, the translation is done directly on the coordinates to be transformed, while the rotation is done on the results of that translation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMultMatrixd(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glMultMatrixf(const GLfloat* m) @system @nogc nothrow;

    /++
     + gluBuild3DMipmaps: man2/gluBuild3DMipmaps.xml
     + 
     + $(D_INLINECODE gluBuild3DMipmaps) builds a series of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture-mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). Initially, the $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) of $(D_INLINECODE data) are checked to see if they are a power of 2. If not, a copy of $(D_INLINECODE data) is made and scaled up or down to the nearest power of 2. (If $(D_INLINECODE width), $(D_INLINECODE height), or $(D_INLINECODE depth) is exactly between powers of 2, then the copy of $(D_INLINECODE data) will scale upwards.) This copy will be used for subsequent mipmapping operations described below.  For example, if $(D_INLINECODE width) is 57, $(D_INLINECODE height) is 23, and $(D_INLINECODE depth) is 24, then a copy of $(D_INLINECODE data) will scale up to 64 in width, down to 16 in height, and up to 32 in depth before mipmapping takes place. Then, proxy textures (see $(D_INLINECODE glTexImage3D) ) are used to determine if the implementation can fit the requested texture. If not, all three dimensions are continually halved until it fits. Next, a series of mipmap levels is built by decimating a copy of $(D_INLINECODE data) in half along all three dimensions until size 1 &times; 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding eight texels in the larger mipmap level. (If exactly one of the dimensions is 1, four texels are averaged. If exactly two of the dimensions are 1, two texels are averaged.) $(D_INLINECODE glTexImage3D) is called to load each of these mipmap levels. Level 0 is a copy of $(D_INLINECODE data).  The highest level is log 2 &af; max &af; width height depth. For example, if $(D_INLINECODE width) is 64, $(D_INLINECODE height) is 16, and $(D_INLINECODE depth) is 32, and the implementation can store a texture of this size, the following mipmap levels are built: 64 &times; 16 &times; 32, 32 &times; 8 &times; 16, 16 &times; 4 &times; 8, 8 &times; 2 &times; 4, 4 &times; 1 &times; 2, 2 &times; 1 &times; 1, and 1 &times; 1 &times; 1. These correspond to levels 0 through 6, respectively. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE format) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter.
     + 
     + Note that there is no direct way of querying the maximum level. This can be derived indirectly via $(D_INLINECODE glGetTexLevelParameter). First, query the width, height, and depth actually used at level 0.  (The width, height, and depth may not be equal to $(D_INLINECODE width), $(D_INLINECODE height), and $(D_INLINECODE depth) respectively since proxy textures might have scaled them to fit the implementation.)  Then the maximum level can be derived from the formula log 2 &af; max &af; width height depth. $(D_INLINECODE gluBuild3DMipmaps) is only available if the GLU version is 1.3 or greater. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* data) @system @nogc nothrow;

    /++
     + glBufferSubData: man2/glBufferSubData.xml
     + 
     + $(D_INLINECODE glBufferSubData) redefines some or all of the data store for the buffer object currently bound to $(D_INLINECODE target). Data starting at byte offset $(D_INLINECODE offset) and extending for $(D_INLINECODE size) bytes is copied to the data store from the memory pointed to by $(D_INLINECODE data).  An error is thrown if $(D_INLINECODE offset) and $(D_INLINECODE size) together define a range beyond the bounds of the buffer object's data store.
     + 
     + $(D_INLINECODE glBufferSubData) is available only if the GL version is 1.5 or greater. Targets $(D_INLINECODE GL_PIXEL_PACK_BUFFER) and $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) are available only if the GL version is 2.1 or greater. When replacing the entire data store, consider using $(D_INLINECODE glBufferSubData) rather than completely recreating the data store with $(D_INLINECODE glBufferData).  This avoids the cost of reallocating the data store. Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering in the pipeline makes reference to data in the buffer object being updated by $(D_INLINECODE glBufferSubData), especially from the specific region being updated, that rendering must drain from the pipeline before the data store can be updated. Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N bytes be a multiple of N.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data) @system @nogc nothrow;

    /++
     + gluQuadricOrientation: man2/gluQuadricOrientation.xml
     + 
     + $(D_INLINECODE gluQuadricOrientation) specifies what kind of orientation is desired for quadrics rendered with $(D_INLINECODE quad). The $(D_INLINECODE orientation) values are as follows: Note that the interpretation of and depends on the quadric being drawn.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricDrawStyle), $(D_INLINECODE gluQuadricNormals), $(D_INLINECODE gluQuadricTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluQuadricOrientation(GLUquadric* quad, GLenum orientation) @system @nogc nothrow;

    /++
     + glHistogram: man2/glHistogram.xml
     + 
     + When $(D_INLINECODE GL_HISTOGRAM) is enabled, RGBA color components are converted to histogram table indices by clamping to the range [0,1], multiplying by the width of the histogram table, and rounding to the nearest integer. The table entries selected by the RGBA indices are then incremented. (If the internal format of the histogram table includes luminance, then the index derived from the R color component determines the luminance table entry to be incremented.)  If a histogram table entry is incremented beyond its maximum value, then its value becomes undefined.  (This is not an error.) Histogramming is performed only for RGBA pixels (though these may be specified originally as color indices and converted to RGBA by index table lookup). Histogramming is enabled with $(D_INLINECODE glEnable) and disabled with $(D_INLINECODE glDisable). When $(D_INLINECODE target) is $(D_INLINECODE GL_HISTOGRAM), $(D_INLINECODE glHistogram) redefines the current histogram table to have $(D_INLINECODE width) entries of the format specified by $(D_INLINECODE internalformat). The entries are indexed 0 through width - 1, and all entries are initialized to zero. The values in the previous histogram table, if any, are lost. If $(D_INLINECODE sink) is $(D_INLINECODE GL_TRUE), then pixels are discarded after histogramming; no further processing of the pixels takes place, and no drawing, texture loading, or pixel readback will result. When $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_HISTOGRAM), $(D_INLINECODE glHistogram) computes all state information as if the histogram table were to be redefined, but does not actually define the new table. If the requested histogram table is too large to be supported, then the state information will be set to zero. This provides a way to determine if a histogram table with the given parameters can be supported.
     + 
     + $(D_INLINECODE glHistogram) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetHistogram), $(D_INLINECODE glResetHistogram)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) @system @nogc nothrow;

    /++
     + glGetActiveAttrib: man2/glGetActiveAttrib.xml
     + 
     + $(D_INLINECODE glGetActiveAttrib) returns information about an active attribute variable in the program object specified by $(D_INLINECODE program). The number of active attributes can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_ATTRIBUTES). A value of 0 for $(D_INLINECODE index) selects the first active attribute variable. Permissible values for $(D_INLINECODE index) range from 0 to the number of active attribute variables minus 1. A vertex shader may use either built-in attribute variables, user-defined attribute variables, or both. Built-in attribute variables have a prefix of &quot;gl_&quot; and reference conventional OpenGL vertex attribtes (e.g., $(D_INLINECODE gl_Vertex), $(D_INLINECODE gl_Normal), etc., see the OpenGL Shading Language specification for a complete list.) User-defined attribute variables have arbitrary names and obtain their values through numbered generic vertex attributes. An attribute variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, $(D_INLINECODE program) should have previously been the target of a call to $(D_INLINECODE glLinkProgram), but it is not necessary for it to have been linked successfully. The size of the character buffer required to store the longest attribute variable name in $(D_INLINECODE program) can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_ATTRIBUTE_MAX_LENGTH). This value should be used to allocate a buffer of sufficient size to store the returned attribute name. The size of this character buffer is passed in $(D_INLINECODE bufSize), and a pointer to this character buffer is passed in $(D_INLINECODE name). $(D_INLINECODE glGetActiveAttrib) returns the name of the attribute variable indicated by $(D_INLINECODE index), storing it in the character buffer specified by $(D_INLINECODE name). The string returned will be null terminated. The actual number of characters written into this buffer is returned in $(D_INLINECODE length), and this count does not include the null termination character. If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The $(D_INLINECODE type) argument will return a pointer to the attribute variable's data type. The symbolic constants $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_FLOAT_VEC2), $(D_INLINECODE GL_FLOAT_VEC3), $(D_INLINECODE GL_FLOAT_VEC4), $(D_INLINECODE GL_FLOAT_MAT2), $(D_INLINECODE GL_FLOAT_MAT3), $(D_INLINECODE GL_FLOAT_MAT4), $(D_INLINECODE GL_FLOAT_MAT2x3), $(D_INLINECODE GL_FLOAT_MAT2x4), $(D_INLINECODE GL_FLOAT_MAT3x2), $(D_INLINECODE GL_FLOAT_MAT3x4), $(D_INLINECODE GL_FLOAT_MAT4x2), or $(D_INLINECODE GL_FLOAT_MAT4x3) may be returned. The $(D_INLINECODE size) argument will return the size of the attribute, in units of the type returned in $(D_INLINECODE type). The list of active attribute variables may include both built-in attribute variables (which begin with the prefix &quot;gl_&quot;) as well as user-defined attribute variable names. This function will return as much information as it can about the specified active attribute variable. If no information is available, $(D_INLINECODE length) will be 0, and $(D_INLINECODE name) will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values $(D_INLINECODE length), $(D_INLINECODE size), $(D_INLINECODE type), and $(D_INLINECODE name) will be unmodified.
     + 
     + $(D_INLINECODE glGetActiveAttrib) is available only if the GL version is 2.0 or greater. $(D_INLINECODE GL_FLOAT_MAT2x3), $(D_INLINECODE GL_FLOAT_MAT2x4), $(D_INLINECODE GL_FLOAT_MAT3x2), $(D_INLINECODE GL_FLOAT_MAT3x4), $(D_INLINECODE GL_FLOAT_MAT4x2), and $(D_INLINECODE GL_FLOAT_MAT4x3) will only be returned as a $(D_INLINECODE type) if the GL version is 2.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) @system @nogc nothrow;

    /++
     + glEnableClientState: man2/glEnableClientState.xml
     + 
     + $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) enable or disable individual client-side capabilities. By default, all client-side capabilities are disabled. Both $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) take a single argument, $(D_INLINECODE cap), which can assume one of the following values:
     + 
     + $(D_INLINECODE glEnableClientState) is available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_FOG_COORD_ARRAY) and $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY) are available only if the GL version is 1.4 or greater. For OpenGL versions 1.3 and greater, or when $(D_INLINECODE ARB_multitexture) is supported, enabling and disabling $(D_INLINECODE GL_TEXTURE_COORD_ARRAY) affects the active client texture unit. The active client texture unit is controlled with $(D_INLINECODE glClientActiveTexture).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glEnable), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glEnableClientState(GLenum cap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glDisableClientState(GLenum cap) @system @nogc nothrow;

    /++
     + glRasterPos: man2/glRasterPos.xml
     + 
     + The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See $(D_INLINECODE glBitmap), $(D_INLINECODE glDrawPixels), and $(D_INLINECODE glCopyPixels). The current raster position consists of three window coordinates ( x, y, z ), a clip coordinate value ( w ), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a clip coordinate, because w is not projected to window coordinates. $(D_INLINECODE glRasterPos4) specifies object coordinates x, y, z, and w explicitly. $(D_INLINECODE glRasterPos3) specifies object coordinate x, y, and z explicitly, while w is implicitly set to 1. $(D_INLINECODE glRasterPos2) uses the argument values for x and y while implicitly setting z and w to 0 and 1. The object coordinates presented by $(D_INLINECODE glRasterPos) are treated just like those of a $(D_INLINECODE glVertex) command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the $(D_INLINECODE GL_CURRENT_RASTER_POSITION_VALID) flag is set. If the vertex culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined. The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then $(D_INLINECODE GL_CURRENT_RASTER_COLOR) (in RGBA mode) or $(D_INLINECODE GL_CURRENT_RASTER_INDEX) (in color index mode) is set to the color produced by the lighting calculation (see $(D_INLINECODE glLight), $(D_INLINECODE glLightModel), and $(D_INLINECODE glShadeModel) ). If lighting is disabled, current color (in RGBA mode, state variable $(D_INLINECODE GL_CURRENT_COLOR) ) or color index (in color index mode, state variable $(D_INLINECODE GL_CURRENT_INDEX) ) is used to update the current raster color. $(D_INLINECODE GL_CURRENT_RASTER_SECONDARY_COLOR) (in RGBA mode) is likewise updated. Likewise, $(D_INLINECODE GL_CURRENT_RASTER_TEXTURE_COORDS) is updated as a function of $(D_INLINECODE GL_CURRENT_TEXTURE_COORDS), based on the texture matrix and the texture generation functions (see $(D_INLINECODE glTexGen) ). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces $(D_INLINECODE GL_CURRENT_RASTER_DISTANCE). Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, $(D_INLINECODE GL_CURRENT_RASTER_INDEX) is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
     + 
     + The raster position is modified by $(D_INLINECODE glRasterPos), $(D_INLINECODE glBitmap), and $(D_INLINECODE glWindowPos). When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to GL state). Calling $(D_INLINECODE glDrawElements) or $(D_INLINECODE glDrawRangeElements) may leave the current color or index indeterminate. If $(D_INLINECODE glRasterPos) is executed while the current color or index is indeterminate, the current raster color or current raster index remains indeterminate. To set a valid raster position outside the viewport, first set a valid raster position, then call $(D_INLINECODE glBitmap) with null as the
     +  parameter. When the $(D_INLINECODE ARB_imaging) extension is supported, there are distinct raster texture coordinates for each texture unit. Each texture unit's current raster texture coordinates are updated by $(D_INLINECODE glRasterPos).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBitmap), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glTexCoord), $(D_INLINECODE glTexGen), $(D_INLINECODE glVertex), $(D_INLINECODE glWindowPos)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2s(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2i(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2f(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2d(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3s(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3i(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4i(GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos2dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glRasterPos4dv(const GLdouble* v) @system @nogc nothrow;

    /++
     + gluTessCallback: man2/gluTessCallback.xml
     + 
     + $(D_INLINECODE gluTessCallback) is used to indicate a callback to be used by a tessellation object. If the specified callback is already defined, then it is replaced. If $(D_INLINECODE CallBackFunc) is null, then the existing callback becomes undefined.
     +  These callbacks are used by the tessellation object to describe how a polygon specified by the user is broken into triangles. Note that there are two versions of each callback: one with user-specified polygon data and one without. If both versions of a particular callback are specified, then the callback with user-specified polygon data will be used. Note that the parameter used by some of the functions is a copy of the pointer that was specified when $(D_INLINECODE gluTessBeginPolygon) was called. The legal callbacks are as follows:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluErrorString), $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty), $(D_INLINECODE gluTessVertex), $(D_INLINECODE glBegin), $(D_INLINECODE glEdgeFlag), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluTessCallback(GLUtesselator* tess, GLenum which, _GLUfuncptr CallBackFunc) @system @nogc nothrow;

    /++
     + gluNurbsProperty: man2/gluNurbsProperty.xml
     + 
     + $(D_INLINECODE gluNurbsProperty) is used to control properties stored in a NURBS object. These properties affect the way that a NURBS curve is rendered. The accepted values for $(D_INLINECODE property) are as follows:
     + 
     + If $(D_INLINECODE GLU_AUTO_LOAD_MATRIX) is true, sampling and culling may be executed incorrectly if NURBS routines are compiled into a display list. A $(D_INLINECODE property) of $(D_INLINECODE GLU_PARAMETRIC_TOLERANCE), $(D_INLINECODE GLU_SAMPLING_METHOD), $(D_INLINECODE GLU_U_STEP), or $(D_INLINECODE GLU_V_STEP), or a $(D_INLINECODE value) of $(D_INLINECODE GLU_PATH_LENGTH), $(D_INLINECODE GLU_PARAMETRIC_ERROR), $(D_INLINECODE GLU_DOMAIN_DISTANCE) are only available if the GLU version is 1.1 or greater. They are not valid parameters in GLU 1.0. $(D_INLINECODE gluGetString) can be used to determine the GLU version. $(D_INLINECODE GLU_NURBS_MODE) is only available if the GLU version is 1.3 or greater. The $(D_INLINECODE GLU_OBJECT_PATH_LENGTH) and $(D_INLINECODE GLU_OBJECT_PARAMETRIC_ERROR) values for the $(D_INLINECODE GLU_SAMPLING_METHOD) property are only available if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluGetNurbsProperty), $(D_INLINECODE gluGetString), $(D_INLINECODE gluLoadSamplingMatrices), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluNurbsProperty(GLUnurbs* nurb, GLenum property, GLfloat value) @system @nogc nothrow;

    /++
     + glGenBuffers: man2/glGenBuffers.xml
     + 
     + $(D_INLINECODE glGenBuffers) returns $(D_INLINECODE n) buffer object names in $(D_INLINECODE buffers). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenBuffers). Buffer object names returned by a call to $(D_INLINECODE glGenBuffers) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteBuffers). No buffer objects are associated with the returned buffer object names until they are first bound by calling $(D_INLINECODE glBindBuffer).
     + 
     + $(D_INLINECODE glGenBuffers) is available only if the GL version is 1.5 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGenBuffers(GLsizei n, GLuint* buffers) @system @nogc nothrow;

    /++
     + glViewport: man2/glViewport.xml
     + 
     + $(D_INLINECODE glViewport) specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window coordinates x w y w are computed as follows: x w = x nd + 1 &it; width 2 + x y w = y nd + 1 &it; height 2 + y Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_VIEWPORT_DIMS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glViewport(GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + gluLoadSamplingMatrices: man2/gluLoadSamplingMatrices.xml
     + 
     + $(D_INLINECODE gluLoadSamplingMatrices) uses $(D_INLINECODE model), $(D_INLINECODE perspective), and $(D_INLINECODE view) to recompute the sampling and culling matrices stored in $(D_INLINECODE nurb). The sampling matrix determines how finely a NURBS curve or surface must be tessellated to satisfy the sampling tolerance (as determined by the $(D_INLINECODE GLU_SAMPLING_TOLERANCE) property). The culling matrix is used in deciding if a NURBS curve or surface should be culled before rendering (when the $(D_INLINECODE GLU_CULLING) property is turned on). $(D_INLINECODE gluLoadSamplingMatrices) is necessary only if the $(D_INLINECODE GLU_AUTO_LOAD_MATRIX) property is turned off (see $(D_INLINECODE gluNurbsProperty) ). Although it can be convenient to leave the $(D_INLINECODE GLU_AUTO_LOAD_MATRIX) property turned on, there can be a performance penalty for doing so. (A round trip to the GL server is needed to fetch the current values of the modelview matrix, projection matrix, and viewport.)
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluGetNurbsProperty), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluLoadSamplingMatrices(GLUnurbs* nurb, const GLfloat* model, const GLfloat* perspective, const GLint* view) @system @nogc nothrow;

    /++
     + glCompressedTexSubImage1D: man2/glCompressedTexSubImage1D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.  To enable and disable one-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_1D). $(D_INLINECODE glCompressedTexSubImage1D) redefines a contiguous subregion of an existing one-dimensional texture image.  The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive.  This region may not include any texels outside the range of the texture array as it was originally specified.  It is not an error to specify a subtexture with width of 0, but such a specification has no effect. $(D_INLINECODE format) must be an extension-specified compressed-texture format.  The $(D_INLINECODE format) of the compressed texture image is selected by the GL implementation that compressed it (see $(D_INLINECODE glTexImage1D) ), and should be queried at the time the texture was compressed with $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glCompressedTexSubImage1D) is available only if the GL version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glColorTable), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;

    /++
     + glCompileShader: man2/glCompileShader.xml
     + 
     + $(D_INLINECODE glCompileShader) compiles the source code strings that have been stored in the shader object specified by $(D_INLINECODE shader). The compilation status will be stored as part of the shader object's state. This value will be set to $(D_INLINECODE GL_TRUE) if the shader was compiled without errors and is ready for use, and $(D_INLINECODE GL_FALSE) otherwise. It can be queried by calling $(D_INLINECODE glGetShader) with arguments $(D_INLINECODE shader) and $(D_INLINECODE GL_COMPILE_STATUS). Compilation of a shader can fail for a number of reasons as specified by the OpenGL Shading Language Specification. Whether or not the compilation was successful, information about the compilation can be obtained from the shader object's information log by calling $(D_INLINECODE glGetShaderInfoLog).
     + 
     + $(D_INLINECODE glCompileShader) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glCompileShader(GLuint shader) @system @nogc nothrow;

    /++
     + glLoadMatrix: man2/glLoadMatrix.xml
     + 
     + $(D_INLINECODE glLoadMatrix) replaces the current matrix with the one whose elements are specified by $(D_INLINECODE m). The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix mode (see $(D_INLINECODE glMatrixMode) ). The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview matrix. If v = v &af; 0 v &af; 1 v &af; 2 v &af; 3 is the set of object coordinates of a vertex, and $(D_INLINECODE m) points to an array of 16 single- or double-precision floating-point values m = m &af; 0 m &af; 1... m &af; 15, then the modelview transformation M &af; v does the following: M &af; v = m &af; 0 m &af; 4 m &af; 8 m &af; 12 m &af; 1 m &af; 5 m &af; 9 m &af; 13 m &af; 2 m &af; 6 m &af; 10 m &af; 14 m &af; 3 m &af; 7 m &af; 11 m &af; 15 &times; v &af; 0 v &af; 1 v &af; 2 v &af; 3 Projection and texture transformations are similarly defined.
     + 
     + While the elements of the matrix may be specified with single or double precision, the GL implementation may store or operate on these values in less than single precision.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLoadMatrixd(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLoadMatrixf(const GLfloat* m) @system @nogc nothrow;

    /++
     + gluBuild2DMipmaps: man2/gluBuild2DMipmaps.xml
     + 
     + $(D_INLINECODE gluBuild2DMipmaps) builds a series of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture-mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). Initially, the $(D_INLINECODE width) and $(D_INLINECODE height) of $(D_INLINECODE data) are checked to see if they are a power of 2. If not, a copy of $(D_INLINECODE data) (not $(D_INLINECODE data) ), is scaled up or down to the nearest power of 2. This copy will be used for subsequent mipmapping operations described below. (If $(D_INLINECODE width) or $(D_INLINECODE height) is exactly between powers of 2, then the copy of $(D_INLINECODE data) will scale upwards.)  For example, if $(D_INLINECODE width) is 57 and $(D_INLINECODE height) is 23, then a copy of $(D_INLINECODE data) will scale up to 64 in $(D_INLINECODE width) and down to 16 in depth, before mipmapping takes place. Then, proxy textures (see $(D_INLINECODE glTexImage2D) ) are used to determine if the implementation can fit the requested texture. If not, both dimensions are continually halved until it fits. (If the OpenGL version is \(&lt;= 1.0, both maximum texture dimensions are clamped to the value returned by $(D_INLINECODE glGetIntegerv) with the argument $(D_INLINECODE GLU_MAX_TEXTURE_SIZE).) Next, a series of mipmap levels is built by decimating a copy of $(D_INLINECODE data) in half along both dimensions until size 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding four texels in the larger mipmap level. (In the case of rectangular images, the decimation will ultimately reach an N &times; 1 or 1 &times; N configuration. Here, two texels are averaged instead.) $(D_INLINECODE glTexImage2D) is called to load each of these mipmap levels. Level 0 is a copy of $(D_INLINECODE data).  The highest level is log 2 &af; max &af; width height. For example, if $(D_INLINECODE width) is 64 and $(D_INLINECODE height) is 16 and the implementation can store a texture of this size, the following mipmap levels are built: 64 &times; 16, 32 &times; 8, 16 &times; 4, 8 &times; 2, 4 &times; 1, 2 &times; 1, and 1 &times; 1 These correspond to levels 0 through 6, respectively. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE format) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter.
     + 
     + Note that there is no direct way of querying the maximum level. This can be derived indirectly via $(D_INLINECODE glGetTexLevelParameter). First, query for the width and height actually used at level 0.  (The width and height may not be equal to $(D_INLINECODE width) and $(D_INLINECODE height) respectively since proxy textures might have scaled them to fit the implementation.)  Then the maximum level can be derived from the formula log 2 &af; max &af; width height. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater and if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* data) @system @nogc nothrow;

    /++
     + glGetError: man2/glGetError.xml
     + 
     + $(D_INLINECODE glGetError) returns the value of the error flag. Each detectable error is assigned a numeric code and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until $(D_INLINECODE glGetError) is called, the error code is returned, and the flag is reset to $(D_INLINECODE GL_NO_ERROR). If a call to $(D_INLINECODE glGetError) returns $(D_INLINECODE GL_NO_ERROR), there has been no detectable error since the last call to $(D_INLINECODE glGetError), or since the GL was initialized. To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to $(D_INLINECODE GL_NO_ERROR) when $(D_INLINECODE glGetError) is called. If more than one flag has recorded an error, $(D_INLINECODE glGetError) returns and clears an arbitrary error flag value. Thus, $(D_INLINECODE glGetError) should always be called in a loop, until it returns $(D_INLINECODE GL_NO_ERROR), if all error flags are to be reset. Initially, all error flags are set to $(D_INLINECODE GL_NO_ERROR). The following errors are currently defined: When an error flag is set, results of a GL operation are undefined only if $(D_INLINECODE GL_OUT_OF_MEMORY) has occurred. In all other cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents. If the generating command returns a value, it returns 0. If $(D_INLINECODE glGetError) itself generates an error, it returns 0.
     + 
     + $(D_INLINECODE GL_TABLE_TOO_LARGE) was introduced in GL version 1.2.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLenum glGetError() @system @nogc nothrow;

    /++
     + glCopyPixels: man2/glCopyPixels.xml
     + 
     + $(D_INLINECODE glCopyPixels) copies a screen-aligned rectangle of pixels from the specified frame buffer location to a region relative to the current raster position. Its operation is well defined only if the entire pixel source region is within the exposed portion of the window. Results of copies from outside the window, or from regions of the window that are not exposed, are hardware dependent and undefined. $(D_INLINECODE x) and $(D_INLINECODE y) specify the window coordinates of the lower left corner of the rectangular region to be copied. $(D_INLINECODE width) and $(D_INLINECODE height) specify the dimensions of the rectangular region to be copied. Both $(D_INLINECODE width) and $(D_INLINECODE height) must not be negative. Several parameters control the processing of the pixel data while it is being copied. These parameters are set with three commands: $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPixelMap), and $(D_INLINECODE glPixelZoom). This reference page describes the effects on $(D_INLINECODE glCopyPixels) of most, but not all, of the parameters specified by these three commands. $(D_INLINECODE glCopyPixels) copies values from each pixel with the lower left-hand corner at x + i y + j for 0 &lt;= i &lt; width and 0 &lt;= j &lt; height. This pixel is said to be the i th pixel in the j th row. Pixels are copied in row order from the lowest to the highest row, left to right in each row. $(D_INLINECODE type) specifies whether color, depth, or stencil data is to be copied. The details of the transfer for each data type are as follows: The rasterization described thus far assumes pixel zoom factors of 1.0. If $(D_INLINECODE glPixelZoom) is used to change the x and y pixel zoom factors, pixels are converted to fragments as follows. If x r y r is the current raster position, and a given pixel is in the i th location in the j th row of the source pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at x r + zoom x &it; i y r + zoom y &it; j and x r + zoom x &af; i + 1 y r + zoom y &af; j + 1 where zoom x is the value of $(D_INLINECODE GL_ZOOM_X) and zoom y is the value of $(D_INLINECODE GL_ZOOM_Y).
     + 
     + Modes specified by $(D_INLINECODE glPixelStore) have no effect on the operation of $(D_INLINECODE glCopyPixels).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPixelZoom), $(D_INLINECODE glRasterPos), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glReadPixels), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glWindowPos)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) @system @nogc nothrow;

    /++
     + glColorMaterial: man2/glColorMaterial.xml
     + 
     + $(D_INLINECODE glColorMaterial) specifies which material parameters track the current color. When $(D_INLINECODE GL_COLOR_MATERIAL) is enabled, the material parameter or parameters specified by $(D_INLINECODE mode), of the material or materials specified by $(D_INLINECODE face), track the current color at all times. To enable and disable $(D_INLINECODE GL_COLOR_MATERIAL), call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_COLOR_MATERIAL). $(D_INLINECODE GL_COLOR_MATERIAL) is initially disabled.
     + 
     + $(D_INLINECODE glColorMaterial) makes it possible to change a subset of material parameters for each vertex using only the $(D_INLINECODE glColor) command, without calling $(D_INLINECODE glMaterial). If only such a subset of parameters is to be specified for each vertex, calling $(D_INLINECODE glColorMaterial) is preferable to calling $(D_INLINECODE glMaterial). Call $(D_INLINECODE glColorMaterial) before enabling $(D_INLINECODE GL_COLOR_MATERIAL). Calling $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawArrays), or $(D_INLINECODE glDrawRangeElements) may leave the current color indeterminate, if the color array is enabled. If $(D_INLINECODE glColorMaterial) is enabled while the current color is indeterminate, the lighting material state specified by $(D_INLINECODE face) and $(D_INLINECODE mode) is also indeterminate. If the GL version is 1.1 or greater, and $(D_INLINECODE GL_COLOR_MATERIAL) is enabled, evaluated color values affect the results of the lighting equation as if the current color were being modified, but no change is made to the tracking lighting parameter of the current color.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColor), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEnable), $(D_INLINECODE glLight), $(D_INLINECODE glLightModel), $(D_INLINECODE glMaterial)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glColorMaterial(GLenum face, GLenum mode) @system @nogc nothrow;

    /++
     + gluTessVertex: man2/gluTessVertex.xml
     + 
     + $(D_INLINECODE gluTessVertex) describes a vertex on a polygon that the program defines. Successive $(D_INLINECODE gluTessVertex) calls describe a closed contour. For example, to describe a quadrilateral, $(D_INLINECODE gluTessVertex) should be called four times. $(D_INLINECODE gluTessVertex) can only be called between $(D_INLINECODE gluTessBeginContour) and $(D_INLINECODE gluTessEndContour). $(D_INLINECODE data) normally points to a structure containing the vertex location, as well as other per-vertex attributes such as color and normal. This pointer is passed back to the user through the $(D_INLINECODE GLU_TESS_VERTEX) or $(D_INLINECODE GLU_TESS_VERTEX_DATA) callback after tessellation (see the $(D_INLINECODE gluTessCallback) reference page).
     + 
     + It is a common error to use a local variable for $(D_INLINECODE location) or $(D_INLINECODE data) and store values into it as part of a loop. For example:
     + 
     + ---
     + for (i = 0; i &lt; NVERTICES; ++i) {
     +    GLdouble data[3];
     +    data[0] = vertex[i][0];
     +    data[1] = vertex[i][1];
     +    data[2] = vertex[i][2];
     +    gluTessVertex(tobj, data, data);
     + }
     +         
     + ---
     +  This doesn't work. Because the pointers specified by $(D_INLINECODE location) and $(D_INLINECODE data) might not be dereferenced until $(D_INLINECODE gluTessEndPolygon) is executed, all the vertex coordinates but the very last set could be overwritten before tessellation begins. Two common symptoms of this problem are when the data consists of a single point (when a local variable is used for $(D_INLINECODE data) ) and a $(D_INLINECODE GLU_TESS_NEED_COMBINE_CALLBACK) error (when a local variable is used for $(D_INLINECODE location) ).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessEndPolygon), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluTessVertex(GLUtesselator* tess, GLdouble* location, GLvoid* data) @system @nogc nothrow;

    /++
     + gluGetString: man2/gluGetString.xml
     + 
     + $(D_INLINECODE gluGetString) returns a pointer to a static string describing the GLU version or the GLU extensions that are supported. The version number is one of the following forms:. The version string is of the following form: Vendor-specific information is optional. Its format and contents depend on the implementation. The standard GLU contains a basic set of features and capabilities. If a company or group of companies wish to support other features, these may be included as extensions to the GLU. If $(D_INLINECODE name) is $(D_INLINECODE GLU_EXTENSIONS), then $(D_INLINECODE gluGetString) returns a space-separated list of names of supported GLU extensions. (Extension names never contain spaces.) All strings are null-terminated.
     + 
     + $(D_INLINECODE gluGetString) only returns information about GLU extensions. Call $(D_INLINECODE glGetString) to get a list of GL extensions. $(D_INLINECODE gluGetString) is an initialization routine. Calling it after a $(D_INLINECODE glNewList) results in undefined behavior.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetString)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    const(GLubyte)* gluGetString(GLenum name) @system @nogc nothrow;

    /++
     + glCompressedTexSubImage2D: man2/glCompressedTexSubImage2D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.  To enable and disable two-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_2D).   To enable and disable texturing using cube-mapped texture, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_CUBE_MAP). $(D_INLINECODE glCompressedTexSubImage2D) redefines a contiguous subregion of an existing two-dimensional texture image.  The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, and the y indices $(D_INLINECODE yoffset) and yoffset + height - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified.  It is not an error to specify a subtexture with width of 0, but such a specification has no effect. $(D_INLINECODE format) must be an extension-specified compressed-texture format.  The $(D_INLINECODE format) of the compressed texture image is selected by the GL implementation that compressed it (see $(D_INLINECODE glTexImage2D) ) and should be queried at the time the texture was compressed with $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glCompressedTexSubImage2D) is available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP) are available only if the GL version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glColorTable), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;

    /++
     + glPolygonMode: man2/glPolygonMode.xml
     + 
     + $(D_INLINECODE glPolygonMode) controls the interpretation of polygons for rasterization. $(D_INLINECODE face) describes which polygons $(D_INLINECODE mode) applies to: front-facing polygons ( $(D_INLINECODE GL_FRONT) ), back-facing polygons ( $(D_INLINECODE GL_BACK) ), or both ( $(D_INLINECODE GL_FRONT_AND_BACK) ). The polygon mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied. Three modes are defined and can be specified in $(D_INLINECODE mode) :
     + 
     + Vertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated internally by the GL when it decomposes polygons; they can be set explicitly using $(D_INLINECODE glEdgeFlag).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glEdgeFlag), $(D_INLINECODE glLineStipple), $(D_INLINECODE glLineWidth), $(D_INLINECODE glPointSize), $(D_INLINECODE glPolygonStipple)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glPolygonMode(GLenum face, GLenum mode) @system @nogc nothrow;

    /++
     + glCopyTexSubImage3D: man2/glCopyTexSubImage3D.xml
     + 
     + $(D_INLINECODE glCopyTexSubImage3D) replaces a rectangular portion of a three-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glTexSubImage3D) ). The screen-aligned pixel rectangle with lower left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ) and with width $(D_INLINECODE width) and height $(D_INLINECODE height) replaces the portion of the texture array with x indices $(D_INLINECODE xoffset) through xoffset + width - 1, inclusive, and y indices $(D_INLINECODE yoffset) through yoffset + height - 1, inclusive, at z index $(D_INLINECODE zoffset) and at the mipmap level specified by $(D_INLINECODE level). The pixels in the rectangle are processed exactly as if $(D_INLINECODE glCopyPixels) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect. If any of the pixels within the specified rectangle of the current $(D_INLINECODE GL_READ_BUFFER) are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the,,,, or parameters of the specified texture array or to texel values outside the specified subregion.
     + 
     + $(D_INLINECODE glCopyTexSubImage3D) is available only if the GL version is 1.2 or greater. Texturing has no effect in color index mode. $(D_INLINECODE glPixelStore) and $(D_INLINECODE glPixelTransfer) modes affect texture images in exactly the way they affect $(D_INLINECODE glDrawPixels). When the $(D_INLINECODE ARB_imaging) extension is supported, the RGBA components copied from the framebuffer may be processed by the imaging pipeline, as if they were a two-dimensional texture.  See $(D_INLINECODE glTexImage2D) for specific details.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glCopyConvolutionFilter2D: man2/glCopyConvolutionFilter2D.xml
     + 
     + $(D_INLINECODE glCopyConvolutionFilter2D) defines a two-dimensional convolution filter kernel with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glConvolutionFilter2D) ). The screen-aligned pixel rectangle with lower-left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ), width $(D_INLINECODE width) and height $(D_INLINECODE height) is used to define the convolution filter. If any pixels within this region are outside the window that is associated with the GL context, the values obtained for those pixels are undefined. The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called with set to RGBA, but the process stops just before final conversion. The R, G, B, and A components of each pixel are next scaled by the four 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_CONVOLUTION_2D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. Pixel ordering is such that lower x screen coordinates correspond to lower filter image coordinates, and lower y screen coordinates correspond to lower filter image coordinates. Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glCopyConvolutionFilter2D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + gluTessProperty: man2/gluTessProperty.xml
     + 
     + $(D_INLINECODE gluTessProperty) is used to control properties stored in a tessellation object. These properties affect the way that the polygons are interpreted and rendered. The legal values for $(D_INLINECODE which) are as follows:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluGetTessProperty), $(D_INLINECODE gluNewTess)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluTessProperty(GLUtesselator* tess, GLenum which, GLdouble data) @system @nogc nothrow;

    /++
     + gluTessEndPolygon: man2/gluTessEndPolygon.xml
     + 
     + $(D_INLINECODE gluTessBeginPolygon) and $(D_INLINECODE gluTessEndPolygon) delimit the definition of a convex, concave, or self-intersecting polygon. Within each $(D_INLINECODE gluTessBeginPolygon) / $(D_INLINECODE gluTessEndPolygon) pair, there must be one or more calls to $(D_INLINECODE gluTessBeginContour) / $(D_INLINECODE gluTessEndContour). Within each contour, there are zero or more calls to $(D_INLINECODE gluTessVertex). The vertices specify a closed contour (the last vertex of each contour is automatically linked to the first). See the $(D_INLINECODE gluTessVertex), $(D_INLINECODE gluTessBeginContour), and $(D_INLINECODE gluTessEndContour) reference pages for more details. Once $(D_INLINECODE gluTessEndPolygon) is called, the polygon is tessellated, and the resulting triangles are described through callbacks. See $(D_INLINECODE gluTessCallback) for descriptions of the callback functions.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluTessEndPolygon(GLUtesselator* tess) @system @nogc nothrow;

    /++
     + glColorSubTable: man2/glColorSubTable.xml
     + 
     + $(D_INLINECODE glColorSubTable) is used to respecify a contiguous portion of a color table previously defined using $(D_INLINECODE glColorTable).  The pixels referenced by $(D_INLINECODE data) replace the portion of the existing table from indices $(D_INLINECODE start) to start + count - 1, inclusive.  This region may not include any entries outside the range of the color table as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a portion of a color table is respecified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glColorSubTable) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glColorTableParameter), $(D_INLINECODE glCopyColorTable), $(D_INLINECODE glCopyColorSubTable), $(D_INLINECODE glGetColorTable)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + gluNewQuadric: man2/gluNewQuadric.xml
     + 
     + $(D_INLINECODE gluNewQuadric) creates and returns a pointer to a new quadrics object. This object must be referred to when calling quadrics rendering and control functions. A return value of 0 means that there is not enough memory to allocate the object.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluCylinder), $(D_INLINECODE gluDeleteQuadric), $(D_INLINECODE gluDisk), $(D_INLINECODE gluPartialDisk), $(D_INLINECODE gluQuadricCallback), $(D_INLINECODE gluQuadricDrawStyle), $(D_INLINECODE gluQuadricNormals), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture), $(D_INLINECODE gluSphere)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLUquadric* gluNewQuadric() @system @nogc nothrow;

    /++
     + glEvalPoint: man2/glEvalPoint.xml
     + 
     + $(D_INLINECODE glMapGrid) and $(D_INLINECODE glEvalMesh) are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. $(D_INLINECODE glEvalPoint) can be used to evaluate a single grid point in the same gridspace that is traversed by $(D_INLINECODE glEvalMesh). Calling $(D_INLINECODE glEvalPoint1) is equivalent to calling
     + 
     + ---
     + glEvalCoord1(  i &CenterDot; &Delta; u + u 1);
     +      
     + ---
     +  where &Delta; u = u 2 - u 1 n and n, u 1, and u 2 are the arguments to the most recent $(D_INLINECODE glMapGrid1) command. The one absolute numeric requirement is that if i = n, then the value computed from i &CenterDot; &Delta; u + u 1 is exactly u 2. In the two-dimensional case, $(D_INLINECODE glEvalPoint2), let &Delta; u = u 2 - u 1 n &Delta; v = v 2 - v 1 m where n, u 1, u 2, m, v 1, and v 2 are the arguments to the most recent $(D_INLINECODE glMapGrid2) command. Then the $(D_INLINECODE glEvalPoint2) command is equivalent to calling
     + 
     + ---
     + glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     +         
     + ---
     +  The only absolute numeric requirements are that if i = n, then the value computed from i &CenterDot; &Delta; u + u 1 is exactly u 2, and if j = m, then the value computed from j &CenterDot; &Delta; v + v 1 is exactly v 2.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2), $(D_INLINECODE glMapGrid)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalPoint1(GLint i) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalPoint2(GLint i, GLint j) @system @nogc nothrow;

    /++
     + gluDeleteTess: man2/gluDeleteTess.xml
     + 
     + $(D_INLINECODE gluDeleteTess) destroys the indicated tessellation object (which was created with $(D_INLINECODE gluNewTess) ) and frees any memory that it used.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginPolygon), $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void gluDeleteTess(GLUtesselator* tess) @system @nogc nothrow;

    /++
     + gluErrorString: man2/gluErrorString.xml
     + 
     + $(D_INLINECODE gluErrorString) produces an error string from a GL or GLU error code. The string is in ISO Latin 1 format. For example, $(D_INLINECODE gluErrorString) ( $(D_INLINECODE GLU_OUT_OF_MEMORY) ) returns the string. The standard GLU error codes are $(D_INLINECODE GLU_INVALID_ENUM), $(D_INLINECODE GLU_INVALID_VALUE), and $(D_INLINECODE GLU_OUT_OF_MEMORY). Certain other GLU functions can return specialized error codes through callbacks. See the $(D_INLINECODE glGetError) reference page for the list of GL error codes.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNurbsCallback), $(D_INLINECODE gluQuadricCallback), $(D_INLINECODE gluTessCallback), $(D_INLINECODE glGetError)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    const(GLubyte)* gluErrorString(GLenum error) @system @nogc nothrow;

    /++
     + glGetQueryObject: man2/glGetQueryObject.xml
     + 
     + $(D_INLINECODE glGetQueryObject) returns in $(D_INLINECODE params) a selected parameter of the query object specified by $(D_INLINECODE id). $(D_INLINECODE pname) names a specific query object parameter. $(D_INLINECODE pname) can be as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE glGetQueryObject) implicitly flushes the GL pipeline so that any incomplete rendering delimited by the occlusion query completes in finite time. If multiple queries are issued using the same query object $(D_INLINECODE id) before calling $(D_INLINECODE glGetQueryObject), the results of the most recent query will be returned.  In this case, when issuing a new query, the results of the previous query are discarded. $(D_INLINECODE glGetQueryObject) is available only if the GL version is 1.5 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetQueryObjectiv(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;

    /++
     + glBeginQuery: man2/glBeginQuery.xml
     + 
     + $(D_INLINECODE glBeginQuery) and $(D_INLINECODE glEndQuery) delimit the boundaries of a query object.  If a query object with name $(D_INLINECODE id) does not yet exist it is created. When $(D_INLINECODE glBeginQuery) is executed, the query object's samples-passed counter is reset to 0.  Subsequent rendering will increment the counter once for every sample that passes the depth test.  When $(D_INLINECODE glEndQuery) is executed, the samples-passed counter is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). Querying the $(D_INLINECODE GL_QUERY_RESULT) implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. $(D_INLINECODE GL_QUERY_RESULT_AVAILABLE) can be queried to determine if the result is immediately available or if the rendering is not yet complete.
     + 
     + If the samples-passed count exceeds the maximum value representable in the number of available bits, as reported by $(D_INLINECODE glGetQueryiv) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_COUNTER_BITS), the count becomes undefined. An implementation may support 0 bits in its samples-passed counter, in which case query results are always undefined and essentially useless. When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 0, the samples-passed counter will increment once for each fragment that passes the depth test.  When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test. $(D_INLINECODE glBeginQuery) and $(D_INLINECODE glEndQuery) are available only if the GL version is 1.5 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2005 Addison-Wesley. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glBeginQuery(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    void glEndQuery(GLenum target) @system @nogc nothrow;

    /++
     + glGetUniform: man2/glGetUniform.xml
     + 
     + $(D_INLINECODE glGetUniform) returns in $(D_INLINECODE params) the value(s) of the specified uniform variable. The type of the uniform variable specified by $(D_INLINECODE location) determines the number of values returned. If the uniform variable is defined in the shader as a boolean, int, or float, a single value will be returned. If it is defined as a vec2, ivec2, or bvec2, two values will be returned. If it is defined as a vec3, ivec3, or bvec3, three values will be returned, and so on. To query values stored in uniform variables declared as arrays, call $(D_INLINECODE glGetUniform) for each element of the array. To query values stored in uniform variables declared as structures, call $(D_INLINECODE glGetUniform) for each field in the structure. The values for uniform variables declared as a matrix will be returned in column major order. The locations assigned to uniform variables are not known until the program object is linked. After linking has occurred, the command $(D_INLINECODE glGetUniformLocation) can be used to obtain the location of a uniform variable. This location value can then be passed to $(D_INLINECODE glGetUniform) in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. The uniform variable values can only be queried after a link if the link was successful.
     + 
     + $(D_INLINECODE glGetUniform) is available only if the GL version is 2.0 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetUniformfv(GLuint program, GLint location, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetUniformiv(GLuint program, GLint location, GLint* params) @system @nogc nothrow;

    /++
     + glBindAttribLocation: man2/glBindAttribLocation.xml
     + 
     + $(D_INLINECODE glBindAttribLocation) is used to associate a user-defined attribute variable in the program object specified by $(D_INLINECODE program) with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in $(D_INLINECODE name). The generic vertex attribute index to be bound to this variable is specified by $(D_INLINECODE index). When $(D_INLINECODE program) is made part of current state, values provided via the generic vertex attribute $(D_INLINECODE index) will modify the value of the user-defined attribute variable specified by $(D_INLINECODE name). If $(D_INLINECODE name) refers to a matrix attribute variable, $(D_INLINECODE index) refers to the first column of the matrix. Other matrix columns are then automatically bound to locations $(D_INLINECODE index+1) for a matrix of type mat2; $(D_INLINECODE index+1) and $(D_INLINECODE index+2) for a matrix of type mat3; and $(D_INLINECODE index+1), $(D_INLINECODE index+2), and $(D_INLINECODE index+3) for a matrix of type mat4. This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from 0 to $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS) -1. The values sent to each generic attribute index are part of current state, just like standard vertex attributes such as color, normal, and vertex position. If a different program object is made current by calling $(D_INLINECODE glUseProgram), the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to $(D_INLINECODE index). Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling $(D_INLINECODE glBindAttribLocation). Attribute bindings do not go into effect until $(D_INLINECODE glLinkProgram) is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs. Applications are not allowed to bind any of the standard OpenGL vertex attributes using this command, as they are bound automatically when needed. Any attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.
     + 
     + $(D_INLINECODE glBindAttribLocation) is available only if the GL version is 2.0 or greater. $(D_INLINECODE glBindAttribLocation) can be called before any vertex shader objects are bound to the specified program object. It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader. If $(D_INLINECODE name) was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices, but you can bind multiple user-defined attribute variables to the same index. Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index. This is called, and it is allowed only if just one of the aliased attributes is active in the executable program, or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location. The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing. Because there is no way to bind standard attributes, it is not possible to alias generic attributes with conventional ones (except for generic attribute 0). Active attributes that are not explicitly bound will be bound by the linker when $(D_INLINECODE glLinkProgram) is called. The locations assigned can be queried by calling $(D_INLINECODE glGetAttribLocation). OpenGL copies the $(D_INLINECODE name) string when $(D_INLINECODE glBindAttribLocation) is called, so an application may free its copy of the $(D_INLINECODE name) string immediately after the function returns.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDisableVertexAttribArray), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glUseProgram), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glBindAttribLocation(GLuint program, GLuint index, const GLchar* name) @system @nogc nothrow;

    /++
     + glTexImage3D: man2/glTexImage3D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable three-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_3D). To define texture images, call $(D_INLINECODE glTexImage3D). The arguments describe the parameters of the texture image, such as height, width, depth, width of the border, level-of-detail number (see $(D_INLINECODE glTexParameter) ), and number of color components provided. The last three arguments describe how the image is represented in memory; they are identical to the pixel formats used for $(D_INLINECODE glDrawPixels). If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_3D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_3D), data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on $(D_INLINECODE type). These values are grouped into sets of one, two, three, or four values, depending on $(D_INLINECODE format), to form elements. If $(D_INLINECODE type) is $(D_INLINECODE GL_BITMAP), the data is considered as a string of unsigned bytes (and $(D_INLINECODE format) must be $(D_INLINECODE GL_COLOR_INDEX) ). Each data byte is treated as eight 1-bit elements, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image. $(D_INLINECODE format) determines the composition of each element in $(D_INLINECODE data). It can assume one of these symbolic values: Refer to the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for the $(D_INLINECODE type) parameter. If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with $(D_INLINECODE internalFormat). The GL will choose an internal representation that closely approximates that requested by $(D_INLINECODE internalFormat), but it may not match exactly. (The representations specified by $(D_INLINECODE GL_LUMINANCE), $(D_INLINECODE GL_LUMINANCE_ALPHA), $(D_INLINECODE GL_RGB), and $(D_INLINECODE GL_RGBA) must match exactly. The numeric values 1, 2, 3, and 4 may also be used to specify the above representations.) If the $(D_INLINECODE internalFormat) parameter is one of the generic compressed formats, $(D_INLINECODE GL_COMPRESSED_ALPHA), $(D_INLINECODE GL_COMPRESSED_INTENSITY), $(D_INLINECODE GL_COMPRESSED_LUMINANCE), $(D_INLINECODE GL_COMPRESSED_LUMINANCE_ALPHA), $(D_INLINECODE GL_COMPRESSED_RGB), or $(D_INLINECODE GL_COMPRESSED_RGBA), the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format. If the $(D_INLINECODE internalFormat) parameter is $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_SLUMINANCE), $(D_INLINECODE GL_SLUMINANCE8), $(D_INLINECODE GL_SLUMINANCE_ALPHA), or $(D_INLINECODE GL_SLUMINANCE8_ALPHA8), the texture is treated as if the red, green, blue, or luminance components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component c s to a linear component c l is: c l = { c s 12.92 if c s &le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the $(D_INLINECODE GL_PROXY_TEXTURE_3D) target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call $(D_INLINECODE glGetTexLevelParameter). If the texture cannot be accommodated, texture state is set to 0. A one-component texture image uses only the red component of the RGBA color extracted from $(D_INLINECODE data). A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
     + 
     + Texturing has no effect in color index mode. The texture image can be represented by the same data formats as the pixels in a $(D_INLINECODE glDrawPixels) command, except that $(D_INLINECODE GL_STENCIL_INDEX) and $(D_INLINECODE GL_DEPTH_COMPONENT) cannot be used. $(D_INLINECODE glPixelStore) and $(D_INLINECODE glPixelTransfer) modes affect texture images in exactly the way they affect $(D_INLINECODE glDrawPixels). $(D_INLINECODE glTexImage3D) is available only if the GL version is 1.2 or greater. Internal formats other than 1, 2, 3, or 4 may be used only if the GL version is 1.1 or greater. $(D_INLINECODE data) may be a null pointer. In this case texture memory is allocated to accommodate a texture of width $(D_INLINECODE width), height $(D_INLINECODE height), and depth $(D_INLINECODE depth). You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive. Formats $(D_INLINECODE GL_BGR), and $(D_INLINECODE GL_BGRA) and types $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) are available only if the GL version is 1.2 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexImage3D) specifies the three-dimensional texture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). If the $(D_INLINECODE ARB_imaging) extension is supported, RGBA elements may also be processed by the imaging pipeline.  The following stages may be applied to an RGBA color before color component clamping to the range 0 1 : Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the $(D_INLINECODE GL_ARB_texture_non_power_of_two) extension. The $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_SLUMINANCE), $(D_INLINECODE GL_SLUMINANCE8), $(D_INLINECODE GL_SLUMINANCE_ALPHA), and $(D_INLINECODE GL_SLUMINANCE8_ALPHA8) internal formats are only available if the GL version is 2.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glColorTable), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glGetProgram: man2/glGetProgram.xml
     + 
     + $(D_INLINECODE glGetProgram) returns in $(D_INLINECODE params) the value of a parameter for a specific program object. The following parameters are defined:
     + 
     + $(D_INLINECODE glGetProgram) is available only if the GL version is 2.0 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glGetShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glGetProgramiv(GLuint program, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glDrawPixels: man2/glDrawPixels.xml
     + 
     + $(D_INLINECODE glDrawPixels) reads pixel data from memory and writes it into the frame buffer relative to the current raster position, provided that the raster position is valid.  Use $(D_INLINECODE glRasterPos) or $(D_INLINECODE glWindowPos) to set the current raster position; use $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_CURRENT_RASTER_POSITION_VALID) to determine if the specified raster position is valid, and $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_CURRENT_RASTER_POSITION) to query the raster position. Several parameters define the encoding of pixel data in memory and control the processing of the pixel data before it is placed in the frame buffer. These parameters are set with four commands: $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPixelMap), and $(D_INLINECODE glPixelZoom). This reference page describes the effects on $(D_INLINECODE glDrawPixels) of many, but not all, of the parameters specified by these four commands. Data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or unsigned integers, or single-precision floating-point values, depending on $(D_INLINECODE type). When $(D_INLINECODE type) is one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), or $(D_INLINECODE GL_FLOAT) each of these bytes, shorts, integers, or floating-point values is interpreted as one color or depth component, or one index, depending on $(D_INLINECODE format). When $(D_INLINECODE type) is one of $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), or $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), each unsigned value is interpreted as containing all the components for a single pixel, with the color components arranged according to $(D_INLINECODE format). When $(D_INLINECODE type) is one of $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), or $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), each unsigned value is interpreted as containing all color components, specified by $(D_INLINECODE format), for a single pixel in a reversed order. Indices are always treated individually. Color components are treated as groups of one, two, three, or four values, again based on $(D_INLINECODE format). Both individual indices and groups of components are referred to as pixels. If $(D_INLINECODE type) is $(D_INLINECODE GL_BITMAP), the data must be unsigned bytes, and $(D_INLINECODE format) must be either $(D_INLINECODE GL_COLOR_INDEX) or $(D_INLINECODE GL_STENCIL_INDEX). Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). width &times; height pixels are read from memory, starting at location $(D_INLINECODE data). By default, these pixels are taken from adjacent memory locations, except that after all $(D_INLINECODE width) pixels are read, the read pointer is advanced to the next four-byte boundary. The four-byte row alignment is specified by $(D_INLINECODE glPixelStore) with argument $(D_INLINECODE GL_UNPACK_ALIGNMENT), and it can be set to one, two, four, or eight bytes. Other pixel store parameters specify different read pointer advancements, both before the first pixel is read and after all $(D_INLINECODE width) pixels are read. See the $(D_INLINECODE glPixelStore) reference page for details on these options. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a block of pixels is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The width &times; height pixels that are read from memory are each operated on in the same way, based on the values of several parameters specified by $(D_INLINECODE glPixelTransfer) and $(D_INLINECODE glPixelMap). The details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the format of the pixels, as specified by $(D_INLINECODE format). $(D_INLINECODE format) can assume one of 13 symbolic values: The following table summarizes the meaning of the valid constants for the parameter: $(B Type) $(B Corresponding Type) $(D_INLINECODE GL_UNSIGNED_BYTE) unsigned 8-bit integer $(D_INLINECODE GL_BYTE) signed 8-bit integer $(D_INLINECODE GL_BITMAP) single bits in unsigned 8-bit integers $(D_INLINECODE GL_UNSIGNED_SHORT) unsigned 16-bit integer $(D_INLINECODE GL_SHORT) signed 16-bit integer $(D_INLINECODE GL_UNSIGNED_INT) unsigned 32-bit integer $(D_INLINECODE GL_INT) 32-bit integer $(D_INLINECODE GL_FLOAT) single-precision floating-point $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2) unsigned 8-bit integer $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV) unsigned 8-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5) unsigned 16-bit integer $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV) unsigned 16-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4) unsigned 16-bit integer $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV) unsigned 16-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1) unsigned 16-bit integer $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV) unsigned 16-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8) unsigned 32-bit integer $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV) unsigned 32-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2) unsigned 32-bit integer $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) unsigned 32-bit integer with reversed component ordering The rasterization described so far assumes pixel zoom factors of 1. If $(D_INLINECODE glPixelZoom) is used to change the x and y pixel zoom factors, pixels are converted to fragments as follows. If x r y r is the current raster position, and a given pixel is in the n th column and m th row of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at x r + zoom x &it; n y r + zoom y &it; m x r + zoom x &af; n + 1 y r + zoom y &af; m + 1 where zoom x is the value of $(D_INLINECODE GL_ZOOM_X) and zoom y is the value of $(D_INLINECODE GL_ZOOM_Y).
     + 
     + $(D_INLINECODE GL_BGR) and $(D_INLINECODE GL_BGRA) are only valid for $(D_INLINECODE format) if the GL version is 1.2 or greater. $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) are only valid for $(D_INLINECODE type) if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glLogicOp), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPixelZoom), $(D_INLINECODE glRasterPos), $(D_INLINECODE glReadPixels), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glWindowPos)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* data) @system @nogc nothrow;

    /++
     + glShadeModel: man2/glShadeModel.xml
     + 
     + GL primitives can have either flat or smooth shading. Smooth shading, the default, causes the computed colors of vertices to be interpolated as the primitive is rasterized, typically assigning different colors to each resulting pixel fragment. Flat shading selects the computed color of just one vertex and assigns it to all the pixel fragments generated by rasterizing a single primitive. In either case, the computed color of a vertex is the result of lighting if lighting is enabled, or it is the current color at the time the vertex was specified if lighting is disabled. Flat and smooth shading are indistinguishable for points. Starting when $(D_INLINECODE glBegin) is issued and counting vertices and primitives from 1, the GL gives each flat-shaded line segment i the computed color of vertex i + 1, its second vertex. Counting similarly from 1, the GL gives each flat-shaded polygon the computed color of the vertex listed in the following table. This is the last vertex to specify the polygon in all cases except single polygons, where the first vertex specifies the flat-shaded color. $(B Primitive Type of Polygon i) $(B Vertex) Single polygon ( i == 1 ) 1 Triangle strip i + 2 Triangle fan i + 2 Independent triangle 3 &it; i Quad strip 2 &it; i + 2 Independent quad 4 &it; i Flat and smooth shading are specified by $(D_INLINECODE glShadeModel) with $(D_INLINECODE mode) set to $(D_INLINECODE GL_FLAT) and $(D_INLINECODE GL_SMOOTH), respectively.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glLight), $(D_INLINECODE glLightModel)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glShadeModel(GLenum mode) @system @nogc nothrow;

    /++
     + glDepthRange: man2/glDepthRange.xml
     + 
     + After clipping and division by, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. $(D_INLINECODE glDepthRange) specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by $(D_INLINECODE glDepthRange) are both clamped to this range before they are accepted. The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
     + 
     + It is not necessary that $(D_INLINECODE nearVal) be less than $(D_INLINECODE farVal). Reverse mappings such as nearVal = 1, and farVal = 0 are acceptable.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDepthRange(GLclampd nearVal, GLclampd farVal) @system @nogc nothrow;

    /++
     + glInitNames: man2/glInitNames.xml
     + 
     + The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers. $(D_INLINECODE glInitNames) causes the name stack to be initialized to its default empty state. The name stack is always empty while the render mode is not $(D_INLINECODE GL_SELECT). Calls to $(D_INLINECODE glInitNames) while the render mode is not $(D_INLINECODE GL_SELECT) are ignored.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadName), $(D_INLINECODE glPushName), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glInitNames() @system @nogc nothrow;

    /++
     + glStencilFunc: man2/glStencilFunc.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first drawn into using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST). To specify actions based on the outcome of the stencil test, call $(D_INLINECODE glStencilOp) or $(D_INLINECODE glStencilOpSeparate). There can be two separate sets of $(D_INLINECODE func), $(D_INLINECODE ref), and $(D_INLINECODE mask) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilFunc) sets both front and back stencil state to the same values. Use $(D_INLINECODE glStencilFuncSeparate) to set front and back stencil state to different values. $(D_INLINECODE func) is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. $(D_INLINECODE ref) is an integer reference value that is used in the stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. $(D_INLINECODE mask) is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison. If represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by $(D_INLINECODE func). Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see $(D_INLINECODE glStencilOp) ). All tests treat values as unsigned integers in the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The following values are accepted by $(D_INLINECODE func) :
     + 
     + Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes. $(D_INLINECODE glStencilFunc) is the same as calling $(D_INLINECODE glStencilFuncSeparate) with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glStencilFunc(GLenum func, GLint ref_, GLuint mask) @system @nogc nothrow;

    /++
     + glStencilMaskSeparate: man2/glStencilMaskSeparate.xml
     + 
     + $(D_INLINECODE glStencilMaskSeparate) controls the writing of individual bits in the stencil planes. The least significant n bits of $(D_INLINECODE mask), where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing. There can be two separate $(D_INLINECODE mask) writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilMask) sets both front and back stencil writemasks to the same values, as if $(D_INLINECODE glStencilMaskSeparate) were called with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + $(D_INLINECODE glStencilMaskSeparate) is available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glIndexMask), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glStencilMaskSeparate(GLenum face, GLuint mask) @system @nogc nothrow;

    /++
     + glActiveTexture: man2/glActiveTexture.xml
     + 
     + $(D_INLINECODE glActiveTexture) selects which texture unit subsequent texture state calls will affect.  The number of texture units an implementation supports is implementation dependent, but must be at least 2. Vertex arrays are client-side GL resources, which are selected by the $(D_INLINECODE glClientActiveTexture) routine.
     + 
     + $(D_INLINECODE glActiveTexture) is only supported if the GL version is 1.3 or greater, or if $(D_INLINECODE ARB_multitexture) is included in the string returned by $(D_INLINECODE glGetString) when called with the argument $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glActiveTexture(GLenum texture) @system @nogc nothrow;

    /++
     + glGetHistogram: man2/glGetHistogram.xml
     + 
     + $(D_INLINECODE glGetHistogram) returns the current histogram table as a one-dimensional image with the same width as the histogram. No pixel transfer operations are performed on this image, but pixel storage modes that are applicable to 1D images are honored. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a histogram table is requested, $(D_INLINECODE values) is treated as a byte offset into the buffer object's data store. Color components that are requested in the specified $(D_INLINECODE format), but which are not included in the internal format of the histogram, are returned as zero. The assignments of internal color components to the components requested by $(D_INLINECODE format) are: $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red
     + 
     + $(D_INLINECODE glGetHistogram) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glHistogram), $(D_INLINECODE glResetHistogram),
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid* values) @system @nogc nothrow;

    /++
     + gluBuild1DMipmaps: man2/gluBuild1DMipmaps.xml
     + 
     + $(D_INLINECODE gluBuild1DMipmaps) builds a series of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). Initially, the $(D_INLINECODE width) of $(D_INLINECODE data) is checked to see if it is a power of 2. If not, a copy of $(D_INLINECODE data) is scaled up or down to the nearest power of 2. (If $(D_INLINECODE width) is exactly between powers of 2, then the copy of $(D_INLINECODE data) will scale upwards.)  This copy will be used for subsequent mipmapping operations described below. For example, if $(D_INLINECODE width) is 57, then a copy of $(D_INLINECODE data) will scale up to 64 before mipmapping takes place. Then, proxy textures (see $(D_INLINECODE glTexImage1D) ) are used to determine if the implementation can fit the requested texture. If not, $(D_INLINECODE width) is continually halved until it fits. Next, a series of mipmap levels is built by decimating a copy of $(D_INLINECODE data) in half until size 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding two texels in the larger mipmap level. $(D_INLINECODE glTexImage1D) is called to load each of these mipmap levels. Level 0 is a copy of $(D_INLINECODE data). The highest level is log 2 &af; width. For example, if $(D_INLINECODE width) is 64 and the implementation can store a texture of this size, the following mipmap levels are built: 64 &times; 1, 32 &times; 1, 16 &times; 1, 8 &times; 1, 4 &times; 1, 2 &times; 1, and 1 &times; 1. These correspond to levels 0 through 6, respectively. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for the $(D_INLINECODE type) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for the $(D_INLINECODE data) parameter.
     + 
     + Note that there is no direct way of querying the maximum level. This can be derived indirectly via $(D_INLINECODE glGetTexLevelParameter). First, query for the width actually used at level 0. (The width may not be equal to $(D_INLINECODE width) since proxy textures might have scaled it to fit the implementation.) Then the maximum level can be derived from the formula log 2 &af; width. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater, and if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void* data) @system @nogc nothrow;

    /++
     + glCompressedTexImage3D: man2/glCompressedTexImage3D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.  To enable and disable three-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_3D). $(D_INLINECODE glCompressedTexImage3D) loads a previously defined, and retrieved, compressed three-dimensional texture image if $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_3D) (see $(D_INLINECODE glTexImage3D) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_3D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. $(D_INLINECODE internalformat) must be an extension-specified compressed-texture format. When a texture is loaded with $(D_INLINECODE glTexImage2D) using a generic compressed texture format (e.g., $(D_INLINECODE GL_COMPRESSED_RGB) ), the GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image using $(D_INLINECODE glCompressedTexImage3D), query the compressed texture image's size and format using $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glCompressedTexImage3D) is available only if the GL version is 1.3 or greater. Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the $(D_INLINECODE GL_ARB_texture_non_power_of_two) extension.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glColorTable), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;

    /++
     + glFogCoord: man2/glFogCoord.xml
     + 
     + $(D_INLINECODE glFogCoord) specifies the fog coordinate that is associated with each vertex and the current raster position.  The value specified is interpolated and used in computing the fog color (see $(D_INLINECODE glFog) ).
     + 
     + $(D_INLINECODE glFogCoord) is available only if the GL version is 1.4 or greater. The current fog coordinate can be updated at any time.  In particular, $(D_INLINECODE glFogCoord) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFog), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoordd(GLdouble coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoordf(GLfloat coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoorddv(GLdouble* coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    void glFogCoordfv(GLfloat* coord) @system @nogc nothrow;

    /++
     + glLogicOp: man2/glLogicOp.xml
     + 
     + $(D_INLINECODE glLogicOp) specifies a logical operation that, when enabled, is applied between the incoming color index or RGBA color and the color index or RGBA color at the corresponding location in the frame buffer. To enable or disable the logical operation, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) using the symbolic constant $(D_INLINECODE GL_COLOR_LOGIC_OP) for RGBA mode or $(D_INLINECODE GL_INDEX_LOGIC_OP) for color index mode. The initial value is disabled for both operations. $(B Opcode) $(B Resulting Operation) $(D_INLINECODE GL_CLEAR) 0 $(D_INLINECODE GL_SET) 1 $(D_INLINECODE GL_COPY) s $(D_INLINECODE GL_COPY_INVERTED) ~s $(D_INLINECODE GL_NOOP) d $(D_INLINECODE GL_INVERT) ~d $(D_INLINECODE GL_AND) s &amp; d $(D_INLINECODE GL_NAND) ~(s &amp; d) $(D_INLINECODE GL_OR) s | d $(D_INLINECODE GL_NOR) ~(s | d) $(D_INLINECODE GL_XOR) s ^ d $(D_INLINECODE GL_EQUIV) ~(s ^ d) $(D_INLINECODE GL_AND_REVERSE) s &amp; ~d $(D_INLINECODE GL_AND_INVERTED) ~s &amp; d $(D_INLINECODE GL_OR_REVERSE) s | ~d $(D_INLINECODE GL_OR_INVERTED) ~s | d $(D_INLINECODE opcode) is a symbolic constant chosen from the list above. In the explanation of the logical operations, represents the incoming color index and represents the index in the frame buffer. Standard C-language operators are used. As these bitwise operators suggest, the logical operation is applied independently to each bit pair of the source and destination indices or colors.
     + 
     + Color index logical operations are always supported. RGBA logical operations are supported only if the GL version is 1.1 or greater. When more than one RGBA color or index buffer is enabled for drawing, logical operations are performed separately for each enabled buffer, using for the destination value the contents of that buffer (see $(D_INLINECODE glDrawBuffer) ).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glEnable), $(D_INLINECODE glStencilOp)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glLogicOp(GLenum opcode) @system @nogc nothrow;

    /++
     + glVertexPointer: man2/glVertexPointer.xml
     + 
     + $(D_INLINECODE glVertexPointer) specifies the location and data format of an array of vertex coordinates to use when rendering. $(D_INLINECODE size) specifies the number of coordinates per vertex, and must be 2, 3, or 4. $(D_INLINECODE type) specifies the data type of each coordinate, and $(D_INLINECODE stride) specifies the byte stride from one vertex to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see $(D_INLINECODE glInterleavedArrays).) If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a vertex array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as vertex array client-side state ( $(D_INLINECODE GL_VERTEX_ARRAY_BUFFER_BINDING) ). When a vertex array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the vertex array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_VERTEX_ARRAY). If enabled, the vertex array is used when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glDrawRangeElements) is called.
     + 
     + $(D_INLINECODE glVertexPointer) is available only if the GL version is 1.1 or greater. The vertex array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glVertexPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glVertexPointer) is typically implemented on the client side. Vertex array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertex), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer) @system @nogc nothrow;

    /++
     + gluNewTess: man2/gluNewTess.xml
     + 
     + $(D_INLINECODE gluNewTess) creates and returns a pointer to a new tessellation object. This object must be referred to when calling tessellation functions.  A return value of 0 means that there is not enough memory to allocate the object.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluDeleteTess), $(D_INLINECODE gluTessCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    GLUtesselator* gluNewTess() @system @nogc nothrow;

    /++
     + glIsEnabled: man2/glIsEnabled.xml
     + 
     + $(D_INLINECODE glIsEnabled) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE cap) is an enabled capability and returns $(D_INLINECODE GL_FALSE) otherwise. Initially all capabilities except $(D_INLINECODE GL_DITHER) are disabled; $(D_INLINECODE GL_DITHER) is initially enabled. The following capabilities are accepted for $(D_INLINECODE cap) : $(B Constant) $(B See) $(D_INLINECODE GL_ALPHA_TEST) $(D_INLINECODE glAlphaFunc) $(D_INLINECODE GL_AUTO_NORMAL) $(D_INLINECODE glEvalCoord) $(D_INLINECODE GL_BLEND) $(D_INLINECODE glBlendFunc), $(D_INLINECODE glLogicOp) $(D_INLINECODE GL_CLIP_PLANE) $(D_INLINECODE glClipPlane) $(D_INLINECODE GL_COLOR_ARRAY) $(D_INLINECODE glColorPointer) $(D_INLINECODE GL_COLOR_LOGIC_OP) $(D_INLINECODE glLogicOp) $(D_INLINECODE GL_COLOR_MATERIAL) $(D_INLINECODE glColorMaterial) $(D_INLINECODE GL_COLOR_SUM) $(D_INLINECODE glSecondaryColor) $(D_INLINECODE GL_COLOR_TABLE) $(D_INLINECODE glColorTable) $(D_INLINECODE GL_CONVOLUTION_1D) $(D_INLINECODE glConvolutionFilter1D) $(D_INLINECODE GL_CONVOLUTION_2D) $(D_INLINECODE glConvolutionFilter2D) $(D_INLINECODE GL_CULL_FACE) $(D_INLINECODE glCullFace) $(D_INLINECODE GL_DEPTH_TEST) $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange) $(D_INLINECODE GL_DITHER) $(D_INLINECODE glEnable) $(D_INLINECODE GL_EDGE_FLAG_ARRAY) $(D_INLINECODE glEdgeFlagPointer) $(D_INLINECODE GL_FOG) $(D_INLINECODE glFog) $(D_INLINECODE GL_FOG_COORD_ARRAY) $(D_INLINECODE glFogCoordPointer) $(D_INLINECODE GL_HISTOGRAM) $(D_INLINECODE glHistogram) $(D_INLINECODE GL_INDEX_ARRAY) $(D_INLINECODE glIndexPointer) $(D_INLINECODE GL_INDEX_LOGIC_OP) $(D_INLINECODE glLogicOp) $(D_INLINECODE GL_LIGHT) $(D_INLINECODE glLightModel), $(D_INLINECODE glLight) $(D_INLINECODE GL_LIGHTING) $(D_INLINECODE glMaterial), $(D_INLINECODE glLightModel), $(D_INLINECODE glLight) $(D_INLINECODE GL_LINE_SMOOTH) $(D_INLINECODE glLineWidth) $(D_INLINECODE GL_LINE_STIPPLE) $(D_INLINECODE glLineStipple) $(D_INLINECODE GL_MAP1_COLOR_4) $(D_INLINECODE glMap1) $(D_INLINECODE GL_MAP1_INDEX) $(D_INLINECODE glMap1) $(D_INLINECODE GL_MAP1_NORMAL) $(D_INLINECODE glMap1) $(D_INLINECODE GL_MAP1_TEXTURE_COORD_1) $(D_INLINECODE glMap1) $(D_INLINECODE GL_MAP1_TEXTURE_COORD_2) $(D_INLINECODE glMap1) $(D_INLINECODE GL_MAP1_TEXTURE_COORD_3) $(D_INLINECODE glMap1) $(D_INLINECODE GL_MAP1_TEXTURE_COORD_4) $(D_INLINECODE glMap1) $(D_INLINECODE GL_MAP2_COLOR_4) $(D_INLINECODE glMap2) $(D_INLINECODE GL_MAP2_INDEX) $(D_INLINECODE glMap2) $(D_INLINECODE GL_MAP2_NORMAL) $(D_INLINECODE glMap2) $(D_INLINECODE GL_MAP2_TEXTURE_COORD_1) $(D_INLINECODE glMap2) $(D_INLINECODE GL_MAP2_TEXTURE_COORD_2) $(D_INLINECODE glMap2) $(D_INLINECODE GL_MAP2_TEXTURE_COORD_3) $(D_INLINECODE glMap2) $(D_INLINECODE GL_MAP2_TEXTURE_COORD_4) $(D_INLINECODE glMap2) $(D_INLINECODE GL_MAP2_VERTEX_3) $(D_INLINECODE glMap2) $(D_INLINECODE GL_MAP2_VERTEX_4) $(D_INLINECODE glMap2) $(D_INLINECODE GL_MINMAX) $(D_INLINECODE glMinmax) $(D_INLINECODE GL_MULTISAMPLE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_NORMAL_ARRAY) $(D_INLINECODE glNormalPointer) $(D_INLINECODE GL_NORMALIZE) $(D_INLINECODE glNormal) $(D_INLINECODE GL_POINT_SMOOTH) $(D_INLINECODE glPointSize) $(D_INLINECODE GL_POINT_SPRITE) $(D_INLINECODE glEnable) $(D_INLINECODE GL_POLYGON_SMOOTH) $(D_INLINECODE glPolygonMode) $(D_INLINECODE GL_POLYGON_OFFSET_FILL) $(D_INLINECODE glPolygonOffset) $(D_INLINECODE GL_POLYGON_OFFSET_LINE) $(D_INLINECODE glPolygonOffset) $(D_INLINECODE GL_POLYGON_OFFSET_POINT) $(D_INLINECODE glPolygonOffset) $(D_INLINECODE GL_POLYGON_STIPPLE) $(D_INLINECODE glPolygonStipple) $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE) $(D_INLINECODE glColorTable) $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE) $(D_INLINECODE glColorTable) $(D_INLINECODE GL_RESCALE_NORMAL) $(D_INLINECODE glNormal) $(D_INLINECODE GL_SAMPLE_ALPHA_TO_COVERAGE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_SAMPLE_ALPHA_TO_ONE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_SAMPLE_COVERAGE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_SCISSOR_TEST) $(D_INLINECODE glScissor) $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY) $(D_INLINECODE glSecondaryColorPointer) $(D_INLINECODE GL_SEPARABLE_2D) $(D_INLINECODE glSeparableFilter2D) $(D_INLINECODE GL_STENCIL_TEST) $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilOp) $(D_INLINECODE GL_TEXTURE_1D) $(D_INLINECODE glTexImage1D) $(D_INLINECODE GL_TEXTURE_2D) $(D_INLINECODE glTexImage2D) $(D_INLINECODE GL_TEXTURE_3D) $(D_INLINECODE glTexImage3D) $(D_INLINECODE GL_TEXTURE_COORD_ARRAY) $(D_INLINECODE glTexCoordPointer) $(D_INLINECODE GL_TEXTURE_CUBE_MAP) $(D_INLINECODE glTexImage2D) $(D_INLINECODE GL_TEXTURE_GEN_Q) $(D_INLINECODE glTexGen) $(D_INLINECODE GL_TEXTURE_GEN_R) $(D_INLINECODE glTexGen) $(D_INLINECODE GL_TEXTURE_GEN_S) $(D_INLINECODE glTexGen) $(D_INLINECODE GL_TEXTURE_GEN_T) $(D_INLINECODE glTexGen) $(D_INLINECODE GL_VERTEX_ARRAY) $(D_INLINECODE glVertexPointer) $(D_INLINECODE GL_VERTEX_PROGRAM_POINT_SIZE) $(D_INLINECODE glEnable) $(D_INLINECODE GL_VERTEX_PROGRAM_TWO_SIDE) $(D_INLINECODE glEnable)
     + 
     + If an error is generated, $(D_INLINECODE glIsEnabled) returns 0. $(D_INLINECODE GL_COLOR_LOGIC_OP), $(D_INLINECODE GL_COLOR_ARRAY), $(D_INLINECODE GL_EDGE_FLAG_ARRAY), $(D_INLINECODE GL_INDEX_ARRAY), $(D_INLINECODE GL_INDEX_LOGIC_OP), $(D_INLINECODE GL_NORMAL_ARRAY), $(D_INLINECODE GL_POLYGON_OFFSET_FILL), $(D_INLINECODE GL_POLYGON_OFFSET_LINE), $(D_INLINECODE GL_POLYGON_OFFSET_POINT), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY), and $(D_INLINECODE GL_VERTEX_ARRAY) are available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_RESCALE_NORMAL), and $(D_INLINECODE GL_TEXTURE_3D) are available only if the GL version is 1.2 or greater. $(D_INLINECODE GL_MULTISAMPLE), $(D_INLINECODE GL_SAMPLE_ALPHA_TO_COVERAGE), $(D_INLINECODE GL_SAMPLE_ALPHA_TO_ONE), $(D_INLINECODE GL_SAMPLE_COVERAGE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP) are available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_FOG_COORD_ARRAY) and $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY) are available only if the GL version is 1.4 or greater. $(D_INLINECODE GL_POINT_SPRITE), $(D_INLINECODE GL_VERTEX_PROGRAM_POINT_SIZE), and $(D_INLINECODE GL_VERTEX_PROGRAM_TWO_SIDE) are available only if the GL version is 2.0 or greater. $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_CONVOLUTION_1D), $(D_INLINECODE GL_CONVOLUTION_2D), $(D_INLINECODE GL_HISTOGRAM), $(D_INLINECODE GL_MINMAX), $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), and $(D_INLINECODE GL_SEPARABLE_2D) are available only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGet) is called with $(D_INLINECODE GL_EXTENSIONS). For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, the following parameters return the associated value for the active texture unit: $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_GEN_S), $(D_INLINECODE GL_TEXTURE_GEN_T), $(D_INLINECODE GL_TEXTURE_GEN_R), $(D_INLINECODE GL_TEXTURE_GEN_Q), $(D_INLINECODE GL_TEXTURE_MATRIX), and $(D_INLINECODE GL_TEXTURE_STACK_DEPTH). Likewise, the following parameters return the associated value for the active client texture unit: $(D_INLINECODE GL_TEXTURE_COORD_ARRAY), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_SIZE), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_STRIDE), $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_TYPE).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    GLboolean glIsEnabled(GLenum cap) @system @nogc nothrow;

    /++
     + glTexParameter: man2/glTexParameter.xml
     + 
     + Texture mapping is a technique that applies an image onto an object's surface as if the image were a decal or cellophane shrink-wrap. The image is created in texture space, with an ( s, t ) coordinate system. A texture is a one- or two-dimensional image and a set of parameters that determine how samples are derived from the image. $(D_INLINECODE glTexParameter) assigns the value or values in $(D_INLINECODE params) to the texture parameter specified as $(D_INLINECODE pname). $(D_INLINECODE target) defines the target texture, either $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), or $(D_INLINECODE GL_TEXTURE_3D). The following symbols are accepted in $(D_INLINECODE pname) :
     + 
     + $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_CLAMP_TO_EDGE), $(D_INLINECODE GL_TEXTURE_BASE_LEVEL), and $(D_INLINECODE GL_TEXTURE_MAX_LEVEL) are available only if the GL version is 1.2 or greater. $(D_INLINECODE GL_CLAMP_TO_BORDER) is available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_MIRRORED_REPEAT), $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC), $(D_INLINECODE GL_DEPTH_TEXTURE_MODE), and $(D_INLINECODE GL_GENERATE_MIPMAP) are available only if the GL version is 1.4 or greater. $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC) allows the following additional comparison modes only if the GL version is 1.5 or greater: $(D_INLINECODE GL_LESS), $(D_INLINECODE GL_GREATER), $(D_INLINECODE GL_EQUAL), $(D_INLINECODE GL_NOTEQUAL), $(D_INLINECODE GL_ALWAYS), and $(D_INLINECODE GL_NEVER). Suppose that a program has enabled texturing (by calling $(D_INLINECODE glEnable) with argument $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), or $(D_INLINECODE GL_TEXTURE_3D) ) and has set $(D_INLINECODE GL_TEXTURE_MIN_FILTER) to one of the functions that requires a mipmap.  If either the dimensions of the texture images currently defined (with previous calls to $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glCopyTexImage1D), or $(D_INLINECODE glCopyTexImage2D) ) do not follow the proper sequence for mipmaps (described above), or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then it is as if texture mapping were disabled. Linear filtering accesses the four nearest texture elements only in 2D textures.  In 1D textures, linear filtering accesses the two nearest texture elements. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexParameter) specifies the texture parameters for the active texture unit, specified by calling $(D_INLINECODE glActiveTexture).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPrioritizeTextures), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexParameterf(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexParameteri(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexParameteriv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;

    /++
     + glEnableVertexAttribArray: man2/glEnableVertexAttribArray.xml
     + 
     + $(D_INLINECODE glEnableVertexAttribArray) enables the generic vertex attribute array specified by $(D_INLINECODE index). $(D_INLINECODE glDisableVertexAttribArray) disables the generic vertex attribute array specified by $(D_INLINECODE index). By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array commands such as $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glArrayElement), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glMultiDrawArrays).
     + 
     + $(D_INLINECODE glEnableVertexAttribArray) and $(D_INLINECODE glDisableVertexAttribArray) are available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glEnableVertexAttribArray(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDisableVertexAttribArray(GLuint index) @system @nogc nothrow;

    /++
     + glGetConvolutionParameter: man2/glGetConvolutionParameter.xml
     + 
     + $(D_INLINECODE glGetConvolutionParameter) retrieves convolution parameters. $(D_INLINECODE target) determines which convolution filter is queried. $(D_INLINECODE pname) determines which parameter is returned:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetConvolutionFilter), $(D_INLINECODE glGetSeparableFilter), $(D_INLINECODE glConvolutionParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glTexCoord: man2/glTexCoord.xml
     + 
     + $(D_INLINECODE glTexCoord) specifies texture coordinates in one, two, three, or four dimensions. $(D_INLINECODE glTexCoord1) sets the current texture coordinates to s 0 0 1; a call to $(D_INLINECODE glTexCoord2) sets them to s t 0 1. Similarly, $(D_INLINECODE glTexCoord3) specifies the texture coordinates as s t r 1, and $(D_INLINECODE glTexCoord4) defines all four components explicitly as s t r q. The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for,,, and are (0, 0, 0, 1).
     + 
     + The current texture coordinates can be updated at any time. In particular, $(D_INLINECODE glTexCoord) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd). When the $(D_INLINECODE ARB_imaging) extension is supported, $(D_INLINECODE glTexCoord) always updates texture unit $(D_INLINECODE GL_TEXTURE0).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1s(GLshort s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1i(GLint s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1f(GLfloat s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1d(GLdouble s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2s(GLshort s, GLshort t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2i(GLint s, GLint t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2f(GLfloat s, GLfloat t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2d(GLdouble s, GLdouble t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3s(GLshort s, GLshort t, GLshort r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3i(GLint s, GLint t, GLint r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4i(GLint s, GLint t, GLint r, GLint q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord1dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord2dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord3dv(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4sv(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4iv(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4fv(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glTexCoord4dv(const GLdouble* v) @system @nogc nothrow;

    /++
     + glDrawBuffers: man2/glDrawBuffers.xml
     + 
     + $(D_INLINECODE glDrawBuffers) defines an array of buffers into which fragment color values or fragment data will be written. If no fragment shader is active, rendering operations will generate only one fragment color per fragment and it will be written into each of the buffers specified by $(D_INLINECODE bufs). If a fragment shader is active and it writes a value to the output variable $(D_INLINECODE gl_FragColor), then that value will be written into each of the buffers specified by $(D_INLINECODE bufs). If a fragment shader is active and it writes a value to one or more elements of the output array variable $(D_INLINECODE gl_FragData[]), then the value of $(D_INLINECODE gl_FragData[0]) will be written into the first buffer specified by $(D_INLINECODE bufs), the value of $(D_INLINECODE gl_FragData[1]) will be written into the second buffer specified by $(D_INLINECODE bufs), and so on up to $(D_INLINECODE gl_FragData[n-1]). The draw buffer used for $(D_INLINECODE gl_FragData[n]) and beyond is implicitly set to be $(D_INLINECODE GL_NONE). The symbolic constants contained in $(D_INLINECODE bufs) may be any of the following: Except for $(D_INLINECODE GL_NONE), the preceding symbolic constants may not appear more than once in $(D_INLINECODE bufs). The maximum number of draw buffers supported is implementation dependent and can be queried by calling $(D_INLINECODE glGet) with the argument $(D_INLINECODE GL_MAX_DRAW_BUFFERS). The number of auxiliary buffers can be queried by calling $(D_INLINECODE glGet) with the argument $(D_INLINECODE GL_AUX_BUFFERS).
     + 
     + $(D_INLINECODE glDrawBuffers) is available only if the GL version is 2.0 or greater. It is always the case that $(D_INLINECODE GL_AUXi) = $(D_INLINECODE GL_AUX0) + $(D_INLINECODE i). The symbolic constants $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), $(D_INLINECODE GL_LEFT), $(D_INLINECODE GL_RIGHT), and $(D_INLINECODE GL_FRONT_AND_BACK) are not allowed in the $(D_INLINECODE bufs) array since they may refer to multiple buffers. If a fragment shader writes to neither $(D_INLINECODE gl_FragColor) nor $(D_INLINECODE gl_FragData), the values of the fragment colors following shader execution are undefined. For each fragment generated in this situation, a different value may be written into each of the buffers specified by $(D_INLINECODE bufs).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 2003-2005 3Dlabs Inc. Ltd. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glColorMask), $(D_INLINECODE glDrawBuffers), $(D_INLINECODE glIndexMask), $(D_INLINECODE glLogicOp), $(D_INLINECODE glReadBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    void glDrawBuffers(GLsizei n, const GLenum* bufs) @system @nogc nothrow;

    /++
     + glGetTexLevelParameter: man2/glGetTexLevelParameter.xml
     + 
     + $(D_INLINECODE glGetTexLevelParameter) returns in $(D_INLINECODE params) texture parameter values for a specific level-of-detail value, specified as $(D_INLINECODE level). $(D_INLINECODE target) defines the target texture, either $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_1D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP). $(D_INLINECODE GL_MAX_TEXTURE_SIZE), and $(D_INLINECODE GL_MAX_3D_TEXTURE_SIZE) are not really descriptive enough. It has to report the largest square texture image that can be accommodated with mipmaps and borders, but a long skinny texture, or a texture without mipmaps and borders, may easily fit in texture memory. The proxy targets allow the user to more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot be accommodated, the texture state variables, which may be queried with $(D_INLINECODE glGetTexLevelParameter), are set to 0.  If the texture can be accommodated, the texture state values will be set as they would be set for a non-proxy target. $(D_INLINECODE pname) specifies the texture parameter whose value or values will be returned. The accepted parameter names are as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE GL_TEXTURE_INTERNAL_FORMAT) is available only if the GL version is 1.1 or greater. In version 1.0, use $(D_INLINECODE GL_TEXTURE_COMPONENTS) instead. $(D_INLINECODE GL_PROXY_TEXTURE_1D) and $(D_INLINECODE GL_PROXY_TEXTURE_2D) are available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), and $(D_INLINECODE GL_TEXTURE_DEPTH) are available only if the GL version is 1.2 or greater. $(D_INLINECODE GL_TEXTURE_COMPRESSED), $(D_INLINECODE GL_TEXTURE_COMPRESSED_IMAGE_SIZE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), and $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP) are available only if the GL version is 1.3 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glGetTexLevelParameter) returns the texture level parameters for the active texture unit.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetPixelMap: man2/glGetPixelMap.xml
     + 
     + See the $(D_INLINECODE glPixelMap) reference page for a description of the acceptable values for the $(D_INLINECODE map) parameter. $(D_INLINECODE glGetPixelMap) returns in $(D_INLINECODE data) the contents of the pixel map specified in $(D_INLINECODE map). Pixel maps are used during the execution of $(D_INLINECODE glReadPixels), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), and $(D_INLINECODE glCopyTexSubImage3D). to map color indices, stencil indices, color components, and depth components to other values. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a pixel map is requested, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to 0. Return unsigned integer values are undefined if the map value was not in the range [0,1]. To determine the required size of $(D_INLINECODE map), call $(D_INLINECODE glGet) with the appropriate symbolic constant.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE data).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorSubTable), $(D_INLINECODE glColorTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glCopyColorSubTable), $(D_INLINECODE glCopyColorTable), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetHistogram), $(D_INLINECODE glGetMinmax), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glReadPixels), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D) $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetPixelMapfv(GLenum map, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetPixelMapuiv(GLenum map, GLuint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetPixelMapusv(GLenum map, GLushort* data) @system @nogc nothrow;

    /++
     + glEvalCoord: man2/glEvalCoord.xml
     + 
     + $(D_INLINECODE glEvalCoord1) evaluates enabled one-dimensional maps at argument $(D_INLINECODE u). $(D_INLINECODE glEvalCoord2) does the same for two-dimensional maps using two domain values, $(D_INLINECODE u) and $(D_INLINECODE v). To define a map, call $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2); to enable and disable it, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable). When one of the $(D_INLINECODE glEvalCoord) commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if $(D_INLINECODE GL_MAP1_INDEX) or $(D_INLINECODE GL_MAP2_INDEX) is enabled, a $(D_INLINECODE glIndex) command is simulated. If $(D_INLINECODE GL_MAP1_COLOR_4) or $(D_INLINECODE GL_MAP2_COLOR_4) is enabled, a $(D_INLINECODE glColor) command is simulated. If $(D_INLINECODE GL_MAP1_NORMAL) or $(D_INLINECODE GL_MAP2_NORMAL) is enabled, a normal vector is produced, and if any of $(D_INLINECODE GL_MAP1_TEXTURE_COORD_1), $(D_INLINECODE GL_MAP1_TEXTURE_COORD_2), $(D_INLINECODE GL_MAP1_TEXTURE_COORD_3), $(D_INLINECODE GL_MAP1_TEXTURE_COORD_4), $(D_INLINECODE GL_MAP2_TEXTURE_COORD_1), $(D_INLINECODE GL_MAP2_TEXTURE_COORD_2), $(D_INLINECODE GL_MAP2_TEXTURE_COORD_3), or $(D_INLINECODE GL_MAP2_TEXTURE_COORD_4) is enabled, then an appropriate $(D_INLINECODE glTexCoord) command is simulated. For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if $(D_INLINECODE glVertex) commands are interspersed with $(D_INLINECODE glEvalCoord) commands, the color, normal, and texture coordinates associated with the $(D_INLINECODE glVertex) commands are not affected by the values generated by the $(D_INLINECODE glEvalCoord) commands, but only by the most recent $(D_INLINECODE glColor), $(D_INLINECODE glIndex), $(D_INLINECODE glNormal), and $(D_INLINECODE glTexCoord) commands. No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, $(D_INLINECODE GL_MAP2_TEXTURE_COORD_1) and $(D_INLINECODE GL_MAP2_TEXTURE_COORD_2) ), then only the evaluation of the map that produces the larger number of coordinates (in this case, $(D_INLINECODE GL_MAP2_TEXTURE_COORD_2) ) is carried out. $(D_INLINECODE GL_MAP1_VERTEX_4) overrides $(D_INLINECODE GL_MAP1_VERTEX_3), and $(D_INLINECODE GL_MAP2_VERTEX_4) overrides $(D_INLINECODE GL_MAP2_VERTEX_3), in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the $(D_INLINECODE glEvalCoord) command is ignored. If you have enabled automatic normal generation, by calling $(D_INLINECODE glEnable) with argument $(D_INLINECODE GL_AUTO_NORMAL), $(D_INLINECODE glEvalCoord2) generates surface normals analytically, regardless of the contents or enabling of the $(D_INLINECODE GL_MAP2_NORMAL) map. Let m = &PartialD; p &PartialD; u &times; &PartialD; p &PartialD; v Then the generated normal n is n = m m If automatic normal generation is disabled, the corresponding normal map $(D_INLINECODE GL_MAP2_NORMAL), if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for $(D_INLINECODE glEvalCoord2) commands.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glEnable), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glIndex), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2), $(D_INLINECODE glMapGrid), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord1f(GLfloat u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord1d(GLdouble u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord2f(GLfloat u, GLfloat v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord2d(GLdouble u, GLdouble v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord1fv(const GLfloat* u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord1dv(const GLdouble* u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord2fv(const GLfloat* u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glEvalCoord2dv(const GLdouble* u) @system @nogc nothrow;

    /++
     + glCompressedTexImage2D: man2/glCompressedTexImage2D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.  To enable and disable two-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_2D).  To enable and disable texturing using cube-mapped textures, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_CUBE_MAP). $(D_INLINECODE glCompressedTexImage2D) loads a previously defined, and retrieved, compressed two-dimensional texture image if $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D) (see $(D_INLINECODE glTexImage2D) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_2D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. $(D_INLINECODE internalformat) must be an extension-specified compressed-texture format. When a texture is loaded with $(D_INLINECODE glTexImage2D) using a generic compressed texture format (e.g., $(D_INLINECODE GL_COMPRESSED_RGB) ), the GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image using $(D_INLINECODE glCompressedTexImage2D), query the compressed texture image's size and format using $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glCompressedTexImage2D) is available only if the GL version is 1.3 or greater. Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the $(D_INLINECODE GL_ARB_texture_non_power_of_two) extension.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glColorTable), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexGen), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data) @system @nogc nothrow;

    /++
     + glGetLight: man2/glGetLight.xml
     + 
     + $(D_INLINECODE glGetLight) returns in $(D_INLINECODE params) the value or values of a light source parameter. $(D_INLINECODE light) names the light and is a symbolic name of the form $(D_INLINECODE GL_LIGHT) i where i ranges from 0 to the value of $(D_INLINECODE GL_MAX_LIGHTS) - 1. $(D_INLINECODE GL_MAX_LIGHTS) is an implementation dependent constant that is greater than or equal to eight. $(D_INLINECODE pname) specifies one of ten light source parameters, again by symbolic name. The following parameters are defined:
     + 
     + It is always the case that $(D_INLINECODE GL_LIGHT) i = $(D_INLINECODE GL_LIGHT0) + i. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLight)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetLightfv(GLenum light, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glGetLightiv(GLenum light, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glDrawBuffer: man2/glDrawBuffer.xml
     + 
     + When colors are written to the frame buffer, they are written into the color buffers specified by $(D_INLINECODE glDrawBuffer). The specifications are as follows: If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer. Monoscopic contexts include only buffers, and stereoscopic contexts include both and buffers. Likewise, single-buffered contexts include only buffers, and double-buffered contexts include both and buffers. The context is selected at GL initialization.
     + 
     + It is always the case that $(D_INLINECODE GL_AUX) i = $(D_INLINECODE GL_AUX0) + i.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glColorMask), $(D_INLINECODE glIndexMask), $(D_INLINECODE glLogicOp), $(D_INLINECODE glReadBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    void glDrawBuffer(GLenum mode) @system @nogc nothrow;

    /++
     + : 
     + 
     + 
     + Params:
     + 
     + Copyright:
     +     
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glAccumxOES(GLenum op, GLfixed value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glActiveProgramEXT(GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glActiveShaderProgram(GLuint pipeline, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glActiveShaderProgramEXT(GLuint pipeline, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_stencil_two_side")
    void glActiveStencilFaceEXT(GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glActiveTextureARB(GLenum texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glActiveVaryingNV(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_alpha_test")
    void glAlphaFuncQCOM(GLenum func, GLclampf ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glAlphaFuncx(GLenum func, GLfixed ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glAlphaFuncxOES(GLenum func, GLfixed ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_framebuffer_CMAA")
    void glApplyFramebufferAttachmentCMAAINTEL() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_light_texture")
    void glApplyTextureEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    GLboolean glAreProgramsResidentNV(GLsizei n, const GLuint* programs, GLboolean* residences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint* textures, GLboolean* residences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glArrayElementEXT(GLint i) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    void glAsyncMarkerSGIX(GLuint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glBeginConditionalRender(GLuint id, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conditional_render")
    void glBeginConditionalRenderNV(GLuint id, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NVX_conditional_render")
    void glBeginConditionalRenderNVX(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glBeginFragmentShaderATI() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glBeginOcclusionQueryNV(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glBeginPerfMonitorAMD(GLuint monitor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glBeginPerfQueryINTEL(GLuint queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glBeginQueryARB(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glBeginQueryEXT(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glBeginTransformFeedback(GLenum primitiveMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glBeginTransformFeedbackEXT(GLenum primitiveMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glBeginTransformFeedbackNV(GLenum primitiveMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glBeginVertexShaderEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glBeginVideoCaptureNV(GLuint video_capture_slot) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_shader")
    void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glBindBufferARB(GLenum target, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glBindBufferBase(GLenum target, GLuint index, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint* buffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizeiptr* sizes) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glBindFragDataLocation(GLuint program, GLuint color, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    void glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_blend_func_extended")
    void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    void glBindFragDataLocationIndexedEXT(GLuint program, GLuint colorNumber, GLuint index, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glBindFragmentShaderATI(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glBindFramebuffer(GLenum target, GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glBindFramebufferEXT(GLenum target, GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glBindFramebufferOES(GLenum target, GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_shader_image_load_store")
    void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_image_load_store")
    void glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindImageTextures(GLuint first, GLsizei count, const GLuint* textures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindLightParameterEXT(GLenum light, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindMaterialParameterEXT(GLenum face, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindParameterEXT(GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glBindProgramARB(GLenum target, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glBindProgramNV(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glBindProgramPipeline(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glBindProgramPipelineEXT(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glBindRenderbuffer(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glBindRenderbufferOES(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glBindSampler(GLuint unit, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindSamplers(GLuint first, GLsizei count, const GLuint* samplers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    void glBindTextureEXT(GLenum target, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glBindTextureUnit(GLuint unit, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glBindTextureUnitParameterEXT(GLenum unit, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindTextures(GLuint first, GLsizei count, const GLuint* textures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glBindTransformFeedback(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glBindTransformFeedbackNV(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    void glBindVertexArray(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    void glBindVertexArrayAPPLE(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    void glBindVertexArrayOES(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glBindVertexShaderEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3bvEXT(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3dvEXT(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3fvEXT(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3iEXT(GLint bx, GLint by, GLint bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3ivEXT(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormal3svEXT(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glBinormalPointerEXT(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glBitmapxOES(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const(GLubyte)* bitmap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glBlendBarrier() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_blend_equation_advanced")
    void glBlendBarrierKHR() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_blend_equation_advanced")
    void glBlendBarrierNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_color")
    void glBlendColorEXT(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glBlendColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_minmax")
    void glBlendEquationEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    void glBlendEquationIndexedAMD(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_blend_subtract")
    void glBlendEquationOES(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_equation_separate")
    void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    void glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_blend_equation_separate")
    void glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    void glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glBlendEquationSeparateiEXT(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glBlendEquationSeparateiOES(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glBlendEquationi(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    void glBlendEquationiARB(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glBlendEquationiEXT(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glBlendEquationiOES(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    void glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_separate")
    void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INGR_blend_func_separate")
    void glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    void glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_blend_func_separate")
    void glBlendFuncSeparateOES(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    void glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glBlendFuncSeparateiEXT(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glBlendFuncSeparateiOES(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glBlendFunci(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    void glBlendFunciARB(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glBlendFunciEXT(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glBlendFunciOES(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_blend_equation_advanced")
    void glBlendParameteriNV(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_framebuffer_blit")
    void glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_blit")
    void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_blit")
    void glBlitFramebufferNV(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glBufferDataARB(GLenum target, GLsizeiptrARB size, const void* data, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_buffer")
    void glBufferPageCommitmentARB(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_flush_buffer_range")
    void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_buffer_storage")
    void glBufferStorage(GLenum target, GLsizeiptr size, const void* data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_buffer_storage")
    void glBufferStorageEXT(GLenum target, GLsizeiptr size, const void* data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCallCommandListNV(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    GLenum glCheckFramebufferStatus(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    GLenum glCheckFramebufferStatusEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    GLenum glCheckFramebufferStatusOES(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    GLenum glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClampColor(GLenum target, GLenum clamp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_color_buffer_float")
    void glClampColorARB(GLenum target, GLenum clamp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glClearAccumxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_clear_buffer_object")
    void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_clear_buffer_object")
    void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_integer")
    void glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_integer")
    void glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glClearColorx(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glClearColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_depth_buffer_float")
    void glClearDepthdNV(GLdouble depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glClearDepthf(GLfloat d) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glClearDepthfOES(GLclampf depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glClearDepthx(GLfixed depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glClearDepthxOES(GLfixed depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_pixel_local_storage2")
    void glClearPixelLocalStorageuiEXT(GLsizei offset, GLsizei n, const GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_clear_texture")
    void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_clear_texture")
    void glClearTexImageEXT(GLuint texture, GLint level, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_clear_texture")
    void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_clear_texture")
    void glClearTexSubImageEXT(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glClientActiveTextureARB(GLenum texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glClientActiveVertexStreamATI(GLenum stream) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glClientAttribDefaultEXT(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    GLenum glClientWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_clip_control")
    void glClipControl(GLenum origin, GLenum depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glClipPlanef(GLenum p, const GLfloat* eqn) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_user_clip_plane")
    void glClipPlanefIMG(GLenum p, const GLfloat* eqn) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glClipPlanefOES(GLenum plane, const GLfloat* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glClipPlanex(GLenum plane, const GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_user_clip_plane")
    void glClipPlanexIMG(GLenum p, const GLfixed* eqn) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glClipPlanexOES(GLenum plane, const GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor3fVertex3fvSUN(const GLfloat* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glColor3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glColor3xOES(GLfixed red, GLfixed green, GLfixed blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glColor3xvOES(const GLfixed* components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4fNormal3fVertex3fvSUN(const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glColor4hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4ubVertex2fvSUN(const(GLubyte)* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glColor4ubVertex3fvSUN(const(GLubyte)* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glColor4xOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glColor4xvOES(const GLfixed* components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glColorFormatNV(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers2")
    void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glColorMaskiEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glColorMaskiOES(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glColorP3ui(GLenum type, GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glColorP3uiv(GLenum type, const GLuint* color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glColorP4ui(GLenum type, GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glColorP4uiv(GLenum type, const GLuint* color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glColorPointerListIBM(GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    void glColorPointervINTEL(GLint size, GLenum type, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_color_subtable")
    void glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    void glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerParameterfNV(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerParameterfvNV(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerParameteriNV(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glCombinerParameterivNV(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners2")
    void glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCommandListSegmentsNV(GLuint list, GLuint segments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCompileCommandListNV(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glCompileShaderARB(GLhandleARB shaderObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glCompileShaderIncludeARB(GLuint shader, GLsizei count, const(const(GLvoid*)*) path, const GLint* length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conservative_raster_dilate")
    void glConservativeRasterParameterfNV(GLenum pname, GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conservative_raster_pre_snap_triangles")
    void glConservativeRasterParameteriNV(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glConvolutionParameterxOES(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glConvolutionParameterxvOES(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_copy_buffer")
    void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_copy_buffer")
    void glCopyBufferSubDataNV(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_color_subtable")
    void glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_copy_image")
    void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_image")
    void glCopyImageSubDataEXT(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_copy_image")
    void glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_copy_image")
    void glCopyImageSubDataOES(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCopyPathNV(GLuint resultPath, GLuint srcPath) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    void glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_copy_texture_levels")
    void glCopyTextureLevelsAPPLE(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCoverFillPathNV(GLuint path, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glCoverStrokePathNV(GLuint path, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_coverage_sample")
    void glCoverageMaskNV(GLboolean mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_mixed_samples")
    void glCoverageModulationNV(GLenum components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_mixed_samples")
    void glCoverageModulationTableNV(GLsizei n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_coverage_sample")
    void glCoverageOperationNV(GLenum operation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateBuffers(GLsizei n, GLuint* buffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCreateCommandListsNV(GLsizei n, GLuint* lists) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateFramebuffers(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glCreatePerfQueryINTEL(GLuint queryId, GLuint* queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    GLhandleARB glCreateProgramObjectARB() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateProgramPipelines(GLsizei n, GLuint* pipelines) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateQueries(GLenum target, GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateRenderbuffers(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateSamplers(GLsizei n, GLuint* samplers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    GLhandleARB glCreateShaderObjectARB(GLenum shaderType) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    GLuint glCreateShaderProgramEXT(GLenum type, const GLchar* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const(const(GLvoid*)*) strings) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    GLuint glCreateShaderProgramvEXT(GLenum type, GLsizei count, const GLchar** strings) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glCreateStatesNV(GLsizei n, GLuint* states) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_cl_event")
    GLsync glCreateSyncFromCLeventARB(_cl_context* context, _cl_event* event, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateTextures(GLenum target, GLsizei n, GLuint* textures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateTransformFeedbacks(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glCreateVertexArrays(GLsizei n, GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_cull_vertex")
    void glCullParameterdvEXT(GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_cull_vertex")
    void glCullParameterfvEXT(GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glCurrentPaletteMatrixARB(GLint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    void glCurrentPaletteMatrixOES(GLuint matrixpaletteindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageCallback(GLDEBUGPROC callback, const void* userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    void glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, void* userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    void glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const void* userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageCallbackKHR(GLDEBUGPROCKHR callback, const void* userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    void glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageControlKHR(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    void glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    void glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    void glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glDebugMessageInsertKHR(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    void glDeformSGIX(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    void glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    void glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    void glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glDeleteBuffersARB(GLsizei n, const GLuint* buffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDeleteCommandListsNV(GLsizei n, const GLuint* lists) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glDeleteFencesAPPLE(GLsizei n, const GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glDeleteFencesNV(GLsizei n, const GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glDeleteFragmentShaderATI(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glDeleteFramebuffersEXT(GLsizei n, const GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glDeleteFramebuffersOES(GLsizei n, const GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glDeleteNamedStringARB(GLint namelen, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_name_gen_delete")
    void glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint* names) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glDeleteObjectARB(GLhandleARB obj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glDeleteOcclusionQueriesNV(GLsizei n, const GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glDeletePathsNV(GLuint path, GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glDeletePerfMonitorsAMD(GLsizei n, GLuint* monitors) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glDeletePerfQueryINTEL(GLuint queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glDeleteProgramPipelines(GLsizei n, const GLuint* pipelines) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glDeleteProgramPipelinesEXT(GLsizei n, const GLuint* pipelines) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glDeleteProgramsARB(GLsizei n, const GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glDeleteProgramsNV(GLsizei n, const GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glDeleteQueriesARB(GLsizei n, const GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glDeleteQueriesEXT(GLsizei n, const GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glDeleteRenderbuffersEXT(GLsizei n, const GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glDeleteRenderbuffersOES(GLsizei n, const GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glDeleteSamplers(GLsizei count, const GLuint* samplers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDeleteStatesNV(GLsizei n, const GLuint* states) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    void glDeleteSync(GLsync sync) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    void glDeleteSyncAPPLE(GLsync sync) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    void glDeleteTexturesEXT(GLsizei n, const GLuint* textures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glDeleteTransformFeedbacks(GLsizei n, const GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glDeleteTransformFeedbacksNV(GLsizei n, const GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    void glDeleteVertexArrays(GLsizei n, const GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    void glDeleteVertexArraysOES(GLsizei n, const GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glDeleteVertexShaderEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_depth_bounds_test")
    void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_depth_buffer_float")
    void glDepthBoundsdNV(GLdouble zmin, GLdouble zmax) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glDepthRangeArrayfvNV(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glDepthRangeArrayfvOES(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glDepthRangeIndexed(GLuint index, GLdouble n, GLdouble f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glDepthRangeIndexedfNV(GLuint index, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glDepthRangeIndexedfOES(GLuint index, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_depth_buffer_float")
    void glDepthRangedNV(GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glDepthRangef(GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glDepthRangefOES(GLclampf n, GLclampf f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glDepthRangex(GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glDepthRangexOES(GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_detail_texture")
    void glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableClientStateIndexedEXT(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableClientStateiEXT(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    void glDisableDriverControlQCOM(GLuint driverControl) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableIndexedEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glDisableVariantClientStateEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableVertexArrayAttribEXT(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glDisableVertexArrayEXT(GLuint vaobj, GLenum array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glDisableVertexAttribAPPLE(GLuint index, GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glDisableVertexAttribArrayARB(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glDisablei(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glDisableiEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glDisableiNV(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glDisableiOES(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_discard_framebuffer")
    void glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum* attachments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_compute_shader")
    void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_compute_variable_group_size")
    void glDispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_compute_shader")
    void glDispatchComputeIndirect(GLintptr indirect) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_draw_indirect")
    void glDrawArraysIndirect(GLenum mode, const void* indirect) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_instanced_arrays")
    void glDrawArraysInstancedANGLE(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_instanced")
    void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_base_instance")
    void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_base_instance")
    void glDrawArraysInstancedBaseInstanceEXT(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_instanced")
    void glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_instanced")
    void glDrawArraysInstancedNV(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers")
    void glDrawBuffersARB(GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_draw_buffers")
    void glDrawBuffersATI(GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers")
    void glDrawBuffersEXT(GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multiview_draw_buffers")
    void glDrawBuffersIndexedEXT(GLint n, const GLenum* location, const GLint* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_buffers")
    void glDrawBuffersNV(GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDrawCommandsAddressNV(GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDrawCommandsNV(GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDrawCommandsStatesAddressNV(const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glDrawCommandsStatesNV(GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_element_array")
    void glDrawElementArrayATI(GLenum mode, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    void glDrawElementsBaseVertexEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    void glDrawElementsBaseVertexOES(GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_draw_indirect")
    void glDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_instanced_arrays")
    void glDrawElementsInstancedANGLE(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_instanced")
    void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_base_instance")
    void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_base_instance")
    void glDrawElementsInstancedBaseInstanceEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_base_instance")
    void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_base_instance")
    void glDrawElementsInstancedBaseVertexBaseInstanceEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    void glDrawElementsInstancedBaseVertexEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    void glDrawElementsInstancedBaseVertexOES(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_instanced")
    void glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_instanced")
    void glDrawElementsInstancedNV(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_mesh_array")
    void glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_element_array")
    void glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    void glDrawRangeElementsBaseVertexEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    void glDrawRangeElementsBaseVertexOES(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_range_elements")
    void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexfvOES(const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexivOES(const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexsvOES(const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_texture")
    void glDrawTextureNV(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    void glDrawTexxvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glDrawTransformFeedback(GLenum mode, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_transform_feedback")
    void glDrawTransformFeedbackEXT(GLenum mode, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_transform_feedback_instanced")
    void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_transform_feedback")
    void glDrawTransformFeedbackInstancedEXT(GLenum mode, GLuint id, GLsizei instancecount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glDrawTransformFeedbackNV(GLenum mode, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_transform_feedback_instanced")
    void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_EGL_image")
    void glEGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_EGL_image")
    void glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glEdgeFlagFormatNV(GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glEdgeFlagPointerListIBM(GLint stride, const GLboolean** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glElementPointerAPPLE(GLenum type, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_element_array")
    void glElementPointerATI(GLenum type, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableClientStateIndexedEXT(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableClientStateiEXT(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    void glEnableDriverControlQCOM(GLuint driverControl) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableIndexedEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glEnableVariantClientStateEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableVertexArrayAttribEXT(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glEnableVertexArrayEXT(GLuint vaobj, GLenum array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glEnableVertexAttribAPPLE(GLuint index, GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glEnableVertexAttribArrayARB(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glEnablei(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    void glEnableiEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glEnableiNV(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    void glEnableiOES(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glEndConditionalRender() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conditional_render")
    void glEndConditionalRenderNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NVX_conditional_render")
    void glEndConditionalRenderNVX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glEndFragmentShaderATI() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glEndOcclusionQueryNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glEndPerfMonitorAMD(GLuint monitor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glEndPerfQueryINTEL(GLuint queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glEndQueryARB(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glEndQueryEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    void glEndQueryIndexed(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_tiled_rendering")
    void glEndTilingQCOM(GLbitfield preserveMask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glEndTransformFeedback() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glEndTransformFeedbackEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glEndTransformFeedbackNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glEndVertexShaderEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glEndVideoCaptureNV(GLuint video_capture_slot) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glEvalCoord1xOES(GLfixed u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glEvalCoord1xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glEvalCoord2xOES(GLfixed u, GLfixed v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glEvalCoord2xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glEvalMapsNV(GLenum target, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_locations")
    void glEvaluateDepthValuesARB() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glExecuteProgramNV(GLenum target, GLuint id, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetBufferPointervQCOM(GLenum target, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetBuffersQCOM(GLuint* buffers, GLint maxBuffers, GLint* numBuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetFramebuffersQCOM(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    void glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar* source, GLint* length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    void glExtGetProgramsQCOM(GLuint* programs, GLint maxPrograms, GLint* numPrograms) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetRenderbuffersQCOM(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    void glExtGetShadersQCOM(GLuint* shaders, GLint maxShaders, GLint* numShaders) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* texels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtGetTexturesQCOM(GLuint* textures, GLint maxTextures, GLint* numTextures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    GLboolean glExtIsProgramBinaryQCOM(GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    void glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glExtractComponentEXT(GLuint res, GLuint src, GLuint num) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glFeedbackBufferxOES(GLsizei n, GLenum type, const GLfixed* buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    GLsync glFenceSync(GLenum condition, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    GLsync glFenceSyncAPPLE(GLenum condition, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    GLint glFinishAsyncSGIX(GLuint* markerp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glFinishFenceAPPLE(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glFinishFenceNV(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glFinishObjectAPPLE(GLenum object, GLint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUNX_constant_data")
    void glFinishTextureSUNX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_map_buffer_range")
    void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_flush_buffer_range")
    void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_map_buffer_range")
    void glFlushMappedBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_pixel_data_range")
    void glFlushPixelDataRangeNV(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_flush_raster")
    void glFlushRasterSGIX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_static_data")
    void glFlushStaticDataIBM(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_range")
    void glFlushVertexArrayRangeAPPLE(GLsizei length, void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_array_range")
    void glFlushVertexArrayRangeNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glFogCoordFormatNV(GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoordPointerEXT(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glFogCoordPointerListIBM(GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoorddEXT(GLdouble coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoorddvEXT(const GLdouble* coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoordfEXT(GLfloat coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    void glFogCoordfvEXT(const GLfloat* coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glFogCoordhNV(GLhalfNV fog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glFogCoordhvNV(const GLhalfNV* fog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_fog_function")
    void glFogFuncSGIS(GLsizei n, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glFogx(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glFogxOES(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glFogxv(GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glFogxvOES(GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentColorMaterialSGIX(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_coverage_to_color")
    void glFragmentCoverageColorNV(GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightModelfSGIX(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightModelfvSGIX(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightModeliSGIX(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightModelivSGIX(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_GREMEDY_frame_terminator")
    void glFrameTerminatorGREMEDY() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_framezoom")
    void glFrameZoomSGIX(GLint factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_framebuffer_no_attachments")
    void glFramebufferParameteri(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_pixel_local_storage2")
    void glFramebufferPixelLocalStorageSizeEXT(GLuint target, GLsizei size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_locations")
    void glFramebufferSampleLocationsfvARB(GLenum target, GLuint start, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_sample_locations")
    void glFramebufferSampleLocationsfvNV(GLenum target, GLuint start, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_framebuffer_downsample")
    void glFramebufferTexture2DDownsampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multisampled_render_to_texture")
    void glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_multisampled_render_to_texture")
    void glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    void glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_geometry_shader")
    void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    void glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_geometry_program4")
    void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    void glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_array")
    void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_framebuffer_downsample")
    void glFramebufferTextureLayerDownsampleIMG(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OVR_multiview_multisampled_render_to_texture")
    void glFramebufferTextureMultisampleMultiviewOVR(GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OVR_multiview")
    void glFramebufferTextureMultiviewOVR(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_geometry_shader")
    void glFramebufferTextureOES(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glFreeObjectBufferATI(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glFrustumf(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glFrustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glFrustumx(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glFrustumxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    GLuint glGenAsyncMarkersSGIX(GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glGenBuffersARB(GLsizei n, GLuint* buffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glGenFencesAPPLE(GLsizei n, GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glGenFencesNV(GLsizei n, GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    GLuint glGenFragmentShadersATI(GLuint range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGenFramebuffers(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGenFramebuffersEXT(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGenFramebuffersOES(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_name_gen_delete")
    void glGenNamesAMD(GLenum identifier, GLuint num, GLuint* names) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glGenOcclusionQueriesNV(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLuint glGenPathsNV(GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGenPerfMonitorsAMD(GLsizei n, GLuint* monitors) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glGenProgramPipelines(GLsizei n, GLuint* pipelines) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glGenProgramPipelinesEXT(GLsizei n, GLuint* pipelines) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGenProgramsARB(GLsizei n, GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGenProgramsNV(GLsizei n, GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glGenQueriesARB(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGenQueriesEXT(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGenRenderbuffers(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGenRenderbuffersEXT(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGenRenderbuffersOES(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGenSamplers(GLsizei count, GLuint* samplers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    void glGenTexturesEXT(GLsizei n, GLuint* textures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glGenTransformFeedbacks(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glGenTransformFeedbacksNV(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    void glGenVertexArrays(GLsizei n, GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    void glGenVertexArraysAPPLE(GLsizei n, GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    void glGenVertexArraysOES(GLsizei n, GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLuint glGenVertexShadersEXT(GLuint range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGenerateMipmap(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGenerateMipmapEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGenerateMipmapOES(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGenerateTextureMipmap(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGenerateTextureMipmapEXT(GLuint texture, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_shader_atomic_counters")
    void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_shader")
    void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetArrayObjectivATI(GLenum array, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB* obj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_shader")
    GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetBooleanIndexedvEXT(GLenum target, GLuint index, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetBooleani_v(GLenum target, GLuint index, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    void glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glGetBufferPointervARB(GLenum target, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_mapbuffer")
    void glGetBufferPointervOES(GLenum target, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetClipPlanef(GLenum plane, GLfloat* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glGetClipPlanefOES(GLenum plane, GLfloat* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetClipPlanex(GLenum plane, GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetClipPlanexOES(GLenum plane, GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    void glGetColorTableEXT(GLenum target, GLenum format, GLenum type, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    void glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    void glGetColorTableSGI(GLenum target, GLenum format, GLenum type, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners2")
    void glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    GLuint glGetCommandHeaderNV(GLenum tokenID, GLuint size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    void glGetCompressedTexImageARB(GLenum target, GLint level, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_get_texture_sub_image")
    void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetConvolutionParameterxvOES(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_mixed_samples")
    void glGetCoverageModulationTableNV(GLsizei bufsize, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    GLuint glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    GLuint glGetDebugMessageLogARB(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    GLuint glGetDebugMessageLogKHR(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_detail_texture")
    void glGetDetailTexFuncSGIS(GLenum target, GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glGetDoublei_v(GLenum target, GLuint index, GLdouble* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetDoublei_vEXT(GLenum pname, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    void glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar* driverControlString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    void glGetDriverControlsQCOM(GLint* num, GLsizei size, GLuint* driverControls) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glGetFenceivNV(GLuint fence, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    void glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetFirstPerfQueryIdINTEL(GLuint* queryId) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetFixedv(GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetFixedvOES(GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glGetFloati_v(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetFloati_vEXT(GLenum pname, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glGetFloati_vNV(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glGetFloati_vOES(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_fog_function")
    void glGetFogFuncSGIS(GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_blend_func_extended")
    GLint glGetFragDataIndex(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    GLint glGetFragDataIndexEXT(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    GLint glGetFragDataLocation(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    GLint glGetFragDataLocationEXT(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_framebuffer_no_attachments")
    void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_pixel_local_storage2")
    GLsizei glGetFramebufferPixelLocalStorageSizeEXT(GLuint target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    GLenum glGetGraphicsResetStatus() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    GLenum glGetGraphicsResetStatusARB() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    GLenum glGetGraphicsResetStatusEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    GLenum glGetGraphicsResetStatusKHR() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    GLhandleARB glGetHandleARB(GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetHistogramParameterxvOES(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLuint64 glGetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLuint64 glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB* infoLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    GLint glGetInstrumentsSGIX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    void glGetInteger64i_v(GLenum target, GLuint index, GLint64* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    void glGetInteger64v(GLenum pname, GLint64* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    void glGetInteger64vAPPLE(GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetIntegerIndexedvEXT(GLenum target, GLuint index, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetIntegeri_v(GLenum target, GLuint index, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multiview_draw_buffers")
    void glGetIntegeri_vEXT(GLenum target, GLuint index, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glGetIntegerui64i_vNV(GLenum value, GLuint index, GLuint64EXT* result) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glGetIntegerui64vNV(GLenum value, GLuint64EXT* result) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_internalformat_sample_query")
    void glGetInternalformatSampleivNV(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_internalformat_query2")
    void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_internalformat_query")
    void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetLightxOES(GLenum light, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetLightxv(GLenum light, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetLightxvOES(GLenum light, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glGetListParameterivSGIX(GLuint list, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glGetMapParameterivNV(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetMapxvOES(GLenum target, GLenum query, GLfixed* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetMaterialxOES(GLenum face, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetMaterialxv(GLenum face, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetMaterialxvOES(GLenum face, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat* val) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_explicit_multisample")
    void glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat* val) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glGetNamedStringARB(GLint namelen, const GLchar* name, GLsizei bufSize, GLint* stringlen, GLchar* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glGetNamedStringivARB(GLint namelen, const GLchar* name, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetNextPerfQueryIdINTEL(GLuint queryId, GLuint* nextQueryId) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_label")
    void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetObjectLabelKHR(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_object_purgeable")
    void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetObjectPtrLabel(const void* ptr, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetObjectPtrLabelKHR(const void* ptr, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    void glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathColorGenivNV(GLenum color, GLenum pname, GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathCommandsNV(GLuint path, GLubyte* commands) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathCoordsNV(GLuint path, GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathDashArrayNV(GLuint path, GLfloat* dashArray) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLfloat glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLsizei stride, GLfloat* metrics) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathParameterfvNV(GLuint path, GLenum pname, GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathParameterivNV(GLuint path, GLenum pname, GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat* returnedSpacing) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetPerfCounterInfoINTEL(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar* counterDesc, GLuint* counterOffset, GLuint* counterDataSize, GLuint* counterTypeEnum, GLuint* counterDataTypeEnum, GLuint64* rawCounterMaxValue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorCountersAMD(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glGetPerfMonitorGroupsAMD(GLint* numGroups, GLsizei groupsSize, GLuint* groups) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetPerfQueryDataINTEL(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid* data, GLuint* bytesWritten) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetPerfQueryIdByNameINTEL(GLchar* queryName, GLuint* queryId) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    void glGetPerfQueryInfoINTEL(GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint* dataSize, GLuint* noCounters, GLuint* noInstances, GLuint* capsMask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetPixelMapxv(GLenum map, GLint size, GLfixed* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glGetPixelTexGenParameterivSGIS(GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetPointerIndexedvEXT(GLenum target, GLuint index, void** data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetPointeri_vEXT(GLenum pname, GLuint index, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glGetPointervEXT(GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glGetPointervKHR(GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_get_program_binary")
    void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_get_program_binary")
    void glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const(GLubyte)* name, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const(GLubyte)* name, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glGetProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glGetProgramPipelineivEXT(GLuint pipeline, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    GLint glGetProgramResourceLocationIndexEXT(GLuint program, GLenum programInterface, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glGetProgramResourcefvNV(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei* length, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei* length, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramStringARB(GLenum target, GLenum pname, void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetProgramStringNV(GLuint id, GLenum pname, GLubyte* program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program5")
    void glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glGetProgramivARB(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetProgramivNV(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_timer_query")
    void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryObjectivEXT(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_timer_query")
    void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    void glGetQueryivARB(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glGetQueryivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glGetSamplerParameterIivEXT(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glGetSamplerParameterIivOES(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glGetSamplerParameterIuivEXT(GLuint sampler, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glGetSamplerParameterIuivOES(GLuint sampler, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, void* row, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB* source) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_sharpen_texture")
    void glGetSharpenTexFuncSGIS(GLenum target, GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    GLushort glGetStageIndexNV(GLenum shadertype) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    const(GLubyte)* glGetStringi(GLenum name, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    void glGetSyncivAPPLE(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    void glGetTexBumpParameterfvATI(GLenum pname, GLfloat* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    void glGetTexBumpParameterivATI(GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetTexEnvxv(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetTexEnvxvOES(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture_filter4")
    void glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glGetTexGenivOES(GLenum coord, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetTexLevelParameterxvOES(GLenum target, GLint level, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetTexParameterIiv(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glGetTexParameterIivOES(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glGetTexParameterIuivOES(GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_texture_range")
    void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glGetTexParameterxv(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glGetTexParameterxvOES(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLuint64 glGetTextureHandleARB(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    GLuint64 glGetTextureHandleIMG(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLuint64 glGetTextureHandleNV(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTextureParameteriv(GLuint texture, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLuint64 glGetTextureSamplerHandleARB(GLuint texture, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    GLuint64 glGetTextureSamplerHandleIMG(GLuint texture, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLuint64 glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_get_texture_sub_image")
    void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint* location) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_translated_shader_source")
    void glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    GLuint glGetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_bindable_uniform")
    GLint glGetUniformBufferSizeEXT(GLuint program, GLint location) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glGetUniformIndices(GLuint program, GLsizei uniformCount, const(const(GLvoid*)*) uniformNames, GLuint* uniformIndices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_bindable_uniform")
    GLintptr glGetUniformOffsetEXT(GLuint program, GLint location) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glGetUniformdv(GLuint program, GLint location, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glGetUniformi64vARB(GLuint program, GLint location, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glGetUniformui64vARB(GLuint program, GLint location, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetUniformuiv(GLuint program, GLint location, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glGetUniformuivEXT(GLuint program, GLint location, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetVariantIntegervEXT(GLuint id, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glGetVariantPointervEXT(GLuint id, GLenum value, void** data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    GLint glGetVaryingLocationNV(GLuint program, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, void** param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, void** param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_attrib_array_object")
    void glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_attrib_array_object")
    void glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glGetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glGetVertexAttribPointervARB(GLuint index, GLenum pname, void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetVertexAttribPointervNV(GLuint index, GLenum pname, void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glGetVertexAttribivNV(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glGetVideoivNV(GLuint video_slot, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnColorTable(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnCompressedTexImage(GLenum target, GLint lod, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnConvolutionFilter(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnMapdv(GLenum target, GLenum query, GLsizei bufSize, GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnMapfv(GLenum target, GLenum query, GLsizei bufSize, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnMapiv(GLenum target, GLenum query, GLsizei bufSize, GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnPixelMapfv(GLenum map, GLsizei bufSize, GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnPixelMapuiv(GLenum map, GLsizei bufSize, GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnPixelMapusv(GLenum map, GLsizei bufSize, GLushort* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnPolygonStipple(GLsizei bufSize, GLubyte* pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnPolygonStippleARB(GLsizei bufSize, GLubyte* pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnSeparableFilter(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    void glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    void glGetnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformfvKHR(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glGetnUniformi64vARB(GLuint program, GLint location, GLsizei bufSize, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    void glGetnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformivKHR(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glGetnUniformui64vARB(GLuint program, GLint location, GLsizei bufSize, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    void glGetnUniformuivKHR(GLuint program, GLint location, GLsizei bufSize, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorbSUN(GLbyte factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactordSUN(GLdouble factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorfSUN(GLfloat factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactoriSUN(GLint factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorsSUN(GLshort factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorubSUN(GLubyte factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactoruiSUN(GLuint factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    void glGlobalAlphaFactorusSUN(GLushort factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_PGI_misc_hints")
    void glHintPGI(GLenum target, GLint mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_igloo_interface")
    void glIglooInterfaceSGIX(GLenum pname, const void* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    void glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_x11_sync_object")
    GLsync glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glIndexFormatNV(GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_index_func")
    void glIndexFuncEXT(GLenum func, GLclampf ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_index_material")
    void glIndexMaterialEXT(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glIndexPointerListIBM(GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glIndexxOES(GLfixed component) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glIndexxvOES(const GLfixed* component) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glInsertComponentEXT(GLuint res, GLuint src, GLuint num) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_marker")
    void glInsertEventMarkerEXT(GLsizei length, const GLchar* marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    void glInstrumentsBufferSGIX(GLsizei size, GLint* buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateBufferData(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateTexImage(GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    GLboolean glIsAsyncMarkerSGIX(GLuint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    GLboolean glIsBufferARB(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    GLboolean glIsBufferResidentNV(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    GLboolean glIsCommandListNV(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    GLboolean glIsEnabledi(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    GLboolean glIsEnablediEXT(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    GLboolean glIsEnablediNV(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    GLboolean glIsEnablediOES(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    GLboolean glIsFenceAPPLE(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    GLboolean glIsFenceNV(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    GLboolean glIsFramebuffer(GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    GLboolean glIsFramebufferEXT(GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    GLboolean glIsFramebufferOES(GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLboolean glIsImageHandleResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLboolean glIsImageHandleResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_name_gen_delete")
    GLboolean glIsNameAMD(GLenum identifier, GLuint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    GLboolean glIsNamedBufferResidentNV(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    GLboolean glIsNamedStringARB(GLint namelen, const GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    GLboolean glIsObjectBufferATI(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    GLboolean glIsOcclusionQueryNV(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLboolean glIsPathNV(GLuint path) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLboolean glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLboolean glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    GLboolean glIsProgramARB(GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    GLboolean glIsProgramNV(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    GLboolean glIsProgramPipeline(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    GLboolean glIsProgramPipelineEXT(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    GLboolean glIsQueryARB(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    GLboolean glIsQueryEXT(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    GLboolean glIsRenderbuffer(GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    GLboolean glIsRenderbufferEXT(GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    GLboolean glIsRenderbufferOES(GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    GLboolean glIsSampler(GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    GLboolean glIsStateNV(GLuint state) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    GLboolean glIsSync(GLsync sync) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    GLboolean glIsSyncAPPLE(GLsync sync) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    GLboolean glIsTextureEXT(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    GLboolean glIsTextureHandleResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    GLboolean glIsTextureHandleResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    GLboolean glIsTransformFeedback(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    GLboolean glIsTransformFeedbackNV(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    GLboolean glIsVariantEnabledEXT(GLuint id, GLenum cap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    GLboolean glIsVertexArray(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    GLboolean glIsVertexArrayAPPLE(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    GLboolean glIsVertexArrayOES(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_label")
    void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    void glLightEnviSGIX(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLightModelx(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLightModelxOES(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLightModelxv(GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLightModelxvOES(GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLightx(GLenum light, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLightxOES(GLenum light, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLightxv(GLenum light, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLightxvOES(GLenum light, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLineWidthx(GLfixed width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLineWidthxOES(GLfixed width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glLinkProgramARB(GLhandleARB programObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glListDrawCommandsStatesClientNV(GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glListParameteriSGIX(GLuint list, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    void glListParameterivSGIX(GLuint list, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    void glLoadIdentityDeformationMapSGIX(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glLoadMatrixx(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLoadMatrixxOES(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    void glLoadPaletteFromModelViewMatrixOES() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const(GLubyte)* program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    void glLoadTransposeMatrixdARB(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    void glLoadTransposeMatrixfARB(const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glLoadTransposeMatrixxOES(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_compiled_vertex_array")
    void glLockArraysEXT(GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glMakeBufferNonResidentNV(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glMakeBufferResidentNV(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glMakeImageHandleNonResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glMakeImageHandleNonResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glMakeImageHandleResidentARB(GLuint64 handle, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glMakeImageHandleResidentNV(GLuint64 handle, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glMakeNamedBufferNonResidentNV(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glMakeNamedBufferResidentNV(GLuint buffer, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glMakeTextureHandleNonResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glMakeTextureHandleNonResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glMakeTextureHandleResidentARB(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glMakeTextureHandleResidentNV(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMap1xOES(GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMap2xOES(GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    void* glMapBufferARB(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_mapbuffer")
    void* glMapBufferOES(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_map_buffer_range")
    void* glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_map_buffer_range")
    void* glMapBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMapGrid1xOES(GLint n, GLfixed u1, GLfixed u2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMapGrid2xOES(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void* glMapNamedBuffer(GLuint buffer, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void* glMapNamedBufferEXT(GLuint buffer, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void* glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void* glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_map_object_buffer")
    void* glMapObjectBufferATI(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    void glMapParameterivNV(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_map_texture")
    void* glMapTexture2DINTEL(GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum* layout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glMaterialx(GLenum face, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMaterialxOES(GLenum face, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glMaterialxv(GLenum face, GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMaterialxvOES(GLenum face, GLenum pname, const GLfixed* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    void glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glMatrixIndexubvARB(GLint size, const(GLubyte)* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glMatrixIndexuivARB(GLint size, const GLuint* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    void glMatrixIndexusvARB(GLint size, const GLushort* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixLoad3x2fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixLoad3x3fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoadIdentityEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixLoadTranspose3x3fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoadTransposedEXT(GLenum mode, const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoadTransposefEXT(GLenum mode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoaddEXT(GLenum mode, const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixLoadfEXT(GLenum mode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixMult3x2fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixMult3x3fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glMatrixMultTranspose3x3fNV(GLenum matrixMode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixMultTransposedEXT(GLenum mode, const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixMultTransposefEXT(GLenum mode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixMultdEXT(GLenum mode, const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixMultfEXT(GLenum mode, const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixPopEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixPushEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_parallel_shader_compile")
    void glMaxShaderCompilerThreadsARB(GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_shader_image_load_store")
    void glMemoryBarrier(GLbitfield barriers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_ES3_1_compatibility")
    void glMemoryBarrierByRegion(GLbitfield barriers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_image_load_store")
    void glMemoryBarrierEXT(GLbitfield barriers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    void glMinSampleShading(GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_shading")
    void glMinSampleShadingARB(GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_sample_shading")
    void glMinSampleShadingOES(GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glMultMatrixx(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultMatrixxOES(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    void glMultTransposeMatrixdARB(const GLdouble* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    void glMultTransposeMatrixfARB(const GLfloat* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultTransposeMatrixxOES(const GLfixed* m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_arrays")
    void glMultiDrawArraysEXT(GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_multi_draw_indirect")
    void glMultiDrawArraysIndirect(GLenum mode, const void* indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_multi_draw_indirect")
    void glMultiDrawArraysIndirectAMD(GLenum mode, const void* indirect, GLsizei primcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect_count")
    void glMultiDrawArraysIndirectBindlessCountNV(GLenum mode, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect")
    void glMultiDrawArraysIndirectBindlessNV(GLenum mode, const void* indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_indirect_parameters")
    void glMultiDrawArraysIndirectCountARB(GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_indirect")
    void glMultiDrawArraysIndirectEXT(GLenum mode, const void* indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei drawcount, const GLint* basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    void glMultiDrawElementsBaseVertexEXT(GLenum mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount, const GLint* basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    void glMultiDrawElementsBaseVertexOES(GLenum mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount, const GLint* basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_arrays")
    void glMultiDrawElementsEXT(GLenum mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_multi_draw_indirect")
    void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_multi_draw_indirect")
    void glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const void* indirect, GLsizei primcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect_count")
    void glMultiDrawElementsIndirectBindlessCountNV(GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect")
    void glMultiDrawElementsIndirectBindlessNV(GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_indirect_parameters")
    void glMultiDrawElementsIndirectCountARB(GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_indirect")
    void glMultiDrawElementsIndirectEXT(GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei* count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_multimode_draw_arrays")
    void glMultiModeDrawArraysIBM(const GLenum* mode, const GLint* first, const GLsizei* count, GLsizei primcount, GLint modestride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_multimode_draw_arrays")
    void glMultiModeDrawElementsIBM(const GLenum* mode, const GLsizei* count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount, GLint modestride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord1bOES(GLenum texture, GLbyte s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord1bvOES(GLenum texture, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1dARB(GLenum target, GLdouble s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1dvARB(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1fARB(GLenum target, GLfloat s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1fvARB(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord1hNV(GLenum target, GLhalfNV s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord1hvNV(GLenum target, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1iARB(GLenum target, GLint s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1ivARB(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1sARB(GLenum target, GLshort s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord1svARB(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord1xOES(GLenum texture, GLfixed s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord1xvOES(GLenum texture, const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord2bOES(GLenum texture, GLbyte s, GLbyte t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord2bvOES(GLenum texture, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2dvARB(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2fvARB(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord2hvNV(GLenum target, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2ivARB(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord2svARB(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord2xOES(GLenum texture, GLfixed s, GLfixed t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord2xvOES(GLenum texture, const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord3bOES(GLenum texture, GLbyte s, GLbyte t, GLbyte r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord3bvOES(GLenum texture, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3dvARB(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3fvARB(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord3hvNV(GLenum target, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3ivARB(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord3svARB(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord3xOES(GLenum texture, GLfixed s, GLfixed t, GLfixed r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord3xvOES(GLenum texture, const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord4bOES(GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glMultiTexCoord4bvOES(GLenum texture, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4dvARB(GLenum target, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4fvARB(GLenum target, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glMultiTexCoord4hvNV(GLenum target, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4ivARB(GLenum target, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    void glMultiTexCoord4svARB(GLenum target, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glMultiTexCoord4x(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord4xOES(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glMultiTexCoord4xvOES(GLenum texture, const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void* data, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const void* data, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_buffer")
    void glNamedBufferPageCommitmentARB(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_buffer")
    void glNamedBufferPageCommitmentEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void* data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedBufferStorageEXT(GLuint buffer, GLsizeiptr size, const void* data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum* bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum src) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_locations")
    void glNamedFramebufferSampleLocationsfvARB(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_sample_locations")
    void glNamedFramebufferSampleLocationsfvNV(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    void glNamedStringARB(GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    GLuint glNewObjectBufferATI(GLsizei size, const void* pointer, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glNormal3fVertex3fvSUN(const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glNormal3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glNormal3xOES(GLfixed nx, GLfixed ny, GLfixed nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glNormal3xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glNormalFormatNV(GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glNormalP3ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glNormalP3uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glNormalPointerListIBM(GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    void glNormalPointervINTEL(GLenum type, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3bATI(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3bvATI(GLenum stream, const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3dATI(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3fATI(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3iATI(GLenum stream, GLint nx, GLint ny, GLint nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3sATI(GLenum stream, GLshort nx, GLshort ny, GLshort nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glNormalStream3svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glObjectLabelKHR(GLenum identifier, GLuint name, GLsizei length, const GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glObjectPtrLabel(const void* ptr, GLsizei length, const GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glObjectPtrLabelKHR(const void* ptr, GLsizei length, const GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_object_purgeable")
    GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_object_purgeable")
    GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glOrthof(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    void glOrthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glOrthox(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glOrthoxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_pn_triangles")
    void glPNTrianglesfATI(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_pn_triangles")
    void glPNTrianglesiATI(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPassThroughxOES(GLfixed token) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_tessellation_shader")
    void glPatchParameterfv(GLenum pname, const GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_tessellation_shader")
    void glPatchParameteri(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_tessellation_shader")
    void glPatchParameteriEXT(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_tessellation_shader")
    void glPatchParameteriOES(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathCommandsNV(GLuint path, GLsizei numCommands, const(GLubyte)* commands, GLsizei numCoords, GLenum coordType, const void* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const void* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathCoverDepthFuncNV(GLenum func) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat* dashArray) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathFogGenNV(GLenum genMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLenum glPathGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLenum glPathGlyphIndexRangeNV(GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void* charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLenum glPathMemoryGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void* fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathParameterfNV(GLuint path, GLenum pname, GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathParameteriNV(GLuint path, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathParameterivNV(GLuint path, GLenum pname, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathStencilFuncNV(GLenum func, GLint ref_, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathStringNV(GLuint path, GLenum format, GLsizei length, const void* pathString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const(GLubyte)* commands, GLsizei numCoords, GLenum coordType, const void* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glPauseTransformFeedback() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glPauseTransformFeedbackNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_pixel_data_range")
    void glPixelDataRangeNV(GLenum target, GLsizei length, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPixelMapx(GLenum map, GLint size, const GLfixed* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPixelStorex(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glPixelTexGenParameteriSGIS(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    void glPixelTexGenParameterivSGIS(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_pixel_texture")
    void glPixelTexGenSGIX(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPixelTransferxOES(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glPixelTransformParameterfEXT(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glPixelTransformParameteriEXT(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    void glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPixelZoomxOES(GLfixed xfactor, GLfixed yfactor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    GLboolean glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat* y, GLfloat* tangentX, GLfloat* tangentY) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_point_parameters")
    void glPointParameterfARB(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_point_parameters")
    void glPointParameterfEXT(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_point_parameters")
    void glPointParameterfSGIS(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_point_parameters")
    void glPointParameterfvARB(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_point_parameters")
    void glPointParameterfvEXT(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_point_parameters")
    void glPointParameterfvSGIS(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_point_sprite")
    void glPointParameteriNV(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_point_sprite")
    void glPointParameterivNV(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPointParameterx(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPointParameterxOES(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPointParameterxv(GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPointParameterxvOES(GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_point_size_array")
    void glPointSizePointerOES(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPointSizex(GLfixed size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPointSizexOES(GLfixed size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    GLint glPollAsyncSGIX(GLuint* markerp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    GLint glPollInstrumentsSGIX(GLint* marker_p) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_polygon_mode")
    void glPolygonModeNV(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_polygon_offset_clamp")
    void glPolygonOffsetClampEXT(GLfloat factor, GLfloat units, GLfloat clamp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_polygon_offset")
    void glPolygonOffsetEXT(GLfloat factor, GLfloat bias) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPolygonOffsetx(GLfixed factor, GLfixed units) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPolygonOffsetxOES(GLfixed factor, GLfixed units) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glPopDebugGroup() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glPopDebugGroupKHR() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_marker")
    void glPopGroupMarkerEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    void glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glPrimitiveBoundingBox(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_ES3_2_compatibility")
    void glPrimitiveBoundingBoxARB(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_primitive_bounding_box")
    void glPrimitiveBoundingBoxEXT(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_primitive_bounding_box")
    void glPrimitiveBoundingBoxOES(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    void glPrimitiveRestartIndex(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_primitive_restart")
    void glPrimitiveRestartIndexNV(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_primitive_restart")
    void glPrimitiveRestartNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    void glPrioritizeTexturesEXT(GLsizei n, const GLuint* textures, const GLclampf* priorities) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glPrioritizeTexturesxOES(GLsizei n, const GLuint* textures, const GLfixed* priorities) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_get_program_binary")
    void glProgramBinary(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_get_program_binary")
    void glProgramBinaryOES(GLuint program, GLenum binaryFormat, const void* binary, GLint length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_parameter_buffer_object")
    void glProgramBufferParametersIivNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_parameter_buffer_object")
    void glProgramBufferParametersIuivNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_parameter_buffer_object")
    void glProgramBufferParametersfvNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_program_parameters")
    void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_program_parameters")
    void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    void glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glProgramNamedParameter4dNV(GLuint id, GLsizei len, const(GLubyte)* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const(GLubyte)* name, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glProgramNamedParameter4fNV(GLuint id, GLsizei len, const(GLubyte)* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    void glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const(GLubyte)* name, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_get_program_binary")
    void glProgramParameteri(GLuint program, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    void glProgramParameteriARB(GLuint program, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_geometry_shader4")
    void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glProgramPathFragmentInputGenNV(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program5")
    void glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1d(GLuint program, GLint location, GLdouble v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1f(GLuint program, GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1i(GLuint program, GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform1i64ARB(GLuint program, GLint location, GLint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform1i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1iEXT(GLuint program, GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1ui(GLuint program, GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform1ui64ARB(GLuint program, GLint location, GLuint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform1ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform2i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform2i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform2ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform2ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform3i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform3i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform3ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform3ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform4i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform4i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform4ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glProgramUniform4ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glProgramUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    void glProgramUniformHandleui64IMG(GLuint program, GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glProgramUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    void glProgramUniformHandleui64vIMG(GLuint program, GLint location, GLsizei count, const GLuint64* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_geometry_program4")
    void glProgramVertexLimitNV(GLenum target, GLint limit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_provoking_vertex")
    void glProvokingVertex(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_provoking_vertex")
    void glProvokingVertexEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glPushClientAttribDefaultEXT(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar* message) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    void glPushDebugGroupKHR(GLenum source, GLuint id, GLsizei length, const GLchar* message) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_marker")
    void glPushGroupMarkerEXT(GLsizei length, const GLchar* marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_timer_query")
    void glQueryCounter(GLuint id, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    void glQueryCounterEXT(GLuint id, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_query_matrix")
    GLbitfield glQueryMatrixxOES(GLfixed* mantissa, GLint* exponent) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_occlusion_query_event")
    void glQueryObjectParameteruiAMD(GLenum target, GLuint id, GLenum pname, GLuint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos2xOES(GLfixed x, GLfixed y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos2xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos3xOES(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos3xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos4xOES(GLfixed x, GLfixed y, GLfixed z, GLfixed w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRasterPos4xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_raster_multisample")
    void glRasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multiview_draw_buffers")
    void glReadBufferIndexedEXT(GLenum src, GLint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_read_buffer")
    void glReadBufferNV(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    void glReadInstrumentsSGIX(GLint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    void glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    void glReadnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    void glReadnPixelsKHR(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRectxOES(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRectxvOES(const GLfixed* v1, const GLfixed* v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_reference_plane")
    void glReferencePlaneSGIX(const GLdouble* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glReleaseShaderCompiler() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_framebuffer_multisample")
    void glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_framebuffer_multisample")
    void glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_multisample_coverage")
    void glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_multisample")
    void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_multisampled_render_to_texture")
    void glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_multisample")
    void glRenderbufferStorageMultisampleNV(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    void glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodePointerSUN(GLenum type, GLsizei stride, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeubSUN(GLubyte code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeubvSUN(const(GLubyte)* code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor3fVertex3fvSUN(const GLuint* rc, const GLfloat* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint* rc, const(GLubyte)* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeuiSUN(GLuint code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* tc, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint* rc, const GLfloat* tc, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glReplacementCodeuiVertex3fvSUN(const GLuint* rc, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeuivSUN(const GLuint* code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeusSUN(GLushort code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    void glReplacementCodeusvSUN(const GLushort* code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glRequestResidentProgramsNV(GLsizei n, const GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glResetHistogramEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    void glResetMinmaxEXT(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_resize_buffers")
    void glResizeBuffersMESA() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_sample_locations")
    void glResolveDepthValuesNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_framebuffer_multisample")
    void glResolveMultisampleFramebufferAPPLE() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    void glResumeTransformFeedback() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    void glResumeTransformFeedbackNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glRotatexOES(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multisample")
    void glSampleCoverageARB(GLfloat value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glSampleCoveragex(GLclampx value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glSampleCoveragexOES(GLclampx value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multisample")
    void glSampleMaskEXT(GLclampf value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_explicit_multisample")
    void glSampleMaskIndexedNV(GLuint index, GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_multisample")
    void glSampleMaskSGIS(GLclampf value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    void glSampleMaski(GLuint maskNumber, GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multisample")
    void glSamplePatternEXT(GLenum pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_multisample")
    void glSamplePatternSGIS(GLenum pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glSamplerParameterIivEXT(GLuint sampler, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glSamplerParameterIivOES(GLuint sampler, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glSamplerParameterIuivEXT(GLuint sampler, GLenum pname, const GLuint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glSamplerParameterIuivOES(GLuint sampler, GLenum pname, const GLuint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glScalex(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glScalexOES(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glScissorArrayv(GLuint first, GLsizei count, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glScissorArrayvNV(GLuint first, GLsizei count, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glScissorArrayvOES(GLuint first, GLsizei count, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glScissorIndexedNV(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glScissorIndexedOES(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glScissorIndexedv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glScissorIndexedvNV(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glScissorIndexedvOES(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3bvEXT(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3dvEXT(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3fvEXT(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glSecondaryColor3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3ivEXT(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3svEXT(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3ubvEXT(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3uivEXT(const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColor3usvEXT(const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glSecondaryColorP3ui(GLenum type, GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glSecondaryColorP3uiv(GLenum type, const GLuint* color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    void glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    void glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* row, const void* column) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    void glSetFenceAPPLE(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    void glSetFenceNV(GLuint fence, GLenum condition) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    void glSetFragmentShaderConstantATI(GLuint dst, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glSetInvariantEXT(GLuint id, GLenum type, const void* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glSetLocalConstantEXT(GLuint id, GLenum type, const void* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_sample_positions")
    void glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat* val) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    void glShaderBinary(GLsizei count, const GLuint* shaders, GLenum binaryformat, const void* binary, GLsizei length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB** string, const GLint* length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_shader_storage_buffer_object")
    void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_sharpen_texture")
    void glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    void glSpriteParameterfSGIX(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    void glSpriteParameterfvSGIX(GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    void glSpriteParameteriSGIX(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    void glSpriteParameterivSGIX(GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    void glStartInstrumentsSGIX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_tiled_rendering")
    void glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    void glStateCaptureNV(GLuint state, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_stencil_clear_tag")
    void glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_separate_stencil")
    void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref_, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_separate_stencil")
    void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_stencil_operation_extended")
    void glStencilOpValueAMD(GLenum face, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilThenCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilThenCoverFillPathNV(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilThenCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glStencilThenCoverStrokePathNV(GLuint path, GLint reference, GLuint mask, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    void glStopInstrumentsSGIX(GLint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_GREMEDY_string_marker")
    void glStringMarkerGREMEDY(GLsizei len, const void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conservative_raster")
    void glSubpixelPrecisionBiasNV(GLuint xbits, GLuint ybits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glSwizzleEXT(GLuint res, GLuint in_, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_map_texture")
    void glSyncTextureINTEL(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_tag_sample_buffer")
    void glTagSampleBufferSGIX() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3bvEXT(const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3dvEXT(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3fvEXT(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3iEXT(GLint tx, GLint ty, GLint tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3ivEXT(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangent3svEXT(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    void glTangentPointerEXT(GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_3DFX_tbuffer")
    void glTbufferMask3DFX(GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_vertex_shader_tessellator")
    void glTessellationFactorAMD(GLfloat factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_vertex_shader_tessellator")
    void glTessellationModeAMD(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    GLboolean glTestFenceAPPLE(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    GLboolean glTestFenceNV(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    GLboolean glTestObjectAPPLE(GLenum object, GLuint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_buffer_object")
    void glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_buffer")
    void glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_buffer")
    void glTexBufferOES(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_buffer_range")
    void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_buffer")
    void glTexBufferRangeEXT(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_buffer")
    void glTexBufferRangeOES(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    void glTexBumpParameterfvATI(GLenum pname, const GLfloat* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    void glTexBumpParameterivATI(GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord1bOES(GLbyte s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord1bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord1hNV(GLhalfNV s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord1hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord1xOES(GLfixed s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord1xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord2bOES(GLbyte s, GLbyte t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord2bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor3fVertex3fvSUN(const GLfloat* tc, const GLfloat* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fColor4ubVertex3fvSUN(const GLfloat* tc, const(GLubyte)* c, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fNormal3fVertex3fvSUN(const GLfloat* tc, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord2fVertex3fvSUN(const GLfloat* tc, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord2hNV(GLhalfNV s, GLhalfNV t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord2hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord2xOES(GLfixed s, GLfixed t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord2xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord3bOES(GLbyte s, GLbyte t, GLbyte r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord3bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord3xOES(GLfixed s, GLfixed t, GLfixed r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord3xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord4bOES(GLbyte s, GLbyte t, GLbyte r, GLbyte q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glTexCoord4bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    void glTexCoord4fVertex4fvSUN(const GLfloat* tc, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glTexCoord4hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord4xOES(GLfixed s, GLfixed t, GLfixed r, GLfixed q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexCoord4xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP1ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP1uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP2ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP2uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP3ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP3uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP4ui(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glTexCoordP4uiv(GLenum type, const GLuint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    void glTexCoordPointervINTEL(GLint size, GLenum type, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTexEnvx(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexEnvxOES(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTexEnvxv(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexEnvxvOES(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture_filter4")
    void glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glTexGenfOES(GLenum coord, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glTexGeniOES(GLenum coord, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    void glTexGenivOES(GLenum coord, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexGenxOES(GLenum coord, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture3D")
    void glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture4D")
    void glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_texture")
    void glTexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_sparse_texture")
    void glTexPageCommitmentEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glTexParameterIiv(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glTexParameterIivEXT(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glTexParameterIivOES(GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    void glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    void glTexParameterIuivOES(GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTexParameterx(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexParameterxOES(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTexParameterxv(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTexParameterxvOES(GLenum target, GLenum pname, const GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_explicit_multisample")
    void glTexRenderbufferNV(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_texture_storage")
    void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_storage")
    void glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_texture_storage")
    void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_storage")
    void glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_storage_multisample")
    void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_texture_storage")
    void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_storage")
    void glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_storage_multisample")
    void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_storage_multisample_2d_array")
    void glTexStorage3DMultisampleOES(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_sparse_texture")
    void glTexStorageSparseAMD(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_subtexture")
    void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_subtexture")
    void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture3D")
    void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    void glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture4D")
    void glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_texture_barrier")
    void glTextureBarrier() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_barrier")
    void glTextureBarrierNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture_color_mask")
    void glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    void glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_light_texture")
    void glTextureLightEXT(GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_light_texture")
    void glTextureMaterialEXT(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_perturb_normal")
    void glTextureNormalEXT(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTexturePageCommitmentEXT(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameterIiv(GLuint texture, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameterf(GLuint texture, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameteri(GLuint texture, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureParameteriv(GLuint texture, GLenum pname, const GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_texture_range")
    void glTextureRangeAPPLE(GLenum target, GLsizei length, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_sparse_texture")
    void glTextureStorageSparseAMD(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_view")
    void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_view")
    void glTextureViewEXT(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_view")
    void glTextureViewOES(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glTransformFeedbackAttribsNV(GLsizei count, const GLint* attribs, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glTransformFeedbackStreamAttribsNV(GLsizei count, const GLint* attribs, GLsizei nbuffers, const GLint* bufstreams, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glTransformFeedbackVaryings(GLuint program, GLsizei count, const(const(GLvoid*)*) varyings, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const(const(GLvoid*)*) varyings, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    void glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint* locations, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    void glTranslatex(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glTranslatexOES(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform1d(GLint location, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform1dv(GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform1fARB(GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform1fvARB(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform1i64ARB(GLint location, GLint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform1i64NV(GLint location, GLint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform1i64vARB(GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform1iARB(GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform1ivARB(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform1ui(GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform1ui64ARB(GLint location, GLuint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform1ui64NV(GLint location, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform1ui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform1uiEXT(GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform1uiv(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform1uivEXT(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform2d(GLint location, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform2dv(GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform2fvARB(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform2i64ARB(GLint location, GLint64 x, GLint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform2i64vARB(GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform2iARB(GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform2ivARB(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform2ui(GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform2ui64ARB(GLint location, GLuint64 x, GLuint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform2ui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform2uiv(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform2uivEXT(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform3dv(GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform3fvARB(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform3i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform3i64vARB(GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform3ivARB(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform3ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform3ui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform3uiv(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform3uivEXT(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniform4dv(GLint location, GLsizei count, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform4fvARB(GLint location, GLsizei count, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform4i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform4i64vARB(GLint location, GLsizei count, const GLint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniform4ivARB(GLint location, GLsizei count, const GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform4ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    void glUniform4ui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    void glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glUniform4uiv(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    void glUniform4uivEXT(GLint location, GLsizei count, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_bindable_uniform")
    void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glUniformHandleui64ARB(GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    void glUniformHandleui64IMG(GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glUniformHandleui64NV(GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glUniformHandleui64vARB(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    void glUniformHandleui64vIMG(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    void glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix2x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix2x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix3x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix3x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix4x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    void glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    void glUniformMatrix4x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glUniformui64NV(GLint location, GLuint64EXT value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    void glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_compiled_vertex_array")
    void glUnlockArraysEXT() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    GLboolean glUnmapBufferARB(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_mapbuffer")
    GLboolean glUnmapBufferOES(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    GLboolean glUnmapNamedBuffer(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    GLboolean glUnmapNamedBufferEXT(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_map_object_buffer")
    void glUnmapObjectBufferATI(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_map_texture")
    void glUnmapTexture2DINTEL(GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const void* pointer, GLenum preserve) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glUseProgramObjectARB(GLhandleARB programObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glUseProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glUseShaderProgramEXT(GLenum type, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUFiniNV() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUInitNV(const void* vdpDevice, const void* getProcAddress) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    GLboolean glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    GLvdpauSurfaceNV glVDPAURegisterOutputSurfaceNV(const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    GLvdpauSurfaceNV glVDPAURegisterVideoSurfaceNV(const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUUnmapSurfacesNV(GLsizei numSurface, const GLvdpauSurfaceNV* surfaces) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    void glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    void glValidateProgramARB(GLhandleARB programObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    void glValidateProgramPipeline(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    void glValidateProgramPipelineEXT(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    void glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const void* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantbvEXT(GLuint id, const GLbyte* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantdvEXT(GLuint id, const GLdouble* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantfvEXT(GLuint id, const GLfloat* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantivEXT(GLuint id, const GLint* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantsvEXT(GLuint id, const GLshort* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantubvEXT(GLuint id, const(GLubyte)* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantuivEXT(GLuint id, const GLuint* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glVariantusvEXT(GLuint id, const GLushort* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex2bOES(GLbyte x, GLbyte y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex2bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex2hNV(GLhalfNV x, GLhalfNV y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex2hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex2xOES(GLfixed x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex2xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex3bOES(GLbyte x, GLbyte y, GLbyte z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex3bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex3hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex3xOES(GLfixed x, GLfixed y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex3xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex4bOES(GLbyte x, GLbyte y, GLbyte z, GLbyte w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    void glVertex4bvOES(const GLbyte* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertex4hvNV(const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex4xOES(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    void glVertex4xvOES(const GLfixed* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_range")
    void glVertexArrayParameteriAPPLE(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_range")
    void glVertexArrayRangeAPPLE(GLsizei length, void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_array_range")
    void glVertexArrayRangeNV(GLsizei length, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribDivisorEXT(GLuint vaobj, GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    void glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1dARB(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1dNV(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1dvARB(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1dvNV(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1fARB(GLuint index, GLfloat x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1fNV(GLuint index, GLfloat x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1fvARB(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1fvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib1hNV(GLuint index, GLhalfNV x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib1hvNV(GLuint index, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1sARB(GLuint index, GLshort x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1sNV(GLuint index, GLshort x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib1svARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib1svNV(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2dvARB(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2dvNV(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2fvARB(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2fvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib2hvNV(GLuint index, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib2svARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib2svNV(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3dvARB(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3dvNV(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3fvARB(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3fvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib3hvNV(GLuint index, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib3svARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib3svNV(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NbvARB(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NivARB(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NsvARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NubvARB(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NuivARB(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4NusvARB(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4bvARB(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4dvARB(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4dvNV(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4fvARB(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4fvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttrib4hvNV(GLuint index, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4ivARB(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4svARB(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4svNV(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4ubvARB(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttrib4ubvNV(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4uivARB(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttrib4usvARB(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_attrib_array_object")
    void glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    void glVertexAttribDivisor(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_instanced_arrays")
    void glVertexAttribDivisorANGLE(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_instanced_arrays")
    void glVertexAttribDivisorARB(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_instanced_arrays")
    void glVertexAttribDivisorEXT(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_instanced_arrays")
    void glVertexAttribDivisorNV(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI1i(GLuint index, GLint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI1iEXT(GLuint index, GLint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI1iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI1ivEXT(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI1ui(GLuint index, GLuint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI1uiEXT(GLuint index, GLuint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI1uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI1uivEXT(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI2i(GLuint index, GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI2iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI2ivEXT(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI2ui(GLuint index, GLuint x, GLuint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI2uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI2uivEXT(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI3iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI3ivEXT(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI3uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI3uivEXT(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4bv(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4bvEXT(GLuint index, const GLbyte* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4iv(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4ivEXT(GLuint index, const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4sv(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4svEXT(GLuint index, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4ubv(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4ubvEXT(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4uiv(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4uivEXT(GLuint index, const GLuint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribI4usv(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribI4usvEXT(GLuint index, const GLushort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL1d(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL1dEXT(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL1dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL1dvEXT(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL1i64NV(GLuint index, GLint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL1i64vNV(GLuint index, const GLint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glVertexAttribL1ui64ARB(GLuint index, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    void glVertexAttribL1ui64vARB(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL2dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL2dvEXT(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL2i64vNV(GLuint index, const GLint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL3dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL3dvEXT(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL3i64vNV(GLuint index, const GLint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribL4dv(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribL4dvEXT(GLuint index, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL4i64vNV(GLuint index, const GLint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    void glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    void glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_interleaved_elements")
    void glVertexAttribParameteriAMD(GLuint index, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs1dvNV(GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs1fvNV(GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttribs1hvNV(GLuint index, GLsizei n, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs1svNV(GLuint index, GLsizei count, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs2dvNV(GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs2fvNV(GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttribs2hvNV(GLuint index, GLsizei n, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs2svNV(GLuint index, GLsizei count, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs3dvNV(GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs3fvNV(GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttribs3hvNV(GLuint index, GLsizei n, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs3svNV(GLuint index, GLsizei count, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs4dvNV(GLuint index, GLsizei count, const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs4fvNV(GLuint index, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexAttribs4hvNV(GLuint index, GLsizei n, const GLhalfNV* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs4svNV(GLuint index, GLsizei count, const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    void glVertexAttribs4ubvNV(GLuint index, GLsizei count, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glVertexBlendARB(GLint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexBlendEnvfATI(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexBlendEnviATI(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    void glVertexFormatNV(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP2ui(GLenum type, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP2uiv(GLenum type, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP3ui(GLenum type, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP3uiv(GLenum type, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP4ui(GLenum type, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    void glVertexP4uiv(GLenum type, const GLuint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    void glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    void glVertexPointervINTEL(GLint size, GLenum type, const void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1dATI(GLenum stream, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1fATI(GLenum stream, GLfloat x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1iATI(GLenum stream, GLint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1sATI(GLenum stream, GLshort x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream1svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2iATI(GLenum stream, GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2sATI(GLenum stream, GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream2svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream3svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4dvATI(GLenum stream, const GLdouble* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4fvATI(GLenum stream, const GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4ivATI(GLenum stream, const GLint* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    void glVertexStream4svATI(GLenum stream, const GLshort* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_weighting")
    void glVertexWeightPointerEXT(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_weighting")
    void glVertexWeightfEXT(GLfloat weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_weighting")
    void glVertexWeightfvEXT(const GLfloat* weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexWeighthNV(GLhalfNV weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    void glVertexWeighthvNV(const GLhalfNV* weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    GLenum glVideoCaptureNV(GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT* capture_time) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    void glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glViewportArrayv(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glViewportArrayvNV(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glViewportArrayvOES(GLuint first, GLsizei count, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glViewportIndexedfOES(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glViewportIndexedfNV(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    void glViewportIndexedfv(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    void glViewportIndexedfvOES(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    void glViewportIndexedfvNV(GLuint index, const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_clip_space_w_scaling")
    void glViewportPositionWScaleNV(GLuint index, GLfloat xcoeff, GLfloat ycoeff) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_swizzle")
    void glViewportSwizzleNV(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    void glWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    void glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint* paths, const GLfloat* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    void glWeightPointerOES(GLint size, GLenum type, GLsizei stride, const void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightbvARB(GLint size, const GLbyte* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightdvARB(GLint size, const GLdouble* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightfvARB(GLint size, const GLfloat* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightivARB(GLint size, const GLint* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightsvARB(GLint size, const GLshort* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightubvARB(GLint size, const(GLubyte)* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightuivARB(GLint size, const GLuint* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    void glWeightusvARB(GLint size, const GLushort* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2dARB(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2dMESA(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2dvARB(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2dvMESA(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2fARB(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2fMESA(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2fvARB(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2fvMESA(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2iARB(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2iMESA(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2ivARB(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2ivMESA(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2sARB(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2sMESA(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos2svARB(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos2svMESA(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3dvARB(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3dvMESA(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3fvARB(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3fvMESA(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3iARB(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3iMESA(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3ivARB(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3ivMESA(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3sARB(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3sMESA(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    void glWindowPos3svARB(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos3svMESA(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4dvMESA(const GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4fvMESA(const GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4ivMESA(const GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    void glWindowPos4svMESA(const GLshort* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_window_rectangles")
    void glWindowRectanglesEXT(GLenum mode, GLsizei count, const GLint* box) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    void glWriteMaskEXT(GLuint res, GLuint in_, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) @system @nogc nothrow;
}
